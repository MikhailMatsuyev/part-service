(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/animations'), require('@angular/core'), require('@angular/cdk/keycodes'), require('tslib'), require('@angular/cdk/a11y'), require('@angular/cdk/bidi'), require('@angular/cdk/overlay'), require('@angular/cdk/portal'), require('@angular/common')) :
    typeof define === 'function' && define.amd ? define('@material-extended/mde', ['exports', '@angular/animations', '@angular/core', '@angular/cdk/keycodes', 'tslib', '@angular/cdk/a11y', '@angular/cdk/bidi', '@angular/cdk/overlay', '@angular/cdk/portal', '@angular/common'], factory) :
    (factory((global['material-extended'] = global['material-extended'] || {}, global['material-extended'].mde = {}),global.ng.animations,global.ng.core,global.ng.cdk.keycodes,global.tslib,global.ng.cdk.a11y,global.ng.cdk.bidi,global.ng.cdk.overlay,global.ng.cdk.portal,global.ng.common));
}(this, (function (exports,animations,core,keycodes,tslib_1,a11y,bidi,overlay,portal,common) { 'use strict';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Throws an exception for the case when popover trigger doesn't have a valid mde-popover instance
     * @return {?}
     */
    function throwMdePopoverMissingError() {
        throw Error("mde-popover-trigger: must pass in an mde-popover instance.\n\n    Example:\n      <mde-popover #popover=\"mdePopover\"></mde-popover>\n      <button [mdePopoverTriggerFor]=\"popover\"></button>");
    }
    /**
     * Throws an exception for the case when popover's mdePopoverPositionX value isn't valid.
     * In other words, it doesn't match 'before' or 'after'.
     * @return {?}
     */
    function throwMdePopoverInvalidPositionX() {
        throw Error("mdePopoverPositionX value must be either 'before' or after'.\n      Example: <mde-popover mdePopoverPositionX=\"before\" #popover=\"mdePopover\"></mde-popover>");
    }
    /**
     * Throws an exception for the case when popover's mdePopoverPositionY value isn't valid.
     * In other words, it doesn't match 'above' or 'below'.
     * @return {?}
     */
    function throwMdePopoverInvalidPositionY() {
        throw Error("mdePopoverPositionY value must be either 'above' or below'.\n      Example: <mde-popover mdePopoverPositionY=\"above\" #popover=\"mdePopover\"></mde-popover>");
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * This animation controls the popover panel's entry and exit from the page.
     *
     * When the popover panel is added to the DOM, it scales in and fades in its border.
     *
     * When the popover panel is removed from the DOM, it simply fades out after a brief
     * delay to display the ripple.
     */
    var /** @type {?} */ transformPopover = animations.trigger('transformPopover', [
        animations.state('enter', animations.style({
            opacity: 1,
            transform: "scale(1)"
        })),
        animations.transition('void => *', [
            animations.style({
                opacity: 0,
                transform: "scale(0)"
            }),
            animations.animate("200ms cubic-bezier(0.25, 0.8, 0.25, 1)")
        ]),
        animations.transition('* => void', [
            animations.animate('50ms 100ms linear', animations.style({ opacity: 0 }))
        ])
    ]);

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MdePopover = (function () {
        function MdePopover(_elementRef) {
            this._elementRef = _elementRef;
            // tslint:disable-line:component-class-suffix
            this.role = 'dialog';
            /**
             * Settings for popover, view setters and getters for more detail
             */
            this._positionX = 'after';
            this._positionY = 'below';
            this._triggerEvent = 'hover';
            this._enterDelay = 200;
            this._leaveDelay = 200;
            this._overlapTrigger = true;
            this._targetOffsetX = 0;
            this._targetOffsetY = 0;
            this._arrowOffsetX = 20;
            this._arrowWidth = 8;
            this._arrowColor = 'rgba(0, 0, 0, 0.12)';
            this._closeOnClick = true;
            this._focusTrapEnabled = true;
            /**
             * Config object to be passed into the popover's ngClass
             */
            this._classList = {};
            /**
             *
             */
            this.containerPositioning = false;
            /**
             * Closing disabled on popover
             */
            this.closeDisabled = false;
            /**
             * Emits the current animation state whenever it changes.
             */
            this._onAnimationStateChange = new core.EventEmitter();
            /**
             * Event emitted when the popover is closed.
             */
            this.close = new core.EventEmitter();
            this.setPositionClasses();
        }
        Object.defineProperty(MdePopover.prototype, "positionX", {
            get: /**
             * Position of the popover in the X axis.
             * @return {?}
             */ function () { return this._positionX; },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value !== 'before' && value !== 'after') {
                    throwMdePopoverInvalidPositionX();
                }
                this._positionX = value;
                this.setPositionClasses();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdePopover.prototype, "positionY", {
            get: /**
             * Position of the popover in the Y axis.
             * @return {?}
             */ function () { return this._positionY; },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value !== 'above' && value !== 'below') {
                    throwMdePopoverInvalidPositionY();
                }
                this._positionY = value;
                this.setPositionClasses();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdePopover.prototype, "triggerEvent", {
            get: /**
             * Popover trigger event
             * @return {?}
             */ function () { return this._triggerEvent; },
            set: /**
             * @param {?} v
             * @return {?}
             */ function (v) { this._triggerEvent = v; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdePopover.prototype, "enterDelay", {
            get: /**
             * Popover enter delay
             * @return {?}
             */ function () { return this._enterDelay; },
            set: /**
             * @param {?} v
             * @return {?}
             */ function (v) { this._enterDelay = v; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdePopover.prototype, "leaveDelay", {
            get: /**
             * Popover leave delay
             * @return {?}
             */ function () { return this._leaveDelay; },
            set: /**
             * @param {?} v
             * @return {?}
             */ function (v) { this._leaveDelay = v; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdePopover.prototype, "overlapTrigger", {
            get: /**
             * Popover overlap trigger
             * @return {?}
             */ function () { return this._overlapTrigger; },
            set: /**
             * @param {?} v
             * @return {?}
             */ function (v) { this._overlapTrigger = v; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdePopover.prototype, "targetOffsetX", {
            get: /**
             * Popover target offset x
             * @return {?}
             */ function () { return this._targetOffsetX; },
            set: /**
             * @param {?} v
             * @return {?}
             */ function (v) { this._targetOffsetX = v; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdePopover.prototype, "targetOffsetY", {
            get: /**
             * Popover target offset y
             * @return {?}
             */ function () { return this._targetOffsetY; },
            set: /**
             * @param {?} v
             * @return {?}
             */ function (v) { this._targetOffsetY = v; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdePopover.prototype, "arrowOffsetX", {
            get: /**
             * Popover arrow offset x
             * @return {?}
             */ function () { return this._arrowOffsetX; },
            set: /**
             * @param {?} v
             * @return {?}
             */ function (v) { this._arrowOffsetX = v; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdePopover.prototype, "arrowWidth", {
            get: /**
             * Popover arrow width
             * @return {?}
             */ function () { return this._arrowWidth; },
            set: /**
             * @param {?} v
             * @return {?}
             */ function (v) { this._arrowWidth = v; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdePopover.prototype, "arrowColor", {
            get: /**
             * Popover arrow color
             * @return {?}
             */ function () { return this._arrowColor; },
            set: /**
             * @param {?} v
             * @return {?}
             */ function (v) { this._arrowColor = v; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdePopover.prototype, "closeOnClick", {
            get: /**
             * Popover container close on click
             * default: true
             * @return {?}
             */ function () { return this._closeOnClick; },
            set: /**
             * @param {?} v
             * @return {?}
             */ function (v) { this._closeOnClick = v; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdePopover.prototype, "focusTrapEnabled", {
            get: /**
             * Popover focus trap using cdkTrapFocus
             * default: true
             * @return {?}
             */ function () { return this._focusTrapEnabled; },
            set: /**
             * @param {?} v
             * @return {?}
             */ function (v) { this._focusTrapEnabled = v; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdePopover.prototype, "panelClass", {
            set: /**
             * This method takes classes set on the host md-popover element and applies them on the
             * popover template that displays in the overlay container.  Otherwise, it's difficult
             * to style the containing popover from outside the component.
             * @param {?} classes list of class names
             * @return {?}
             */ function (classes) {
                if (classes && classes.length) {
                    this._classList = classes.split(' ').reduce(function (obj, className) {
                        obj[className] = true;
                        return obj;
                    }, {});
                    this._elementRef.nativeElement.className = '';
                    this.setPositionClasses();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdePopover.prototype, "classList", {
            get: /**
             * This method takes classes set on the host md-popover element and applies them on the
             * popover template that displays in the overlay container.  Otherwise, it's difficult
             * to style the containing popover from outside the component.
             * @deprecated Use `panelClass` instead.
             * @return {?}
             */ function () { return this.panelClass; },
            set: /**
             * @param {?} classes
             * @return {?}
             */ function (classes) { this.panelClass = classes; },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MdePopover.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._emitCloseEvent();
                this.close.complete();
            };
        /** Handle a keyboard event from the popover, delegating to the appropriate action. */
        /**
         * Handle a keyboard event from the popover, delegating to the appropriate action.
         * @param {?} event
         * @return {?}
         */
        MdePopover.prototype._handleKeydown = /**
         * Handle a keyboard event from the popover, delegating to the appropriate action.
         * @param {?} event
         * @return {?}
         */
            function (event) {
                switch (event.keyCode) {
                    case keycodes.ESCAPE:
                        this._emitCloseEvent();
                        return;
                }
            };
        /**
         * This emits a close event to which the trigger is subscribed. When emitted, the
         * trigger will close the popover.
         */
        /**
         * This emits a close event to which the trigger is subscribed. When emitted, the
         * trigger will close the popover.
         * @return {?}
         */
        MdePopover.prototype._emitCloseEvent = /**
         * This emits a close event to which the trigger is subscribed. When emitted, the
         * trigger will close the popover.
         * @return {?}
         */
            function () {
                this.close.emit();
            };
        /** Close popover on click if closeOnClick is true */
        /**
         * Close popover on click if closeOnClick is true
         * @return {?}
         */
        MdePopover.prototype.onClick = /**
         * Close popover on click if closeOnClick is true
         * @return {?}
         */
            function () {
                if (this.closeOnClick) {
                    this._emitCloseEvent();
                }
            };
        /**
         * TODO: Refactor when @angular/cdk includes feature I mentioned on github see link below.
         * https://github.com/angular/material2/pull/5493#issuecomment-313085323
         */
        /** Disables close of popover when leaving trigger element and mouse over the popover */
        /**
         * Disables close of popover when leaving trigger element and mouse over the popover
         * @return {?}
         */
        MdePopover.prototype.onMouseOver = /**
         * Disables close of popover when leaving trigger element and mouse over the popover
         * @return {?}
         */
            function () {
                if (this.triggerEvent === 'hover') {
                    this.closeDisabled = true;
                }
            };
        /** Enables close of popover when mouse leaving popover element */
        /**
         * Enables close of popover when mouse leaving popover element
         * @return {?}
         */
        MdePopover.prototype.onMouseLeave = /**
         * Enables close of popover when mouse leaving popover element
         * @return {?}
         */
            function () {
                if (this.triggerEvent === 'hover') {
                    this.closeDisabled = false;
                    this._emitCloseEvent();
                }
            };
        // TODO: Refactor how styles are set and updated on the component, use best practices.
        // TODO: If arrow left and right positioning is requested, see if flex direction can be used to work with order.
        /** Sets the current styles for the popover to allow for dynamically changing settings */
        /**
         * Sets the current styles for the popover to allow for dynamically changing settings
         * @return {?}
         */
        MdePopover.prototype.setCurrentStyles = /**
         * Sets the current styles for the popover to allow for dynamically changing settings
         * @return {?}
         */
            function () {
                // TODO: See if arrow position can be calculated automatically and allow override.
                // TODO: See if flex order is a better alternative to position arrow top or bottom.
                this.popoverArrowStyles = {
                    'right': this.positionX === 'before' ? (this.arrowOffsetX - this.arrowWidth) + 'px' : '',
                    'left': this.positionX === 'after' ? (this.arrowOffsetX - this.arrowWidth) + 'px' : '',
                    'border-top': this.positionY === 'below' ?
                        this.arrowWidth + 'px solid ' + this.arrowColor : '0px solid transparent',
                    'border-right': 'undefined' === undefined ?
                        this.arrowWidth + 'px solid ' + this.arrowColor :
                        this.arrowWidth + 'px solid transparent',
                    'border-bottom': this.positionY === 'above' ?
                        this.arrowWidth + 'px solid ' + this.arrowColor :
                        this.arrowWidth + 'px solid transparent',
                    'border-left': 'undefined' === undefined ?
                        this.arrowWidth + 'px solid ' + this.arrowColor :
                        this.arrowWidth + 'px solid transparent',
                };
                // TODO: Remove if flex order is added.
                this.popoverContentStyles = {
                    'padding-top': this.overlapTrigger === true ? '0px' : this.arrowWidth + 'px',
                    'padding-bottom': this.overlapTrigger === true ? '0px' : (this.arrowWidth) + 'px',
                    'margin-top': this.overlapTrigger === false && this.positionY === 'below' && this.containerPositioning === false ?
                        -(this.arrowWidth * 2) + 'px' : '0px'
                };
            };
        /**
         * It's necessary to set position-based classes to ensure the popover panel animation
         * folds out from the correct direction.
         */
        /**
         * It's necessary to set position-based classes to ensure the popover panel animation
         * folds out from the correct direction.
         * @param {?=} posX
         * @param {?=} posY
         * @return {?}
         */
        MdePopover.prototype.setPositionClasses = /**
         * It's necessary to set position-based classes to ensure the popover panel animation
         * folds out from the correct direction.
         * @param {?=} posX
         * @param {?=} posY
         * @return {?}
         */
            function (posX, posY) {
                if (posX === void 0) {
                    posX = this.positionX;
                }
                if (posY === void 0) {
                    posY = this.positionY;
                }
                this._classList['mde-popover-before'] = posX === 'before';
                this._classList['mde-popover-after'] = posX === 'after';
                this._classList['mde-popover-above'] = posY === 'above';
                this._classList['mde-popover-below'] = posY === 'below';
            };
        MdePopover.decorators = [
            { type: core.Component, args: [{
                        selector: 'mde-popover',
                        template: "<ng-template>\n  <div class=\"mde-popover-panel\" role=\"dialog\" [class.mde-popover-overlap]=\"overlapTrigger\"\n       [ngClass]=\"_classList\" [ngStyle]=\"popoverPanelStyles\" (keydown)=\"_handleKeydown($event)\"\n       (click)=\"onClick()\" (mouseover)=\"onMouseOver()\" (mouseleave)=\"onMouseLeave()\"\n       [@transformPopover]=\"'enter'\">\n    <div class=\"mde-popover-direction-arrow\" [ngStyle]=\"popoverArrowStyles\" *ngIf=\"!overlapTrigger\"></div>\n    <div class=\"mde-popover-content\" [ngStyle]=\"popoverContentStyles\" cdkTrapFocus=\"focusTrapEnabled\">\n      <ng-content></ng-content>\n    </div>\n  </div>\n</ng-template>\n",
                        styles: [".mde-popover-panel{display:flex;flex-direction:column;max-height:calc(100vh + 48px)}.mde-popover-ripple{position:absolute;top:0;left:0;bottom:0;right:0}.mde-popover-below .mde-popover-direction-arrow{position:absolute;bottom:0;width:0;height:0;border-bottom-width:0!important;z-index:99999}.mde-popover-above .mde-popover-direction-arrow{position:absolute;top:0;width:0;height:0;border-top-width:0!important;z-index:99999}.mde-popover-after .mde-popover-direction-arrow{left:20px}.mde-popover-before .mde-popover-direction-arrow{right:20px}"],
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        encapsulation: core.ViewEncapsulation.None,
                        animations: [
                            transformPopover
                        ],
                        exportAs: 'mdePopover'
                    },] },
        ];
        /** @nocollapse */
        MdePopover.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
            ];
        };
        MdePopover.propDecorators = {
            "role": [{ type: core.HostBinding, args: ['attr.role',] },],
            "positionX": [{ type: core.Input, args: ['mdePopoverPositionX',] },],
            "positionY": [{ type: core.Input, args: ['mdePopoverPositionY',] },],
            "triggerEvent": [{ type: core.Input, args: ['mdePopoverTriggerOn',] },],
            "enterDelay": [{ type: core.Input, args: ['mdePopoverEnterDelay',] },],
            "leaveDelay": [{ type: core.Input, args: ['mdePopoverLeaveDelay',] },],
            "overlapTrigger": [{ type: core.Input, args: ['mdePopoverOverlapTrigger',] },],
            "targetOffsetX": [{ type: core.Input, args: ['mdePopoverOffsetX',] },],
            "targetOffsetY": [{ type: core.Input, args: ['mdePopoverOffsetY',] },],
            "arrowOffsetX": [{ type: core.Input, args: ['mdePopoverArrowOffsetX',] },],
            "arrowWidth": [{ type: core.Input, args: ['mdePopoverArrowWidth',] },],
            "arrowColor": [{ type: core.Input, args: ['mdePopoverArrowColor',] },],
            "closeOnClick": [{ type: core.Input, args: ['mdePopoverCloseOnClick',] },],
            "focusTrapEnabled": [{ type: core.Input, args: ['mdeFocusTrapEnabled',] },],
            "panelClass": [{ type: core.Input, args: ['class',] },],
            "classList": [{ type: core.Input },],
            "close": [{ type: core.Output },],
            "templateRef": [{ type: core.ViewChild, args: [core.TemplateRef,] },],
        };
        return MdePopover;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * This directive is intended to be used in conjunction with an mde-popover tag. It is
     * responsible for toggling the display of the provided popover instance.
     */
    var MdePopoverTrigger = (function () {
        function MdePopoverTrigger(_overlay, _elementRef, _viewContainerRef, _dir) {
            this._overlay = _overlay;
            this._elementRef = _elementRef;
            this._viewContainerRef = _viewContainerRef;
            this._dir = _dir;
            // tslint:disable-line:directive-class-suffix
            this.ariaHaspopup = true;
            this._overlayRef = null;
            this._popoverOpen = false;
            this._halt = false;
            this._openedByMouse = false;
            /**
             * Event emitted when the associated popover is opened.
             */
            this.opened = new core.EventEmitter();
            /**
             * Event emitted when the associated popover is closed.
             */
            this.closed = new core.EventEmitter();
        }
        /**
         * @return {?}
         */
        MdePopoverTrigger.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this._checkPopover();
                this._setCurrentConfig();
                this.popover.close.subscribe(function () { return _this.closePopover(); });
            };
        /**
         * @return {?}
         */
        MdePopoverTrigger.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () { this.destroyPopover(); };
        /**
         * @return {?}
         */
        MdePopoverTrigger.prototype._setCurrentConfig = /**
         * @return {?}
         */
            function () {
                if (this.positionX === 'before' || this.positionX === 'after') {
                    this.popover.positionX = this.positionX;
                }
                if (this.positionY === 'above' || this.positionY === 'below') {
                    this.popover.positionY = this.positionY;
                }
                if (this.triggerEvent) {
                    this.popover.triggerEvent = this.triggerEvent;
                }
                if (this.enterDelay) {
                    this.popover.enterDelay = this.enterDelay;
                }
                if (this.leaveDelay) {
                    this.popover.leaveDelay = this.leaveDelay;
                }
                if (this.overlapTrigger === true || this.overlapTrigger === false) {
                    this.popover.overlapTrigger = this.overlapTrigger;
                }
                if (this.targetOffsetX) {
                    this.popover.targetOffsetX = this.targetOffsetX;
                }
                if (this.targetOffsetY) {
                    this.popover.targetOffsetY = this.targetOffsetY;
                }
                if (this.arrowOffsetX) {
                    this.popover.arrowOffsetX = this.arrowOffsetX;
                }
                if (this.arrowWidth) {
                    this.popover.arrowWidth = this.arrowWidth;
                }
                if (this.arrowColor) {
                    this.popover.arrowColor = this.arrowColor;
                }
                if (this.closeOnClick === true || this.closeOnClick === false) {
                    this.popover.closeOnClick = this.closeOnClick;
                }
                this.popover.setCurrentStyles();
            };
        Object.defineProperty(MdePopoverTrigger.prototype, "popoverOpen", {
            /** Whether the popover is open. */
            get: /**
             * Whether the popover is open.
             * @return {?}
             */ function () { return this._popoverOpen; },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MdePopoverTrigger.prototype.onClick = /**
         * @return {?}
         */
            function () {
                if (this.popover.triggerEvent === 'click') {
                    // this.popover.setCurrentStyles();
                    // this._setCurrentConfig();
                    this.togglePopover();
                }
            };
        /**
         * @return {?}
         */
        MdePopoverTrigger.prototype.onMouseEnter = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this._halt = false;
                if (this.popover.triggerEvent === 'hover') {
                    this._mouseoverTimer = setTimeout(function () {
                        _this.openPopover();
                    }, this.popover.enterDelay);
                }
            };
        /**
         * @return {?}
         */
        MdePopoverTrigger.prototype.onMouseLeave = /**
         * @return {?}
         */
            function () {
                var _this = this;
                if (this.popover.triggerEvent === 'hover') {
                    if (this._mouseoverTimer) {
                        clearTimeout(this._mouseoverTimer);
                        this._mouseoverTimer = null;
                    }
                    if (this._popoverOpen) {
                        setTimeout(function () {
                            if (!_this.popover.closeDisabled) {
                                _this.closePopover();
                            }
                        }, this.popover.leaveDelay);
                    }
                    else {
                        this._halt = true;
                    }
                }
            };
        /** Toggles the popover between the open and closed states. */
        /**
         * Toggles the popover between the open and closed states.
         * @return {?}
         */
        MdePopoverTrigger.prototype.togglePopover = /**
         * Toggles the popover between the open and closed states.
         * @return {?}
         */
            function () {
                return this._popoverOpen ? this.closePopover() : this.openPopover();
            };
        /** Opens the popover. */
        /**
         * Opens the popover.
         * @return {?}
         */
        MdePopoverTrigger.prototype.openPopover = /**
         * Opens the popover.
         * @return {?}
         */
            function () {
                if (!this._popoverOpen && !this._halt) {
                    this._createOverlay().attach(this._portal);
                    /** Only subscribe to backdrop if trigger event is click */
                    if (this.triggerEvent === 'click') {
                        this._subscribeToBackdrop();
                    }
                    this._initPopover();
                }
            };
        /** Closes the popover. */
        /**
         * Closes the popover.
         * @return {?}
         */
        MdePopoverTrigger.prototype.closePopover = /**
         * Closes the popover.
         * @return {?}
         */
            function () {
                if (this._overlayRef) {
                    this._overlayRef.detach();
                    /** Only unsubscribe to backdrop if trigger event is click */
                    if (this.triggerEvent === 'click') {
                        this._backdropSubscription.unsubscribe();
                    }
                    this._resetPopover();
                }
            };
        /** Removes the popover from the DOM. */
        /**
         * Removes the popover from the DOM.
         * @return {?}
         */
        MdePopoverTrigger.prototype.destroyPopover = /**
         * Removes the popover from the DOM.
         * @return {?}
         */
            function () {
                if (this._overlayRef) {
                    this._overlayRef.dispose();
                    this._overlayRef = null;
                    this._cleanUpSubscriptions();
                }
            };
        /** Focuses the popover trigger. */
        /**
         * Focuses the popover trigger.
         * @return {?}
         */
        MdePopoverTrigger.prototype.focus = /**
         * Focuses the popover trigger.
         * @return {?}
         */
            function () {
                this._elementRef.nativeElement.focus();
            };
        Object.defineProperty(MdePopoverTrigger.prototype, "dir", {
            /** The text direction of the containing app. */
            get: /**
             * The text direction of the containing app.
             * @return {?}
             */ function () {
                return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';
            },
            enumerable: true,
            configurable: true
        });
        /**
         * This method ensures that the popover closes when the overlay backdrop is clicked.
         * We do not use first() here because doing so would not catch clicks from within
         * the popover, and it would fail to unsubscribe properly. Instead, we unsubscribe
         * explicitly when the popover is closed or destroyed.
         * @return {?}
         */
        MdePopoverTrigger.prototype._subscribeToBackdrop = /**
         * This method ensures that the popover closes when the overlay backdrop is clicked.
         * We do not use first() here because doing so would not catch clicks from within
         * the popover, and it would fail to unsubscribe properly. Instead, we unsubscribe
         * explicitly when the popover is closed or destroyed.
         * @return {?}
         */
            function () {
                var _this = this;
                if (this._overlayRef) {
                    this._backdropSubscription = this._overlayRef.backdropClick().subscribe(function () {
                        _this.popover._emitCloseEvent();
                    });
                }
            };
        /**
         * This method sets the popover state to open and focuses the first item if
         * the popover was opened via the keyboard.
         * @return {?}
         */
        MdePopoverTrigger.prototype._initPopover = /**
         * This method sets the popover state to open and focuses the first item if
         * the popover was opened via the keyboard.
         * @return {?}
         */
            function () {
                this._setIsPopoverOpen(true);
            };
        /**
         * This method resets the popover when it's closed, most importantly restoring
         * focus to the popover trigger if the popover was opened via the keyboard.
         * @return {?}
         */
        MdePopoverTrigger.prototype._resetPopover = /**
         * This method resets the popover when it's closed, most importantly restoring
         * focus to the popover trigger if the popover was opened via the keyboard.
         * @return {?}
         */
            function () {
                this._setIsPopoverOpen(false);
                // Focus only needs to be reset to the host element if the popover was opened
                // by the keyboard and manually shifted to the first popover item.
                if (!this._openedByMouse) {
                    this.focus();
                }
                this._openedByMouse = false;
            };
        /**
         * set state rather than toggle to support triggers sharing a popover
         * @param {?} isOpen
         * @return {?}
         */
        MdePopoverTrigger.prototype._setIsPopoverOpen = /**
         * set state rather than toggle to support triggers sharing a popover
         * @param {?} isOpen
         * @return {?}
         */
            function (isOpen) {
                this._popoverOpen = isOpen;
                this._popoverOpen ? this.opened.emit() : this.closed.emit();
            };
        /**
         *  This method checks that a valid instance of MdPopover has been passed into
         *  mdPopoverTriggerFor. If not, an exception is thrown.
         * @return {?}
         */
        MdePopoverTrigger.prototype._checkPopover = /**
         *  This method checks that a valid instance of MdPopover has been passed into
         *  mdPopoverTriggerFor. If not, an exception is thrown.
         * @return {?}
         */
            function () {
                if (!this.popover) {
                    throwMdePopoverMissingError();
                }
            };
        /**
         *  This method creates the overlay from the provided popover's template and saves its
         *  OverlayRef so that it can be attached to the DOM when openPopover is called.
         * @return {?}
         */
        MdePopoverTrigger.prototype._createOverlay = /**
         *  This method creates the overlay from the provided popover's template and saves its
         *  OverlayRef so that it can be attached to the DOM when openPopover is called.
         * @return {?}
         */
            function () {
                if (!this._overlayRef) {
                    this._portal = new portal.TemplatePortal(this.popover.templateRef, this._viewContainerRef);
                    var /** @type {?} */ config = this._getOverlayConfig();
                    this._subscribeToPositions(/** @type {?} */ (config.positionStrategy));
                    this._overlayRef = this._overlay.create(config);
                }
                return this._overlayRef;
            };
        /**
         * This method builds the configuration object needed to create the overlay, the OverlayConfig.
         * @return {?} OverlayConfig
         */
        MdePopoverTrigger.prototype._getOverlayConfig = /**
         * This method builds the configuration object needed to create the overlay, the OverlayConfig.
         * @return {?} OverlayConfig
         */
            function () {
                var /** @type {?} */ overlayState = new overlay.OverlayConfig();
                overlayState.positionStrategy = this._getPosition();
                /** Display overlay backdrop if trigger event is click */
                if (this.triggerEvent === 'click') {
                    overlayState.hasBackdrop = true;
                    overlayState.backdropClass = 'cdk-overlay-transparent-backdrop';
                }
                overlayState.direction = this.dir;
                overlayState.scrollStrategy = this._overlay.scrollStrategies.reposition();
                return overlayState;
            };
        /**
         * Listens to changes in the position of the overlay and sets the correct classes
         * on the popover based on the new position. This ensures the animation origin is always
         * correct, even if a fallback position is used for the overlay.
         * @param {?} position
         * @return {?}
         */
        MdePopoverTrigger.prototype._subscribeToPositions = /**
         * Listens to changes in the position of the overlay and sets the correct classes
         * on the popover based on the new position. This ensures the animation origin is always
         * correct, even if a fallback position is used for the overlay.
         * @param {?} position
         * @return {?}
         */
            function (position) {
                var _this = this;
                this._positionSubscription = position.positionChanges.subscribe(function (change) {
                    var /** @type {?} */ posisionX = change.connectionPair.overlayX === 'start' ? 'after' : 'before';
                    var /** @type {?} */ posisionY = change.connectionPair.overlayY === 'top' ? 'below' : 'above';
                    if (!_this.popover.overlapTrigger) {
                        posisionY = posisionY === 'below' ? 'above' : 'below';
                    }
                    _this.popover.positionX = posisionX;
                    _this.popover.positionY = posisionY;
                    _this.popover.setCurrentStyles();
                    _this.popover.setPositionClasses(posisionX, posisionY);
                });
            };
        /**
         * This method builds the position strategy for the overlay, so the popover is properly connected
         * to the trigger.
         * @return {?} ConnectedPositionStrategy
         */
        MdePopoverTrigger.prototype._getPosition = /**
         * This method builds the position strategy for the overlay, so the popover is properly connected
         * to the trigger.
         * @return {?} ConnectedPositionStrategy
         */
            function () {
                var _a = tslib_1.__read(this.popover.positionX === 'before' ? ['end', 'start'] : ['start', 'end'], 2), originX = _a[0], originFallbackX = _a[1];
                var _b = tslib_1.__read(this.popover.positionY === 'above' ? ['bottom', 'top'] : ['top', 'bottom'], 2), overlayY = _b[0], overlayFallbackY = _b[1];
                // let originY = overlayY;
                // let fallbackOriginY = overlayFallbackY;
                var /** @type {?} */ originY = overlayY;
                var /** @type {?} */ originFallbackY = overlayFallbackY;
                var /** @type {?} */ overlayX = originX;
                var /** @type {?} */ overlayFallbackX = originFallbackX;
                // let [originY, originFallbackY] = [overlayY, overlayFallbackY];
                // let [overlayX, overlayFallbackX] = [originX, originFallbackX];
                /** Reverse overlayY and fallbackOverlayY when overlapTrigger is false */
                if (!this.popover.overlapTrigger) {
                    originY = overlayY === 'top' ? 'bottom' : 'top';
                    originFallbackY = overlayFallbackY === 'top' ? 'bottom' : 'top';
                }
                var /** @type {?} */ offsetX = 0;
                var /** @type {?} */ offsetY = 0;
                if (this.popover.targetOffsetX && !isNaN(Number(this.popover.targetOffsetX))) {
                    offsetX = Number(this.popover.targetOffsetX);
                    // offsetX = -16;
                }
                if (this.popover.targetOffsetY && !isNaN(Number(this.popover.targetOffsetY))) {
                    offsetY = Number(this.popover.targetOffsetY);
                    // offsetY = -10;
                }
                /**
                 * For overriding position element, when mdePopoverTargetAt has a valid element reference.
                 * Useful for sticking popover to parent element and offsetting arrow to trigger element.
                 * If undefined defaults to the trigger element reference.
                 */
                var /** @type {?} */ element = this._elementRef;
                if (typeof this.targetElement !== 'undefined') {
                    this.popover.containerPositioning = true;
                    element = this.targetElement._elementRef;
                }
                return this._overlay.position()
                    .flexibleConnectedTo(element)
                    .withPositions([
                    {
                        originX: originX,
                        originY: originY,
                        overlayX: overlayX,
                        overlayY: overlayY,
                        offsetY: offsetY
                    },
                    {
                        originX: originFallbackX,
                        originY: originY,
                        overlayX: overlayFallbackX,
                        overlayY: overlayY,
                        offsetY: offsetY
                    },
                    {
                        originX: originX,
                        originY: originFallbackY,
                        overlayX: overlayX,
                        overlayY: overlayFallbackY,
                        offsetY: -offsetY
                    },
                    {
                        originX: originFallbackX,
                        originY: originFallbackY,
                        overlayX: overlayFallbackX,
                        overlayY: overlayFallbackY,
                        offsetY: -offsetY
                    }
                ])
                    .withDefaultOffsetX(offsetX)
                    .withDefaultOffsetY(offsetY);
                /*
                        return this._overlay.position()
                          .connectedTo(element,
                              {originX: posX, originY: originY},
                              {overlayX: posX, overlayY: overlayY})
                          .withFallbackPosition(
                              {originX: fallbackX, originY: originY},
                              {overlayX: fallbackX, overlayY: overlayY})
                          .withFallbackPosition(
                              {originX: posX, originY: fallbackOriginY},
                              {overlayX: posX, overlayY: fallbackOverlayY})
                          .withFallbackPosition(
                              {originX: fallbackX, originY: fallbackOriginY},
                              {overlayX: fallbackX, overlayY: fallbackOverlayY})
                          .withOffsetX(offsetX)
                          .withOffsetY(offsetY);
                          */
            };
        /**
         * @return {?}
         */
        MdePopoverTrigger.prototype._cleanUpSubscriptions = /**
         * @return {?}
         */
            function () {
                if (this._backdropSubscription) {
                    this._backdropSubscription.unsubscribe();
                }
                if (this._positionSubscription) {
                    this._positionSubscription.unsubscribe();
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        MdePopoverTrigger.prototype._handleMousedown = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (event && !a11y.isFakeMousedownFromScreenReader(event)) {
                    this._openedByMouse = true;
                }
            };
        MdePopoverTrigger.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdePopoverTriggerFor]',
                        exportAs: 'mdePopoverTrigger'
                    },] },
        ];
        /** @nocollapse */
        MdePopoverTrigger.ctorParameters = function () {
            return [
                { type: overlay.Overlay, },
                { type: core.ElementRef, },
                { type: core.ViewContainerRef, },
                { type: bidi.Directionality, decorators: [{ type: core.Optional },] },
            ];
        };
        MdePopoverTrigger.propDecorators = {
            "ariaHaspopup": [{ type: core.HostBinding, args: ['attr.aria-haspopup',] },],
            "popover": [{ type: core.Input, args: ['mdePopoverTriggerFor',] },],
            "targetElement": [{ type: core.Input, args: ['mdePopoverTargetAt',] },],
            "positionX": [{ type: core.Input, args: ['mdePopoverPositionX',] },],
            "positionY": [{ type: core.Input, args: ['mdePopoverPositionY',] },],
            "triggerEvent": [{ type: core.Input, args: ['mdePopoverTriggerOn',] },],
            "enterDelay": [{ type: core.Input, args: ['mdePopoverEnterDelay',] },],
            "leaveDelay": [{ type: core.Input, args: ['mdePopoverLeaveDelay',] },],
            "overlapTrigger": [{ type: core.Input, args: ['mdePopoverOverlapTrigger',] },],
            "targetOffsetX": [{ type: core.Input, args: ['mdePopoverOffsetX',] },],
            "targetOffsetY": [{ type: core.Input, args: ['mdePopoverOffsetY',] },],
            "arrowOffsetX": [{ type: core.Input, args: ['mdePopoverArrowOffsetX',] },],
            "arrowWidth": [{ type: core.Input, args: ['mdePopoverArrowWidth',] },],
            "arrowColor": [{ type: core.Input, args: ['mdePopoverArrowColor',] },],
            "closeOnClick": [{ type: core.Input, args: ['mdePopoverCloseOnClick',] },],
            "opened": [{ type: core.Output },],
            "closed": [{ type: core.Output },],
            "onClick": [{ type: core.HostListener, args: ['click',] },],
            "onMouseEnter": [{ type: core.HostListener, args: ['mouseenter',] },],
            "onMouseLeave": [{ type: core.HostListener, args: ['mouseleave',] },],
            "_handleMousedown": [{ type: core.HostListener, args: ['mousedown',] },],
        };
        return MdePopoverTrigger;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MdePopoverTarget = (function () {
        function MdePopoverTarget(_elementRef) {
            this._elementRef = _elementRef;
        }
        MdePopoverTarget.decorators = [
            { type: core.Directive, args: [{
                        selector: 'mde-popover-target, [mdePopoverTarget]',
                        exportAs: 'mdePopoverTarget'
                    },] },
        ];
        /** @nocollapse */
        MdePopoverTarget.ctorParameters = function () {
            return [
                { type: core.ElementRef, },
            ];
        };
        return MdePopoverTarget;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MdePopoverModule = (function () {
        function MdePopoverModule() {
        }
        MdePopoverModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            overlay.OverlayModule,
                            common.CommonModule
                        ],
                        exports: [MdePopover, MdePopoverTrigger, MdePopoverTarget],
                        declarations: [MdePopover, MdePopoverTrigger, MdePopoverTarget],
                    },] },
        ];
        return MdePopoverModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    // export { MdePopoverPositionX, MdePopoverPositionY, MdePopoverTriggerEvent } from './popover-types';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    exports.MdePopoverModule = MdePopoverModule;
    exports.MdePopover = MdePopover;
    exports.transformPopover = transformPopover;
    exports.MdePopoverTrigger = MdePopoverTrigger;
    exports.MdePopoverTarget = MdePopoverTarget;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWF0ZXJpYWwtZXh0ZW5kZWQtbWRlLnVtZC5qcy5tYXAiLCJzb3VyY2VzIjpbIm5nOi8vQG1hdGVyaWFsLWV4dGVuZGVkL21kZS9saWIvcG9wb3Zlci9wb3BvdmVyLWVycm9ycy50cyIsIm5nOi8vQG1hdGVyaWFsLWV4dGVuZGVkL21kZS9saWIvcG9wb3Zlci9wb3BvdmVyLWFuaW1hdGlvbnMudHMiLCJuZzovL0BtYXRlcmlhbC1leHRlbmRlZC9tZGUvbGliL3BvcG92ZXIvcG9wb3Zlci50cyIsIm5nOi8vQG1hdGVyaWFsLWV4dGVuZGVkL21kZS9saWIvcG9wb3Zlci9wb3BvdmVyLXRyaWdnZXIudHMiLCJuZzovL0BtYXRlcmlhbC1leHRlbmRlZC9tZGUvbGliL3BvcG92ZXIvcG9wb3Zlci10YXJnZXQudHMiLCJuZzovL0BtYXRlcmlhbC1leHRlbmRlZC9tZGUvbGliL3BvcG92ZXIvcG9wb3Zlci1tb2R1bGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIFRocm93cyBhbiBleGNlcHRpb24gZm9yIHRoZSBjYXNlIHdoZW4gcG9wb3ZlciB0cmlnZ2VyIGRvZXNuJ3QgaGF2ZSBhIHZhbGlkIG1kZS1wb3BvdmVyIGluc3RhbmNlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdGhyb3dNZGVQb3BvdmVyTWlzc2luZ0Vycm9yKCkge1xyXG4gIHRocm93IEVycm9yKGBtZGUtcG9wb3Zlci10cmlnZ2VyOiBtdXN0IHBhc3MgaW4gYW4gbWRlLXBvcG92ZXIgaW5zdGFuY2UuXHJcblxyXG4gICAgRXhhbXBsZTpcclxuICAgICAgPG1kZS1wb3BvdmVyICNwb3BvdmVyPVwibWRlUG9wb3ZlclwiPjwvbWRlLXBvcG92ZXI+XHJcbiAgICAgIDxidXR0b24gW21kZVBvcG92ZXJUcmlnZ2VyRm9yXT1cInBvcG92ZXJcIj48L2J1dHRvbj5gKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRocm93cyBhbiBleGNlcHRpb24gZm9yIHRoZSBjYXNlIHdoZW4gcG9wb3ZlcidzIG1kZVBvcG92ZXJQb3NpdGlvblggdmFsdWUgaXNuJ3QgdmFsaWQuXHJcbiAqIEluIG90aGVyIHdvcmRzLCBpdCBkb2Vzbid0IG1hdGNoICdiZWZvcmUnIG9yICdhZnRlcicuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdGhyb3dNZGVQb3BvdmVySW52YWxpZFBvc2l0aW9uWCgpIHtcclxuICB0aHJvdyBFcnJvcihgbWRlUG9wb3ZlclBvc2l0aW9uWCB2YWx1ZSBtdXN0IGJlIGVpdGhlciAnYmVmb3JlJyBvciBhZnRlcicuXHJcbiAgICAgIEV4YW1wbGU6IDxtZGUtcG9wb3ZlciBtZGVQb3BvdmVyUG9zaXRpb25YPVwiYmVmb3JlXCIgI3BvcG92ZXI9XCJtZGVQb3BvdmVyXCI+PC9tZGUtcG9wb3Zlcj5gKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRocm93cyBhbiBleGNlcHRpb24gZm9yIHRoZSBjYXNlIHdoZW4gcG9wb3ZlcidzIG1kZVBvcG92ZXJQb3NpdGlvblkgdmFsdWUgaXNuJ3QgdmFsaWQuXHJcbiAqIEluIG90aGVyIHdvcmRzLCBpdCBkb2Vzbid0IG1hdGNoICdhYm92ZScgb3IgJ2JlbG93Jy5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB0aHJvd01kZVBvcG92ZXJJbnZhbGlkUG9zaXRpb25ZKCkge1xyXG4gIHRocm93IEVycm9yKGBtZGVQb3BvdmVyUG9zaXRpb25ZIHZhbHVlIG11c3QgYmUgZWl0aGVyICdhYm92ZScgb3IgYmVsb3cnLlxyXG4gICAgICBFeGFtcGxlOiA8bWRlLXBvcG92ZXIgbWRlUG9wb3ZlclBvc2l0aW9uWT1cImFib3ZlXCIgI3BvcG92ZXI9XCJtZGVQb3BvdmVyXCI+PC9tZGUtcG9wb3Zlcj5gKTtcclxufVxyXG4iLCJpbXBvcnQge1xyXG4gIHRyaWdnZXIsXHJcbiAgc3RhdGUsXHJcbiAgc3R5bGUsXHJcbiAgYW5pbWF0ZSxcclxuICB0cmFuc2l0aW9uLFxyXG4gIEFuaW1hdGlvblRyaWdnZXJNZXRhZGF0YSxcclxufSBmcm9tICdAYW5ndWxhci9hbmltYXRpb25zJztcclxuXHJcbi8qKlxyXG4gKiBCZWxvdyBhcmUgYWxsIHRoZSBhbmltYXRpb25zIGZvciB0aGUgbWQtcG9wb3ZlciBjb21wb25lbnQuXHJcbiAqIEFuaW1hdGlvbiBkdXJhdGlvbiBhbmQgdGltaW5nIHZhbHVlcyBhcmUgYmFzZWQgb24gQW5ndWxhckpTIE1hdGVyaWFsLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBUaGlzIGFuaW1hdGlvbiBjb250cm9scyB0aGUgcG9wb3ZlciBwYW5lbCdzIGVudHJ5IGFuZCBleGl0IGZyb20gdGhlIHBhZ2UuXHJcbiAqXHJcbiAqIFdoZW4gdGhlIHBvcG92ZXIgcGFuZWwgaXMgYWRkZWQgdG8gdGhlIERPTSwgaXQgc2NhbGVzIGluIGFuZCBmYWRlcyBpbiBpdHMgYm9yZGVyLlxyXG4gKlxyXG4gKiBXaGVuIHRoZSBwb3BvdmVyIHBhbmVsIGlzIHJlbW92ZWQgZnJvbSB0aGUgRE9NLCBpdCBzaW1wbHkgZmFkZXMgb3V0IGFmdGVyIGEgYnJpZWZcclxuICogZGVsYXkgdG8gZGlzcGxheSB0aGUgcmlwcGxlLlxyXG4gKi9cclxuXHJcbmV4cG9ydCBjb25zdCB0cmFuc2Zvcm1Qb3BvdmVyOiBBbmltYXRpb25UcmlnZ2VyTWV0YWRhdGEgPSB0cmlnZ2VyKCd0cmFuc2Zvcm1Qb3BvdmVyJywgW1xyXG4gIHN0YXRlKCdlbnRlcicsIHN0eWxlKHtcclxuICAgIG9wYWNpdHk6IDEsXHJcbiAgICB0cmFuc2Zvcm06IGBzY2FsZSgxKWBcclxuICB9KSksXHJcbiAgdHJhbnNpdGlvbigndm9pZCA9PiAqJywgW1xyXG4gICAgc3R5bGUoe1xyXG4gICAgICBvcGFjaXR5OiAwLFxyXG4gICAgICB0cmFuc2Zvcm06IGBzY2FsZSgwKWBcclxuICAgIH0pLFxyXG4gICAgYW5pbWF0ZShgMjAwbXMgY3ViaWMtYmV6aWVyKDAuMjUsIDAuOCwgMC4yNSwgMSlgKVxyXG4gIF0pLFxyXG4gIHRyYW5zaXRpb24oJyogPT4gdm9pZCcsIFtcclxuICAgIGFuaW1hdGUoJzUwbXMgMTAwbXMgbGluZWFyJywgc3R5bGUoe29wYWNpdHk6IDB9KSlcclxuICBdKVxyXG5dKTtcclxuIiwiaW1wb3J0IHtcclxuICBDb21wb25lbnQsXHJcbiAgRXZlbnRFbWl0dGVyLFxyXG4gIElucHV0LFxyXG4gIE9uRGVzdHJveSxcclxuICBPdXRwdXQsXHJcbiAgVGVtcGxhdGVSZWYsXHJcbiAgVmlld0NoaWxkLFxyXG4gIFZpZXdFbmNhcHN1bGF0aW9uLFxyXG4gIEVsZW1lbnRSZWYsXHJcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXHJcbiAgSG9zdEJpbmRpbmcsXHJcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcblxyXG5pbXBvcnQgeyBFU0NBUEUgfSBmcm9tICdAYW5ndWxhci9jZGsva2V5Y29kZXMnO1xyXG5cclxuaW1wb3J0IHsgTWRlUG9wb3ZlclBvc2l0aW9uWCwgTWRlUG9wb3ZlclBvc2l0aW9uWSwgTWRlUG9wb3ZlclRyaWdnZXJFdmVudCB9IGZyb20gJy4vcG9wb3Zlci10eXBlcyc7XHJcbmltcG9ydCB7IHRocm93TWRlUG9wb3ZlckludmFsaWRQb3NpdGlvblgsIHRocm93TWRlUG9wb3ZlckludmFsaWRQb3NpdGlvblkgfSBmcm9tICcuL3BvcG92ZXItZXJyb3JzJztcclxuaW1wb3J0IHsgTWRlUG9wb3ZlclBhbmVsIH0gZnJvbSAnLi9wb3BvdmVyLWludGVyZmFjZXMnO1xyXG5pbXBvcnQgeyB0cmFuc2Zvcm1Qb3BvdmVyIH0gZnJvbSAnLi9wb3BvdmVyLWFuaW1hdGlvbnMnO1xyXG5cclxuaW1wb3J0IHsgQW5pbWF0aW9uRXZlbnQgfSBmcm9tICdAYW5ndWxhci9hbmltYXRpb25zJztcclxuXHJcblxyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgc2VsZWN0b3I6ICdtZGUtcG9wb3ZlcicsXHJcbiAgdGVtcGxhdGU6IGA8bmctdGVtcGxhdGU+XHJcbiAgPGRpdiBjbGFzcz1cIm1kZS1wb3BvdmVyLXBhbmVsXCIgcm9sZT1cImRpYWxvZ1wiIFtjbGFzcy5tZGUtcG9wb3Zlci1vdmVybGFwXT1cIm92ZXJsYXBUcmlnZ2VyXCJcclxuICAgICAgIFtuZ0NsYXNzXT1cIl9jbGFzc0xpc3RcIiBbbmdTdHlsZV09XCJwb3BvdmVyUGFuZWxTdHlsZXNcIiAoa2V5ZG93bik9XCJfaGFuZGxlS2V5ZG93bigkZXZlbnQpXCJcclxuICAgICAgIChjbGljayk9XCJvbkNsaWNrKClcIiAobW91c2VvdmVyKT1cIm9uTW91c2VPdmVyKClcIiAobW91c2VsZWF2ZSk9XCJvbk1vdXNlTGVhdmUoKVwiXHJcbiAgICAgICBbQHRyYW5zZm9ybVBvcG92ZXJdPVwiJ2VudGVyJ1wiPlxyXG4gICAgPGRpdiBjbGFzcz1cIm1kZS1wb3BvdmVyLWRpcmVjdGlvbi1hcnJvd1wiIFtuZ1N0eWxlXT1cInBvcG92ZXJBcnJvd1N0eWxlc1wiICpuZ0lmPVwiIW92ZXJsYXBUcmlnZ2VyXCI+PC9kaXY+XHJcbiAgICA8ZGl2IGNsYXNzPVwibWRlLXBvcG92ZXItY29udGVudFwiIFtuZ1N0eWxlXT1cInBvcG92ZXJDb250ZW50U3R5bGVzXCIgY2RrVHJhcEZvY3VzPVwiZm9jdXNUcmFwRW5hYmxlZFwiPlxyXG4gICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XHJcbiAgICA8L2Rpdj5cclxuICA8L2Rpdj5cclxuPC9uZy10ZW1wbGF0ZT5cclxuYCxcclxuICBzdHlsZXM6IFtgLm1kZS1wb3BvdmVyLXBhbmVse2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW47bWF4LWhlaWdodDpjYWxjKDEwMHZoICsgNDhweCl9Lm1kZS1wb3BvdmVyLXJpcHBsZXtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0OjA7Ym90dG9tOjA7cmlnaHQ6MH0ubWRlLXBvcG92ZXItYmVsb3cgLm1kZS1wb3BvdmVyLWRpcmVjdGlvbi1hcnJvd3twb3NpdGlvbjphYnNvbHV0ZTtib3R0b206MDt3aWR0aDowO2hlaWdodDowO2JvcmRlci1ib3R0b20td2lkdGg6MCFpbXBvcnRhbnQ7ei1pbmRleDo5OTk5OX0ubWRlLXBvcG92ZXItYWJvdmUgLm1kZS1wb3BvdmVyLWRpcmVjdGlvbi1hcnJvd3twb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDt3aWR0aDowO2hlaWdodDowO2JvcmRlci10b3Atd2lkdGg6MCFpbXBvcnRhbnQ7ei1pbmRleDo5OTk5OX0ubWRlLXBvcG92ZXItYWZ0ZXIgLm1kZS1wb3BvdmVyLWRpcmVjdGlvbi1hcnJvd3tsZWZ0OjIwcHh9Lm1kZS1wb3BvdmVyLWJlZm9yZSAubWRlLXBvcG92ZXItZGlyZWN0aW9uLWFycm93e3JpZ2h0OjIwcHh9YF0sXHJcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXHJcbiAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcclxuICBhbmltYXRpb25zOiBbXHJcbiAgICB0cmFuc2Zvcm1Qb3BvdmVyXHJcbiAgXSxcclxuICBleHBvcnRBczogJ21kZVBvcG92ZXInXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBNZGVQb3BvdmVyIGltcGxlbWVudHMgTWRlUG9wb3ZlclBhbmVsLCBPbkRlc3Ryb3kgeyAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOmNvbXBvbmVudC1jbGFzcy1zdWZmaXhcclxuXHJcbiAgQEhvc3RCaW5kaW5nKCdhdHRyLnJvbGUnKSByb2xlID0gJ2RpYWxvZyc7XHJcblxyXG4gIC8qKiBTZXR0aW5ncyBmb3IgcG9wb3ZlciwgdmlldyBzZXR0ZXJzIGFuZCBnZXR0ZXJzIGZvciBtb3JlIGRldGFpbCAqL1xyXG4gIHByaXZhdGUgX3Bvc2l0aW9uWDogTWRlUG9wb3ZlclBvc2l0aW9uWCA9ICdhZnRlcic7XHJcbiAgcHJpdmF0ZSBfcG9zaXRpb25ZOiBNZGVQb3BvdmVyUG9zaXRpb25ZID0gJ2JlbG93JztcclxuICBwcml2YXRlIF90cmlnZ2VyRXZlbnQ6IE1kZVBvcG92ZXJUcmlnZ2VyRXZlbnQgPSAnaG92ZXInO1xyXG4gIHByaXZhdGUgX2VudGVyRGVsYXkgPSAyMDA7XHJcbiAgcHJpdmF0ZSBfbGVhdmVEZWxheSA9IDIwMDtcclxuICBwcml2YXRlIF9vdmVybGFwVHJpZ2dlciA9IHRydWU7XHJcbiAgcHJpdmF0ZSBfdGFyZ2V0T2Zmc2V0WCA9IDA7XHJcbiAgcHJpdmF0ZSBfdGFyZ2V0T2Zmc2V0WSA9IDA7XHJcbiAgcHJpdmF0ZSBfYXJyb3dPZmZzZXRYID0gMjA7XHJcbiAgcHJpdmF0ZSBfYXJyb3dXaWR0aCA9IDg7XHJcbiAgcHJpdmF0ZSBfYXJyb3dDb2xvciA9ICdyZ2JhKDAsIDAsIDAsIDAuMTIpJztcclxuICBwcml2YXRlIF9jbG9zZU9uQ2xpY2sgPSB0cnVlO1xyXG4gIHByaXZhdGUgX2ZvY3VzVHJhcEVuYWJsZWQgPSB0cnVlO1xyXG5cclxuICAvKiogQ29uZmlnIG9iamVjdCB0byBiZSBwYXNzZWQgaW50byB0aGUgcG9wb3ZlcidzIG5nQ2xhc3MgKi9cclxuICBfY2xhc3NMaXN0OiB7W2tleTogc3RyaW5nXTogYm9vbGVhbn0gPSB7fTtcclxuXHJcbiAgLy8gVE9ETzogV3JpdGUgY29tbWVudCBkZXNjcmlwdGlvblxyXG4gIC8qKiAqL1xyXG4gIHB1YmxpYyBjb250YWluZXJQb3NpdGlvbmluZyA9IGZhbHNlO1xyXG5cclxuICAvKiogQ2xvc2luZyBkaXNhYmxlZCBvbiBwb3BvdmVyICovXHJcbiAgcHVibGljIGNsb3NlRGlzYWJsZWQgPSBmYWxzZTtcclxuXHJcbiAgLyoqIENvbmZpZyBvYmplY3QgdG8gYmUgcGFzc2VkIGludG8gdGhlIHBvcG92ZXIncyBhcnJvdyBuZ1N0eWxlICovXHJcbiAgcHVibGljIHBvcG92ZXJQYW5lbFN0eWxlczoge307XHJcblxyXG4gIC8qKiBDb25maWcgb2JqZWN0IHRvIGJlIHBhc3NlZCBpbnRvIHRoZSBwb3BvdmVyJ3MgYXJyb3cgbmdTdHlsZSAqL1xyXG4gIHB1YmxpYyBwb3BvdmVyQXJyb3dTdHlsZXM6IHt9O1xyXG5cclxuICAvKiogQ29uZmlnIG9iamVjdCB0byBiZSBwYXNzZWQgaW50byB0aGUgcG9wb3ZlcidzIGNvbnRlbnQgbmdTdHlsZSAqL1xyXG4gIHB1YmxpYyBwb3BvdmVyQ29udGVudFN0eWxlczoge307XHJcblxyXG4gIC8qKiBFbWl0cyB0aGUgY3VycmVudCBhbmltYXRpb24gc3RhdGUgd2hlbmV2ZXIgaXQgY2hhbmdlcy4gKi9cclxuICBfb25BbmltYXRpb25TdGF0ZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8QW5pbWF0aW9uRXZlbnQ+KCk7XHJcblxyXG5cclxuICAvKiogUG9zaXRpb24gb2YgdGhlIHBvcG92ZXIgaW4gdGhlIFggYXhpcy4gKi9cclxuICBASW5wdXQoJ21kZVBvcG92ZXJQb3NpdGlvblgnKVxyXG4gIGdldCBwb3NpdGlvblgoKSB7IHJldHVybiB0aGlzLl9wb3NpdGlvblg7IH1cclxuICBzZXQgcG9zaXRpb25YKHZhbHVlOiBNZGVQb3BvdmVyUG9zaXRpb25YKSB7XHJcbiAgICBpZiAodmFsdWUgIT09ICdiZWZvcmUnICYmIHZhbHVlICE9PSAnYWZ0ZXInKSB7XHJcbiAgICAgIHRocm93TWRlUG9wb3ZlckludmFsaWRQb3NpdGlvblgoKTtcclxuICAgIH1cclxuICAgIHRoaXMuX3Bvc2l0aW9uWCA9IHZhbHVlO1xyXG4gICAgdGhpcy5zZXRQb3NpdGlvbkNsYXNzZXMoKTtcclxuICB9XHJcblxyXG4gIC8qKiBQb3NpdGlvbiBvZiB0aGUgcG9wb3ZlciBpbiB0aGUgWSBheGlzLiAqL1xyXG4gIEBJbnB1dCgnbWRlUG9wb3ZlclBvc2l0aW9uWScpXHJcbiAgZ2V0IHBvc2l0aW9uWSgpIHsgcmV0dXJuIHRoaXMuX3Bvc2l0aW9uWTsgfVxyXG4gIHNldCBwb3NpdGlvblkodmFsdWU6IE1kZVBvcG92ZXJQb3NpdGlvblkpIHtcclxuICAgIGlmICh2YWx1ZSAhPT0gJ2Fib3ZlJyAmJiB2YWx1ZSAhPT0gJ2JlbG93Jykge1xyXG4gICAgICB0aHJvd01kZVBvcG92ZXJJbnZhbGlkUG9zaXRpb25ZKCk7XHJcbiAgICB9XHJcbiAgICB0aGlzLl9wb3NpdGlvblkgPSB2YWx1ZTtcclxuICAgIHRoaXMuc2V0UG9zaXRpb25DbGFzc2VzKCk7XHJcbiAgfVxyXG5cclxuICAvKiogUG9wb3ZlciB0cmlnZ2VyIGV2ZW50ICovXHJcbiAgQElucHV0KCdtZGVQb3BvdmVyVHJpZ2dlck9uJylcclxuICBnZXQgdHJpZ2dlckV2ZW50KCk6IE1kZVBvcG92ZXJUcmlnZ2VyRXZlbnQgeyByZXR1cm4gdGhpcy5fdHJpZ2dlckV2ZW50OyB9XHJcbiAgc2V0IHRyaWdnZXJFdmVudCh2OiBNZGVQb3BvdmVyVHJpZ2dlckV2ZW50KSB7IHRoaXMuX3RyaWdnZXJFdmVudCA9IHY7IH1cclxuXHJcbiAgLyoqIFBvcG92ZXIgZW50ZXIgZGVsYXkgKi9cclxuICBASW5wdXQoJ21kZVBvcG92ZXJFbnRlckRlbGF5JylcclxuICBnZXQgZW50ZXJEZWxheSgpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5fZW50ZXJEZWxheTsgfVxyXG4gIHNldCBlbnRlckRlbGF5KHY6IG51bWJlcikgeyB0aGlzLl9lbnRlckRlbGF5ID0gdjsgfVxyXG5cclxuICAvKiogUG9wb3ZlciBsZWF2ZSBkZWxheSAqL1xyXG4gIEBJbnB1dCgnbWRlUG9wb3ZlckxlYXZlRGVsYXknKVxyXG4gIGdldCBsZWF2ZURlbGF5KCk6IG51bWJlciB7IHJldHVybiB0aGlzLl9sZWF2ZURlbGF5OyB9XHJcbiAgc2V0IGxlYXZlRGVsYXkodjogbnVtYmVyKSB7IHRoaXMuX2xlYXZlRGVsYXkgPSB2OyB9XHJcblxyXG4gIC8qKiBQb3BvdmVyIG92ZXJsYXAgdHJpZ2dlciAqL1xyXG4gIEBJbnB1dCgnbWRlUG9wb3Zlck92ZXJsYXBUcmlnZ2VyJylcclxuICBnZXQgb3ZlcmxhcFRyaWdnZXIoKTogYm9vbGVhbiB7IHJldHVybiB0aGlzLl9vdmVybGFwVHJpZ2dlcjsgfVxyXG4gIHNldCBvdmVybGFwVHJpZ2dlcih2OiBib29sZWFuKSB7IHRoaXMuX292ZXJsYXBUcmlnZ2VyID0gdjsgfVxyXG5cclxuICAvKiogUG9wb3ZlciB0YXJnZXQgb2Zmc2V0IHggKi9cclxuICBASW5wdXQoJ21kZVBvcG92ZXJPZmZzZXRYJylcclxuICBnZXQgdGFyZ2V0T2Zmc2V0WCgpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5fdGFyZ2V0T2Zmc2V0WDsgfVxyXG4gIHNldCB0YXJnZXRPZmZzZXRYKHY6IG51bWJlcikgeyB0aGlzLl90YXJnZXRPZmZzZXRYID0gdjsgfVxyXG5cclxuICAvKiogUG9wb3ZlciB0YXJnZXQgb2Zmc2V0IHkgKi9cclxuICBASW5wdXQoJ21kZVBvcG92ZXJPZmZzZXRZJylcclxuICBnZXQgdGFyZ2V0T2Zmc2V0WSgpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5fdGFyZ2V0T2Zmc2V0WTsgfVxyXG4gIHNldCB0YXJnZXRPZmZzZXRZKHY6IG51bWJlcikgeyB0aGlzLl90YXJnZXRPZmZzZXRZID0gdjsgfVxyXG5cclxuICAvKiogUG9wb3ZlciBhcnJvdyBvZmZzZXQgeCAqL1xyXG4gIEBJbnB1dCgnbWRlUG9wb3ZlckFycm93T2Zmc2V0WCcpXHJcbiAgZ2V0IGFycm93T2Zmc2V0WCgpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5fYXJyb3dPZmZzZXRYOyB9XHJcbiAgc2V0IGFycm93T2Zmc2V0WCh2OiBudW1iZXIpIHsgdGhpcy5fYXJyb3dPZmZzZXRYID0gdjsgfVxyXG5cclxuICAvKiogUG9wb3ZlciBhcnJvdyB3aWR0aCAqL1xyXG4gIEBJbnB1dCgnbWRlUG9wb3ZlckFycm93V2lkdGgnKVxyXG4gIGdldCBhcnJvd1dpZHRoKCk6IG51bWJlciB7IHJldHVybiB0aGlzLl9hcnJvd1dpZHRoOyB9XHJcbiAgc2V0IGFycm93V2lkdGgodjogbnVtYmVyKSB7IHRoaXMuX2Fycm93V2lkdGggPSB2OyB9XHJcblxyXG4gIC8qKiBQb3BvdmVyIGFycm93IGNvbG9yICovXHJcbiAgQElucHV0KCdtZGVQb3BvdmVyQXJyb3dDb2xvcicpXHJcbiAgZ2V0IGFycm93Q29sb3IoKTogc3RyaW5nIHsgcmV0dXJuIHRoaXMuX2Fycm93Q29sb3I7IH1cclxuICBzZXQgYXJyb3dDb2xvcih2OiBzdHJpbmcpIHsgdGhpcy5fYXJyb3dDb2xvciA9IHY7IH1cclxuXHJcbiAgLyoqXHJcbiAgICogUG9wb3ZlciBjb250YWluZXIgY2xvc2Ugb24gY2xpY2tcclxuICAgKiBkZWZhdWx0OiB0cnVlXHJcbiAgICovXHJcbiAgQElucHV0KCdtZGVQb3BvdmVyQ2xvc2VPbkNsaWNrJylcclxuICBnZXQgY2xvc2VPbkNsaWNrKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5fY2xvc2VPbkNsaWNrOyB9XHJcbiAgc2V0IGNsb3NlT25DbGljayh2OiBib29sZWFuKSB7IHRoaXMuX2Nsb3NlT25DbGljayA9IHY7IH1cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIFBvcG92ZXIgZm9jdXMgdHJhcCB1c2luZyBjZGtUcmFwRm9jdXNcclxuICAgKiBkZWZhdWx0OiB0cnVlXHJcbiAgICovXHJcbiAgQElucHV0KCdtZGVGb2N1c1RyYXBFbmFibGVkJylcclxuICBnZXQgZm9jdXNUcmFwRW5hYmxlZCgpOiBib29sZWFuIHsgcmV0dXJuIHRoaXMuX2ZvY3VzVHJhcEVuYWJsZWQ7IH1cclxuICBzZXQgZm9jdXNUcmFwRW5hYmxlZCh2OiBib29sZWFuKSB7IHRoaXMuX2ZvY3VzVHJhcEVuYWJsZWQgPSB2OyB9XHJcblxyXG5cclxuICAvKipcclxuICAgKiBUaGlzIG1ldGhvZCB0YWtlcyBjbGFzc2VzIHNldCBvbiB0aGUgaG9zdCBtZC1wb3BvdmVyIGVsZW1lbnQgYW5kIGFwcGxpZXMgdGhlbSBvbiB0aGVcclxuICAgKiBwb3BvdmVyIHRlbXBsYXRlIHRoYXQgZGlzcGxheXMgaW4gdGhlIG92ZXJsYXkgY29udGFpbmVyLiAgT3RoZXJ3aXNlLCBpdCdzIGRpZmZpY3VsdFxyXG4gICAqIHRvIHN0eWxlIHRoZSBjb250YWluaW5nIHBvcG92ZXIgZnJvbSBvdXRzaWRlIHRoZSBjb21wb25lbnQuXHJcbiAgICogQHBhcmFtIGNsYXNzZXMgbGlzdCBvZiBjbGFzcyBuYW1lc1xyXG4gICAqL1xyXG4gIEBJbnB1dCgnY2xhc3MnKVxyXG4gIHNldCBwYW5lbENsYXNzKGNsYXNzZXM6IHN0cmluZykge1xyXG4gICAgaWYgKGNsYXNzZXMgJiYgY2xhc3Nlcy5sZW5ndGgpIHtcclxuICAgICAgdGhpcy5fY2xhc3NMaXN0ID0gY2xhc3Nlcy5zcGxpdCgnICcpLnJlZHVjZSgob2JqOiBhbnksIGNsYXNzTmFtZTogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgb2JqW2NsYXNzTmFtZV0gPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiBvYmo7XHJcbiAgICAgIH0sIHt9KTtcclxuXHJcbiAgICAgIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5jbGFzc05hbWUgPSAnJztcclxuICAgICAgdGhpcy5zZXRQb3NpdGlvbkNsYXNzZXMoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgbWV0aG9kIHRha2VzIGNsYXNzZXMgc2V0IG9uIHRoZSBob3N0IG1kLXBvcG92ZXIgZWxlbWVudCBhbmQgYXBwbGllcyB0aGVtIG9uIHRoZVxyXG4gICAqIHBvcG92ZXIgdGVtcGxhdGUgdGhhdCBkaXNwbGF5cyBpbiB0aGUgb3ZlcmxheSBjb250YWluZXIuICBPdGhlcndpc2UsIGl0J3MgZGlmZmljdWx0XHJcbiAgICogdG8gc3R5bGUgdGhlIGNvbnRhaW5pbmcgcG9wb3ZlciBmcm9tIG91dHNpZGUgdGhlIGNvbXBvbmVudC5cclxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYHBhbmVsQ2xhc3NgIGluc3RlYWQuXHJcbiAgICovXHJcbiAgQElucHV0KClcclxuICBnZXQgY2xhc3NMaXN0KCk6IHN0cmluZyB7IHJldHVybiB0aGlzLnBhbmVsQ2xhc3M7IH1cclxuICBzZXQgY2xhc3NMaXN0KGNsYXNzZXM6IHN0cmluZykgeyB0aGlzLnBhbmVsQ2xhc3MgPSBjbGFzc2VzOyB9XHJcblxyXG4gIC8qKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIHBvcG92ZXIgaXMgY2xvc2VkLiAqL1xyXG4gIEBPdXRwdXQoKSBjbG9zZSA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcclxuXHJcbiAgQFZpZXdDaGlsZChUZW1wbGF0ZVJlZikgdGVtcGxhdGVSZWY6IFRlbXBsYXRlUmVmPGFueT47XHJcblxyXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYpIHtcclxuICAgIHRoaXMuc2V0UG9zaXRpb25DbGFzc2VzKCk7XHJcbiAgfVxyXG5cclxuICBuZ09uRGVzdHJveSgpIHtcclxuICAgIHRoaXMuX2VtaXRDbG9zZUV2ZW50KCk7XHJcbiAgICB0aGlzLmNsb3NlLmNvbXBsZXRlKCk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLyoqIEhhbmRsZSBhIGtleWJvYXJkIGV2ZW50IGZyb20gdGhlIHBvcG92ZXIsIGRlbGVnYXRpbmcgdG8gdGhlIGFwcHJvcHJpYXRlIGFjdGlvbi4gKi9cclxuICBfaGFuZGxlS2V5ZG93bihldmVudDogS2V5Ym9hcmRFdmVudCkge1xyXG4gICAgc3dpdGNoIChldmVudC5rZXlDb2RlKSB7XHJcbiAgICAgIGNhc2UgRVNDQVBFOlxyXG4gICAgICAgIHRoaXMuX2VtaXRDbG9zZUV2ZW50KCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBlbWl0cyBhIGNsb3NlIGV2ZW50IHRvIHdoaWNoIHRoZSB0cmlnZ2VyIGlzIHN1YnNjcmliZWQuIFdoZW4gZW1pdHRlZCwgdGhlXHJcbiAgICogdHJpZ2dlciB3aWxsIGNsb3NlIHRoZSBwb3BvdmVyLlxyXG4gICAqL1xyXG4gIF9lbWl0Q2xvc2VFdmVudCgpOiB2b2lkIHtcclxuICAgIHRoaXMuY2xvc2UuZW1pdCgpO1xyXG4gIH1cclxuXHJcbiAgLyoqIENsb3NlIHBvcG92ZXIgb24gY2xpY2sgaWYgY2xvc2VPbkNsaWNrIGlzIHRydWUgKi9cclxuICBvbkNsaWNrKCkge1xyXG4gICAgaWYgKHRoaXMuY2xvc2VPbkNsaWNrKSB7XHJcbiAgICAgIHRoaXMuX2VtaXRDbG9zZUV2ZW50KCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUT0RPOiBSZWZhY3RvciB3aGVuIEBhbmd1bGFyL2NkayBpbmNsdWRlcyBmZWF0dXJlIEkgbWVudGlvbmVkIG9uIGdpdGh1YiBzZWUgbGluayBiZWxvdy5cclxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9tYXRlcmlhbDIvcHVsbC81NDkzI2lzc3VlY29tbWVudC0zMTMwODUzMjNcclxuICAgKi9cclxuICAvKiogRGlzYWJsZXMgY2xvc2Ugb2YgcG9wb3ZlciB3aGVuIGxlYXZpbmcgdHJpZ2dlciBlbGVtZW50IGFuZCBtb3VzZSBvdmVyIHRoZSBwb3BvdmVyICovXHJcbiAgb25Nb3VzZU92ZXIoKSB7XHJcbiAgICBpZiAodGhpcy50cmlnZ2VyRXZlbnQgPT09ICdob3ZlcicpIHtcclxuICAgICAgdGhpcy5jbG9zZURpc2FibGVkID0gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcbiAgLyoqIEVuYWJsZXMgY2xvc2Ugb2YgcG9wb3ZlciB3aGVuIG1vdXNlIGxlYXZpbmcgcG9wb3ZlciBlbGVtZW50ICovXHJcbiAgb25Nb3VzZUxlYXZlKCkge1xyXG4gICAgaWYgKHRoaXMudHJpZ2dlckV2ZW50ID09PSAnaG92ZXInKSB7XHJcbiAgICAgIHRoaXMuY2xvc2VEaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgICB0aGlzLl9lbWl0Q2xvc2VFdmVudCgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gVE9ETzogUmVmYWN0b3IgaG93IHN0eWxlcyBhcmUgc2V0IGFuZCB1cGRhdGVkIG9uIHRoZSBjb21wb25lbnQsIHVzZSBiZXN0IHByYWN0aWNlcy5cclxuICAvLyBUT0RPOiBJZiBhcnJvdyBsZWZ0IGFuZCByaWdodCBwb3NpdGlvbmluZyBpcyByZXF1ZXN0ZWQsIHNlZSBpZiBmbGV4IGRpcmVjdGlvbiBjYW4gYmUgdXNlZCB0byB3b3JrIHdpdGggb3JkZXIuXHJcbiAgLyoqIFNldHMgdGhlIGN1cnJlbnQgc3R5bGVzIGZvciB0aGUgcG9wb3ZlciB0byBhbGxvdyBmb3IgZHluYW1pY2FsbHkgY2hhbmdpbmcgc2V0dGluZ3MgKi9cclxuICBzZXRDdXJyZW50U3R5bGVzKCkge1xyXG5cclxuICAgIC8vIFRPRE86IFNlZSBpZiBhcnJvdyBwb3NpdGlvbiBjYW4gYmUgY2FsY3VsYXRlZCBhdXRvbWF0aWNhbGx5IGFuZCBhbGxvdyBvdmVycmlkZS5cclxuICAgIC8vIFRPRE86IFNlZSBpZiBmbGV4IG9yZGVyIGlzIGEgYmV0dGVyIGFsdGVybmF0aXZlIHRvIHBvc2l0aW9uIGFycm93IHRvcCBvciBib3R0b20uXHJcbiAgICB0aGlzLnBvcG92ZXJBcnJvd1N0eWxlcyA9IHtcclxuICAgICAgJ3JpZ2h0JzogdGhpcy5wb3NpdGlvblggPT09ICdiZWZvcmUnID8gKHRoaXMuYXJyb3dPZmZzZXRYIC0gdGhpcy5hcnJvd1dpZHRoKSArICdweCcgOiAnJyxcclxuICAgICAgJ2xlZnQnOiB0aGlzLnBvc2l0aW9uWCA9PT0gJ2FmdGVyJyA/ICh0aGlzLmFycm93T2Zmc2V0WCAtIHRoaXMuYXJyb3dXaWR0aCkgKyAncHgnIDogJycsXHJcbiAgICAgICdib3JkZXItdG9wJzogdGhpcy5wb3NpdGlvblkgPT09ICdiZWxvdycgP1xyXG4gICAgICAgIHRoaXMuYXJyb3dXaWR0aCArICdweCBzb2xpZCAnICsgdGhpcy5hcnJvd0NvbG9yIDogJzBweCBzb2xpZCB0cmFuc3BhcmVudCcsXHJcbiAgICAgICdib3JkZXItcmlnaHQnOiAndW5kZWZpbmVkJyA9PT0gdW5kZWZpbmVkID9cclxuICAgICAgICB0aGlzLmFycm93V2lkdGggKyAncHggc29saWQgJyArIHRoaXMuYXJyb3dDb2xvciA6XHJcbiAgICAgICAgdGhpcy5hcnJvd1dpZHRoICsgJ3B4IHNvbGlkIHRyYW5zcGFyZW50JyxcclxuICAgICAgJ2JvcmRlci1ib3R0b20nOiB0aGlzLnBvc2l0aW9uWSA9PT0gJ2Fib3ZlJyA/XHJcbiAgICAgICAgdGhpcy5hcnJvd1dpZHRoICsgJ3B4IHNvbGlkICcgKyB0aGlzLmFycm93Q29sb3IgOlxyXG4gICAgICAgIHRoaXMuYXJyb3dXaWR0aCArICdweCBzb2xpZCB0cmFuc3BhcmVudCcsXHJcbiAgICAgICdib3JkZXItbGVmdCc6ICd1bmRlZmluZWQnID09PSB1bmRlZmluZWQgP1xyXG4gICAgICAgIHRoaXMuYXJyb3dXaWR0aCArICdweCBzb2xpZCAnICsgdGhpcy5hcnJvd0NvbG9yIDpcclxuICAgICAgICB0aGlzLmFycm93V2lkdGggKyAncHggc29saWQgdHJhbnNwYXJlbnQnLFxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBUT0RPOiBSZW1vdmUgaWYgZmxleCBvcmRlciBpcyBhZGRlZC5cclxuICAgIHRoaXMucG9wb3ZlckNvbnRlbnRTdHlsZXMgPSB7XHJcbiAgICAgICdwYWRkaW5nLXRvcCc6IHRoaXMub3ZlcmxhcFRyaWdnZXIgPT09IHRydWUgPyAnMHB4JyA6IHRoaXMuYXJyb3dXaWR0aCArICdweCcsXHJcbiAgICAgICdwYWRkaW5nLWJvdHRvbSc6IHRoaXMub3ZlcmxhcFRyaWdnZXIgPT09IHRydWUgPyAnMHB4JyA6ICh0aGlzLmFycm93V2lkdGgpICsgJ3B4JyxcclxuICAgICAgJ21hcmdpbi10b3AnOiB0aGlzLm92ZXJsYXBUcmlnZ2VyID09PSBmYWxzZSAmJiB0aGlzLnBvc2l0aW9uWSA9PT0gJ2JlbG93JyAmJiB0aGlzLmNvbnRhaW5lclBvc2l0aW9uaW5nID09PSBmYWxzZSA/XHJcbiAgICAgICAgLSh0aGlzLmFycm93V2lkdGggKiAyKSArICdweCcgOiAnMHB4J1xyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEl0J3MgbmVjZXNzYXJ5IHRvIHNldCBwb3NpdGlvbi1iYXNlZCBjbGFzc2VzIHRvIGVuc3VyZSB0aGUgcG9wb3ZlciBwYW5lbCBhbmltYXRpb25cclxuICAgKiBmb2xkcyBvdXQgZnJvbSB0aGUgY29ycmVjdCBkaXJlY3Rpb24uXHJcbiAgICovXHJcbiAgc2V0UG9zaXRpb25DbGFzc2VzKHBvc1ggPSB0aGlzLnBvc2l0aW9uWCwgcG9zWSA9IHRoaXMucG9zaXRpb25ZKTogdm9pZCB7XHJcbiAgICB0aGlzLl9jbGFzc0xpc3RbJ21kZS1wb3BvdmVyLWJlZm9yZSddID0gcG9zWCA9PT0gJ2JlZm9yZSc7XHJcbiAgICB0aGlzLl9jbGFzc0xpc3RbJ21kZS1wb3BvdmVyLWFmdGVyJ10gPSBwb3NYID09PSAnYWZ0ZXInO1xyXG4gICAgdGhpcy5fY2xhc3NMaXN0WydtZGUtcG9wb3Zlci1hYm92ZSddID0gcG9zWSA9PT0gJ2Fib3ZlJztcclxuICAgIHRoaXMuX2NsYXNzTGlzdFsnbWRlLXBvcG92ZXItYmVsb3cnXSA9IHBvc1kgPT09ICdiZWxvdyc7XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCB7XHJcbiAgQWZ0ZXJWaWV3SW5pdCxcclxuICBEaXJlY3RpdmUsXHJcbiAgRWxlbWVudFJlZixcclxuICBFdmVudEVtaXR0ZXIsXHJcbiAgSW5wdXQsXHJcbiAgT25EZXN0cm95LFxyXG4gIE9wdGlvbmFsLFxyXG4gIE91dHB1dCxcclxuICBWaWV3Q29udGFpbmVyUmVmLFxyXG4gIEhvc3RMaXN0ZW5lcixcclxuICBIb3N0QmluZGluZyxcclxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuXHJcblxyXG5pbXBvcnQgeyBpc0Zha2VNb3VzZWRvd25Gcm9tU2NyZWVuUmVhZGVyIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2ExMXknO1xyXG5pbXBvcnQgeyBEaXJlY3Rpb24sIERpcmVjdGlvbmFsaXR5IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2JpZGknO1xyXG5pbXBvcnQge1xyXG4gIENvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3ksXHJcbiAgT3ZlcmxheSxcclxuICBPdmVybGF5UmVmLFxyXG4gIE92ZXJsYXlDb25maWcsXHJcbiAgSG9yaXpvbnRhbENvbm5lY3Rpb25Qb3MsXHJcbiAgVmVydGljYWxDb25uZWN0aW9uUG9zLFxyXG4gIEZsZXhpYmxlQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneVxyXG59IGZyb20gJ0Bhbmd1bGFyL2Nkay9vdmVybGF5JztcclxuaW1wb3J0IHsgVGVtcGxhdGVQb3J0YWwgfSBmcm9tICdAYW5ndWxhci9jZGsvcG9ydGFsJztcclxuXHJcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xyXG5cclxuaW1wb3J0IHsgZmlyc3QgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcblxyXG5pbXBvcnQgeyBNZGVQb3BvdmVyUGFuZWwsIE1kZVRhcmdldCB9IGZyb20gJy4vcG9wb3Zlci1pbnRlcmZhY2VzJztcclxuaW1wb3J0IHsgTWRlUG9wb3ZlclBvc2l0aW9uWCwgTWRlUG9wb3ZlclBvc2l0aW9uWSwgTWRlUG9wb3ZlclRyaWdnZXJFdmVudCB9IGZyb20gJy4vcG9wb3Zlci10eXBlcyc7XHJcbmltcG9ydCB7IHRocm93TWRlUG9wb3Zlck1pc3NpbmdFcnJvciB9IGZyb20gJy4vcG9wb3Zlci1lcnJvcnMnO1xyXG5cclxuXHJcblxyXG4vKipcclxuICogVGhpcyBkaXJlY3RpdmUgaXMgaW50ZW5kZWQgdG8gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGFuIG1kZS1wb3BvdmVyIHRhZy4gSXQgaXNcclxuICogcmVzcG9uc2libGUgZm9yIHRvZ2dsaW5nIHRoZSBkaXNwbGF5IG9mIHRoZSBwcm92aWRlZCBwb3BvdmVyIGluc3RhbmNlLlxyXG4gKi9cclxuXHJcbkBEaXJlY3RpdmUoe1xyXG4gIHNlbGVjdG9yOiAnW21kZVBvcG92ZXJUcmlnZ2VyRm9yXScsXHJcbiAgZXhwb3J0QXM6ICdtZGVQb3BvdmVyVHJpZ2dlcidcclxufSlcclxuZXhwb3J0IGNsYXNzIE1kZVBvcG92ZXJUcmlnZ2VyIGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCwgT25EZXN0cm95IHsgLy8gdHNsaW50OmRpc2FibGUtbGluZTpkaXJlY3RpdmUtY2xhc3Mtc3VmZml4XHJcblxyXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLmFyaWEtaGFzcG9wdXAnKSBhcmlhSGFzcG9wdXAgPSB0cnVlO1xyXG5cclxuICAgIHByaXZhdGUgX3BvcnRhbDogVGVtcGxhdGVQb3J0YWw8YW55PjtcclxuICAgIHByaXZhdGUgX292ZXJsYXlSZWY6IE92ZXJsYXlSZWYgfCBudWxsID0gbnVsbDtcclxuICAgIHByaXZhdGUgX3BvcG92ZXJPcGVuID0gZmFsc2U7XHJcbiAgICBwcml2YXRlIF9oYWx0ID0gZmFsc2U7XHJcbiAgICBwcml2YXRlIF9iYWNrZHJvcFN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xyXG4gICAgcHJpdmF0ZSBfcG9zaXRpb25TdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcclxuXHJcbiAgICBwcml2YXRlIF9tb3VzZW92ZXJUaW1lcjogYW55O1xyXG5cclxuICAgIC8vIHRyYWNraW5nIGlucHV0IHR5cGUgaXMgbmVjZXNzYXJ5IHNvIGl0J3MgcG9zc2libGUgdG8gb25seSBhdXRvLWZvY3VzXHJcbiAgICAvLyB0aGUgZmlyc3QgaXRlbSBvZiB0aGUgbGlzdCB3aGVuIHRoZSBwb3BvdmVyIGlzIG9wZW5lZCB2aWEgdGhlIGtleWJvYXJkXHJcbiAgICBwcml2YXRlIF9vcGVuZWRCeU1vdXNlID0gZmFsc2U7XHJcblxyXG4gICAgLyoqIFJlZmVyZW5jZXMgdGhlIHBvcG92ZXIgaW5zdGFuY2UgdGhhdCB0aGUgdHJpZ2dlciBpcyBhc3NvY2lhdGVkIHdpdGguICovXHJcbiAgICBASW5wdXQoJ21kZVBvcG92ZXJUcmlnZ2VyRm9yJykgcG9wb3ZlcjogTWRlUG9wb3ZlclBhbmVsO1xyXG5cclxuICAgIC8qKiBSZWZlcmVuY2VzIHRoZSBwb3BvdmVyIHRhcmdldCBpbnN0YW5jZSB0aGF0IHRoZSB0cmlnZ2VyIGlzIGFzc29jaWF0ZWQgd2l0aC4gKi9cclxuICAgIEBJbnB1dCgnbWRlUG9wb3ZlclRhcmdldEF0JykgdGFyZ2V0RWxlbWVudDogTWRlVGFyZ2V0O1xyXG5cclxuICAgIC8qKiBQb3NpdGlvbiBvZiB0aGUgcG9wb3ZlciBpbiB0aGUgWCBheGlzICovXHJcbiAgICBASW5wdXQoJ21kZVBvcG92ZXJQb3NpdGlvblgnKSBwb3NpdGlvblg6IE1kZVBvcG92ZXJQb3NpdGlvblg7XHJcblxyXG4gICAgLyoqIFBvc2l0aW9uIG9mIHRoZSBwb3BvdmVyIGluIHRoZSBZIGF4aXMgKi9cclxuICAgIEBJbnB1dCgnbWRlUG9wb3ZlclBvc2l0aW9uWScpIHBvc2l0aW9uWTogTWRlUG9wb3ZlclBvc2l0aW9uWTtcclxuXHJcbiAgICAvKiogUG9wb3ZlciB0cmlnZ2VyIGV2ZW50ICovXHJcbiAgICBASW5wdXQoJ21kZVBvcG92ZXJUcmlnZ2VyT24nKSB0cmlnZ2VyRXZlbnQ6IE1kZVBvcG92ZXJUcmlnZ2VyRXZlbnQ7XHJcblxyXG4gICAgLyoqIFBvcG92ZXIgZGVsYXkgKi9cclxuICAgIEBJbnB1dCgnbWRlUG9wb3ZlckVudGVyRGVsYXknKSBlbnRlckRlbGF5OiBudW1iZXI7XHJcblxyXG4gICAgLyoqIFBvcG92ZXIgZGVsYXkgKi9cclxuICAgIEBJbnB1dCgnbWRlUG9wb3ZlckxlYXZlRGVsYXknKSBsZWF2ZURlbGF5OiBudW1iZXI7XHJcblxyXG4gICAgLyoqIFBvcG92ZXIgb3ZlcmxhcCB0cmlnZ2VyICovXHJcbiAgICBASW5wdXQoJ21kZVBvcG92ZXJPdmVybGFwVHJpZ2dlcicpIG92ZXJsYXBUcmlnZ2VyOiBib29sZWFuO1xyXG5cclxuICAgIC8qKiBQb3BvdmVyIHRhcmdldCBvZmZzZXQgeCAqL1xyXG4gICAgQElucHV0KCdtZGVQb3BvdmVyT2Zmc2V0WCcpIHRhcmdldE9mZnNldFg6IG51bWJlcjtcclxuXHJcbiAgICAvKiogUG9wb3ZlciB0YXJnZXQgb2Zmc2V0IHkgKi9cclxuICAgIEBJbnB1dCgnbWRlUG9wb3Zlck9mZnNldFknKSB0YXJnZXRPZmZzZXRZOiBudW1iZXI7XHJcblxyXG4gICAgLyoqIFBvcG92ZXIgYXJyb3cgb2Zmc2V0IHggKi9cclxuICAgIEBJbnB1dCgnbWRlUG9wb3ZlckFycm93T2Zmc2V0WCcpIGFycm93T2Zmc2V0WDogbnVtYmVyO1xyXG5cclxuXHJcbiAgICAvKiogUG9wb3ZlciBhcnJvdyB3aWR0aCAqL1xyXG4gICAgQElucHV0KCdtZGVQb3BvdmVyQXJyb3dXaWR0aCcpIGFycm93V2lkdGg6IG51bWJlcjtcclxuXHJcblxyXG4gICAgLyoqIFBvcG92ZXIgYXJyb3cgY29sb3IgKi9cclxuICAgIEBJbnB1dCgnbWRlUG9wb3ZlckFycm93Q29sb3InKSBhcnJvd0NvbG9yOiBzdHJpbmc7XHJcblxyXG5cclxuICAgIC8qKiBQb3BvdmVyIGNvbnRhaW5lciBjbG9zZSBvbiBjbGljayAqL1xyXG4gICAgQElucHV0KCdtZGVQb3BvdmVyQ2xvc2VPbkNsaWNrJykgY2xvc2VPbkNsaWNrOiBib29sZWFuO1xyXG5cclxuXHJcbiAgICAvKiogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBhc3NvY2lhdGVkIHBvcG92ZXIgaXMgb3BlbmVkLiAqL1xyXG4gICAgQE91dHB1dCgpIG9wZW5lZCA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcclxuXHJcbiAgICAvKiogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBhc3NvY2lhdGVkIHBvcG92ZXIgaXMgY2xvc2VkLiAqL1xyXG4gICAgQE91dHB1dCgpIGNsb3NlZCA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcclxuXHJcblxyXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfb3ZlcmxheTogT3ZlcmxheSwgcHVibGljIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmLFxyXG4gICAgICAgICAgICAgIHByaXZhdGUgX3ZpZXdDb250YWluZXJSZWY6IFZpZXdDb250YWluZXJSZWYsXHJcbiAgICAgICAgICAgICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBfZGlyOiBEaXJlY3Rpb25hbGl0eSkgeyB9XHJcblxyXG4gICAgbmdBZnRlclZpZXdJbml0KCkge1xyXG4gICAgICAgIHRoaXMuX2NoZWNrUG9wb3ZlcigpO1xyXG4gICAgICAgIHRoaXMuX3NldEN1cnJlbnRDb25maWcoKTtcclxuICAgICAgICB0aGlzLnBvcG92ZXIuY2xvc2Uuc3Vic2NyaWJlKCgpID0+IHRoaXMuY2xvc2VQb3BvdmVyKCkpO1xyXG4gICAgfVxyXG5cclxuICAgIG5nT25EZXN0cm95KCkgeyB0aGlzLmRlc3Ryb3lQb3BvdmVyKCk7IH1cclxuXHJcblxyXG4gICAgcHJpdmF0ZSBfc2V0Q3VycmVudENvbmZpZygpIHtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMucG9zaXRpb25YID09PSAnYmVmb3JlJyB8fCB0aGlzLnBvc2l0aW9uWCA9PT0gJ2FmdGVyJykge1xyXG4gICAgICAgICAgdGhpcy5wb3BvdmVyLnBvc2l0aW9uWCA9IHRoaXMucG9zaXRpb25YO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMucG9zaXRpb25ZID09PSAnYWJvdmUnIHx8IHRoaXMucG9zaXRpb25ZID09PSAnYmVsb3cnKSB7XHJcbiAgICAgICAgICB0aGlzLnBvcG92ZXIucG9zaXRpb25ZID0gdGhpcy5wb3NpdGlvblk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy50cmlnZ2VyRXZlbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5wb3BvdmVyLnRyaWdnZXJFdmVudCA9IHRoaXMudHJpZ2dlckV2ZW50O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuZW50ZXJEZWxheSkge1xyXG4gICAgICAgICAgdGhpcy5wb3BvdmVyLmVudGVyRGVsYXkgPSB0aGlzLmVudGVyRGVsYXk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5sZWF2ZURlbGF5KSB7XHJcbiAgICAgICAgICB0aGlzLnBvcG92ZXIubGVhdmVEZWxheSA9IHRoaXMubGVhdmVEZWxheTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLm92ZXJsYXBUcmlnZ2VyID09PSB0cnVlIHx8IHRoaXMub3ZlcmxhcFRyaWdnZXIgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHRoaXMucG9wb3Zlci5vdmVybGFwVHJpZ2dlciA9IHRoaXMub3ZlcmxhcFRyaWdnZXI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy50YXJnZXRPZmZzZXRYKSB7XHJcbiAgICAgICAgICAgIHRoaXMucG9wb3Zlci50YXJnZXRPZmZzZXRYID0gdGhpcy50YXJnZXRPZmZzZXRYO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMudGFyZ2V0T2Zmc2V0WSkge1xyXG4gICAgICAgICAgICB0aGlzLnBvcG92ZXIudGFyZ2V0T2Zmc2V0WSA9IHRoaXMudGFyZ2V0T2Zmc2V0WTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmFycm93T2Zmc2V0WCkge1xyXG4gICAgICAgICAgICB0aGlzLnBvcG92ZXIuYXJyb3dPZmZzZXRYID0gdGhpcy5hcnJvd09mZnNldFg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5hcnJvd1dpZHRoKSB7XHJcbiAgICAgICAgICAgIHRoaXMucG9wb3Zlci5hcnJvd1dpZHRoID0gdGhpcy5hcnJvd1dpZHRoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuYXJyb3dDb2xvcikge1xyXG4gICAgICAgICAgICB0aGlzLnBvcG92ZXIuYXJyb3dDb2xvciA9IHRoaXMuYXJyb3dDb2xvcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmNsb3NlT25DbGljayA9PT0gdHJ1ZSB8fCB0aGlzLmNsb3NlT25DbGljayA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgdGhpcy5wb3BvdmVyLmNsb3NlT25DbGljayA9IHRoaXMuY2xvc2VPbkNsaWNrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5wb3BvdmVyLnNldEN1cnJlbnRTdHlsZXMoKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqIFdoZXRoZXIgdGhlIHBvcG92ZXIgaXMgb3Blbi4gKi9cclxuICAgIGdldCBwb3BvdmVyT3BlbigpOiBib29sZWFuIHsgcmV0dXJuIHRoaXMuX3BvcG92ZXJPcGVuOyB9XHJcblxyXG4gICAgQEhvc3RMaXN0ZW5lcignY2xpY2snKSBvbkNsaWNrKCkge1xyXG4gICAgICBpZiAodGhpcy5wb3BvdmVyLnRyaWdnZXJFdmVudCA9PT0gJ2NsaWNrJykge1xyXG4gICAgICAgICAgLy8gdGhpcy5wb3BvdmVyLnNldEN1cnJlbnRTdHlsZXMoKTtcclxuICAgICAgICAgIC8vIHRoaXMuX3NldEN1cnJlbnRDb25maWcoKTtcclxuICAgICAgICAgIHRoaXMudG9nZ2xlUG9wb3ZlcigpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgQEhvc3RMaXN0ZW5lcignbW91c2VlbnRlcicpIG9uTW91c2VFbnRlcigpIHtcclxuICAgICAgdGhpcy5faGFsdCA9IGZhbHNlO1xyXG4gICAgICBpZiAodGhpcy5wb3BvdmVyLnRyaWdnZXJFdmVudCA9PT0gJ2hvdmVyJykge1xyXG4gICAgICAgICAgdGhpcy5fbW91c2VvdmVyVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICB0aGlzLm9wZW5Qb3BvdmVyKCk7XHJcbiAgICAgICAgICB9LCB0aGlzLnBvcG92ZXIuZW50ZXJEZWxheSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBASG9zdExpc3RlbmVyKCdtb3VzZWxlYXZlJykgb25Nb3VzZUxlYXZlKCkge1xyXG4gICAgICBpZiAodGhpcy5wb3BvdmVyLnRyaWdnZXJFdmVudCA9PT0gJ2hvdmVyJykge1xyXG4gICAgICAgIGlmICh0aGlzLl9tb3VzZW92ZXJUaW1lcikge1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fbW91c2VvdmVyVGltZXIpO1xyXG4gICAgICAgICAgICB0aGlzLl9tb3VzZW92ZXJUaW1lciA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9wb3BvdmVyT3Blbikge1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5wb3BvdmVyLmNsb3NlRGlzYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlUG9wb3ZlcigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCB0aGlzLnBvcG92ZXIubGVhdmVEZWxheSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRoaXMuX2hhbHQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBUb2dnbGVzIHRoZSBwb3BvdmVyIGJldHdlZW4gdGhlIG9wZW4gYW5kIGNsb3NlZCBzdGF0ZXMuICovXHJcbiAgICB0b2dnbGVQb3BvdmVyKCk6IHZvaWQge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9wb3BvdmVyT3BlbiA/IHRoaXMuY2xvc2VQb3BvdmVyKCkgOiB0aGlzLm9wZW5Qb3BvdmVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIE9wZW5zIHRoZSBwb3BvdmVyLiAqL1xyXG4gICAgb3BlblBvcG92ZXIoKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9wb3BvdmVyT3BlbiAmJiAhdGhpcy5faGFsdCkge1xyXG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVPdmVybGF5KCkuYXR0YWNoKHRoaXMuX3BvcnRhbCk7XHJcblxyXG4gICAgICAgICAgICAvKiogT25seSBzdWJzY3JpYmUgdG8gYmFja2Ryb3AgaWYgdHJpZ2dlciBldmVudCBpcyBjbGljayAqL1xyXG4gICAgICAgICAgICBpZiAodGhpcy50cmlnZ2VyRXZlbnQgPT09ICdjbGljaycpIHtcclxuICAgICAgICAgICAgICB0aGlzLl9zdWJzY3JpYmVUb0JhY2tkcm9wKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuX2luaXRQb3BvdmVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBDbG9zZXMgdGhlIHBvcG92ZXIuICovXHJcbiAgICBjbG9zZVBvcG92ZXIoKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKHRoaXMuX292ZXJsYXlSZWYpIHtcclxuICAgICAgICAgIHRoaXMuX292ZXJsYXlSZWYuZGV0YWNoKCk7XHJcblxyXG4gICAgICAgICAgLyoqIE9ubHkgdW5zdWJzY3JpYmUgdG8gYmFja2Ryb3AgaWYgdHJpZ2dlciBldmVudCBpcyBjbGljayAqL1xyXG4gICAgICAgICAgaWYgKHRoaXMudHJpZ2dlckV2ZW50ID09PSAnY2xpY2snKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2JhY2tkcm9wU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgdGhpcy5fcmVzZXRQb3BvdmVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBSZW1vdmVzIHRoZSBwb3BvdmVyIGZyb20gdGhlIERPTS4gKi9cclxuICAgIGRlc3Ryb3lQb3BvdmVyKCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLl9vdmVybGF5UmVmKSB7XHJcbiAgICAgICAgICB0aGlzLl9vdmVybGF5UmVmLmRpc3Bvc2UoKTtcclxuICAgICAgICAgIHRoaXMuX292ZXJsYXlSZWYgPSBudWxsO1xyXG4gICAgICAgICAgdGhpcy5fY2xlYW5VcFN1YnNjcmlwdGlvbnMoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEZvY3VzZXMgdGhlIHBvcG92ZXIgdHJpZ2dlci4gKi9cclxuICAgIGZvY3VzKCkge1xyXG4gICAgICAgIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5mb2N1cygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBUaGUgdGV4dCBkaXJlY3Rpb24gb2YgdGhlIGNvbnRhaW5pbmcgYXBwLiAqL1xyXG4gICAgZ2V0IGRpcigpOiBEaXJlY3Rpb24ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kaXIgJiYgdGhpcy5fZGlyLnZhbHVlID09PSAncnRsJyA/ICdydGwnIDogJ2x0cic7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFRoaXMgbWV0aG9kIGVuc3VyZXMgdGhhdCB0aGUgcG9wb3ZlciBjbG9zZXMgd2hlbiB0aGUgb3ZlcmxheSBiYWNrZHJvcCBpcyBjbGlja2VkLlxyXG4gICAgKiBXZSBkbyBub3QgdXNlIGZpcnN0KCkgaGVyZSBiZWNhdXNlIGRvaW5nIHNvIHdvdWxkIG5vdCBjYXRjaCBjbGlja3MgZnJvbSB3aXRoaW5cclxuICAgICogdGhlIHBvcG92ZXIsIGFuZCBpdCB3b3VsZCBmYWlsIHRvIHVuc3Vic2NyaWJlIHByb3Blcmx5LiBJbnN0ZWFkLCB3ZSB1bnN1YnNjcmliZVxyXG4gICAgKiBleHBsaWNpdGx5IHdoZW4gdGhlIHBvcG92ZXIgaXMgY2xvc2VkIG9yIGRlc3Ryb3llZC5cclxuICAgICovXHJcbiAgICBwcml2YXRlIF9zdWJzY3JpYmVUb0JhY2tkcm9wKCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLl9vdmVybGF5UmVmKSB7XHJcbiAgICAgICAgICB0aGlzLl9iYWNrZHJvcFN1YnNjcmlwdGlvbiA9IHRoaXMuX292ZXJsYXlSZWYuYmFja2Ryb3BDbGljaygpLnN1YnNjcmliZSgoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucG9wb3Zlci5fZW1pdENsb3NlRXZlbnQoKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogVGhpcyBtZXRob2Qgc2V0cyB0aGUgcG9wb3ZlciBzdGF0ZSB0byBvcGVuIGFuZCBmb2N1c2VzIHRoZSBmaXJzdCBpdGVtIGlmXHJcbiAgICAqIHRoZSBwb3BvdmVyIHdhcyBvcGVuZWQgdmlhIHRoZSBrZXlib2FyZC5cclxuICAgICovXHJcbiAgICBwcml2YXRlIF9pbml0UG9wb3ZlcigpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl9zZXRJc1BvcG92ZXJPcGVuKHRydWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBUaGlzIG1ldGhvZCByZXNldHMgdGhlIHBvcG92ZXIgd2hlbiBpdCdzIGNsb3NlZCwgbW9zdCBpbXBvcnRhbnRseSByZXN0b3JpbmdcclxuICAgICogZm9jdXMgdG8gdGhlIHBvcG92ZXIgdHJpZ2dlciBpZiB0aGUgcG9wb3ZlciB3YXMgb3BlbmVkIHZpYSB0aGUga2V5Ym9hcmQuXHJcbiAgICAqL1xyXG4gICAgcHJpdmF0ZSBfcmVzZXRQb3BvdmVyKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX3NldElzUG9wb3Zlck9wZW4oZmFsc2UpO1xyXG5cclxuICAgICAgICAvLyBGb2N1cyBvbmx5IG5lZWRzIHRvIGJlIHJlc2V0IHRvIHRoZSBob3N0IGVsZW1lbnQgaWYgdGhlIHBvcG92ZXIgd2FzIG9wZW5lZFxyXG4gICAgICAgIC8vIGJ5IHRoZSBrZXlib2FyZCBhbmQgbWFudWFsbHkgc2hpZnRlZCB0byB0aGUgZmlyc3QgcG9wb3ZlciBpdGVtLlxyXG4gICAgICAgIGlmICghdGhpcy5fb3BlbmVkQnlNb3VzZSkge1xyXG4gICAgICAgICAgdGhpcy5mb2N1cygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9vcGVuZWRCeU1vdXNlID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIHNldCBzdGF0ZSByYXRoZXIgdGhhbiB0b2dnbGUgdG8gc3VwcG9ydCB0cmlnZ2VycyBzaGFyaW5nIGEgcG9wb3ZlciAqL1xyXG4gICAgcHJpdmF0ZSBfc2V0SXNQb3BvdmVyT3Blbihpc09wZW46IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl9wb3BvdmVyT3BlbiA9IGlzT3BlbjtcclxuICAgICAgICB0aGlzLl9wb3BvdmVyT3BlbiA/IHRoaXMub3BlbmVkLmVtaXQoKSA6IHRoaXMuY2xvc2VkLmVtaXQoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogIFRoaXMgbWV0aG9kIGNoZWNrcyB0aGF0IGEgdmFsaWQgaW5zdGFuY2Ugb2YgTWRQb3BvdmVyIGhhcyBiZWVuIHBhc3NlZCBpbnRvXHJcbiAgICAqICBtZFBvcG92ZXJUcmlnZ2VyRm9yLiBJZiBub3QsIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24uXHJcbiAgICAqL1xyXG4gICAgcHJpdmF0ZSBfY2hlY2tQb3BvdmVyKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5wb3BvdmVyKSB7XHJcbiAgICAgICAgICB0aHJvd01kZVBvcG92ZXJNaXNzaW5nRXJyb3IoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqICBUaGlzIG1ldGhvZCBjcmVhdGVzIHRoZSBvdmVybGF5IGZyb20gdGhlIHByb3ZpZGVkIHBvcG92ZXIncyB0ZW1wbGF0ZSBhbmQgc2F2ZXMgaXRzXHJcbiAgICAqICBPdmVybGF5UmVmIHNvIHRoYXQgaXQgY2FuIGJlIGF0dGFjaGVkIHRvIHRoZSBET00gd2hlbiBvcGVuUG9wb3ZlciBpcyBjYWxsZWQuXHJcbiAgICAqL1xyXG4gICAgcHJpdmF0ZSBfY3JlYXRlT3ZlcmxheSgpOiBPdmVybGF5UmVmIHtcclxuICAgICAgICBpZiAoIXRoaXMuX292ZXJsYXlSZWYpIHtcclxuICAgICAgICAgIHRoaXMuX3BvcnRhbCA9IG5ldyBUZW1wbGF0ZVBvcnRhbCh0aGlzLnBvcG92ZXIudGVtcGxhdGVSZWYsIHRoaXMuX3ZpZXdDb250YWluZXJSZWYpO1xyXG4gICAgICAgICAgY29uc3QgY29uZmlnID0gdGhpcy5fZ2V0T3ZlcmxheUNvbmZpZygpO1xyXG4gICAgICAgICAgdGhpcy5fc3Vic2NyaWJlVG9Qb3NpdGlvbnMoY29uZmlnLnBvc2l0aW9uU3RyYXRlZ3kgYXMgRmxleGlibGVDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5KTtcclxuICAgICAgICAgIHRoaXMuX292ZXJsYXlSZWYgPSB0aGlzLl9vdmVybGF5LmNyZWF0ZShjb25maWcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX292ZXJsYXlSZWY7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFRoaXMgbWV0aG9kIGJ1aWxkcyB0aGUgY29uZmlndXJhdGlvbiBvYmplY3QgbmVlZGVkIHRvIGNyZWF0ZSB0aGUgb3ZlcmxheSwgdGhlIE92ZXJsYXlDb25maWcuXHJcbiAgICAqIEByZXR1cm5zIE92ZXJsYXlDb25maWdcclxuICAgICovXHJcbiAgICBwcml2YXRlIF9nZXRPdmVybGF5Q29uZmlnKCk6IE92ZXJsYXlDb25maWcge1xyXG4gICAgICAgIGNvbnN0IG92ZXJsYXlTdGF0ZSA9IG5ldyBPdmVybGF5Q29uZmlnKCk7XHJcbiAgICAgICAgb3ZlcmxheVN0YXRlLnBvc2l0aW9uU3RyYXRlZ3kgPSB0aGlzLl9nZXRQb3NpdGlvbigpO1xyXG5cclxuICAgICAgICAvKiogRGlzcGxheSBvdmVybGF5IGJhY2tkcm9wIGlmIHRyaWdnZXIgZXZlbnQgaXMgY2xpY2sgKi9cclxuICAgICAgICBpZiAodGhpcy50cmlnZ2VyRXZlbnQgPT09ICdjbGljaycpIHtcclxuICAgICAgICAgIG92ZXJsYXlTdGF0ZS5oYXNCYWNrZHJvcCA9IHRydWU7XHJcbiAgICAgICAgICBvdmVybGF5U3RhdGUuYmFja2Ryb3BDbGFzcyA9ICdjZGstb3ZlcmxheS10cmFuc3BhcmVudC1iYWNrZHJvcCc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBvdmVybGF5U3RhdGUuZGlyZWN0aW9uID0gdGhpcy5kaXI7XHJcbiAgICAgICAgb3ZlcmxheVN0YXRlLnNjcm9sbFN0cmF0ZWd5ID0gdGhpcy5fb3ZlcmxheS5zY3JvbGxTdHJhdGVnaWVzLnJlcG9zaXRpb24oKTtcclxuICAgICAgICByZXR1cm4gb3ZlcmxheVN0YXRlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBMaXN0ZW5zIHRvIGNoYW5nZXMgaW4gdGhlIHBvc2l0aW9uIG9mIHRoZSBvdmVybGF5IGFuZCBzZXRzIHRoZSBjb3JyZWN0IGNsYXNzZXNcclxuICAgICogb24gdGhlIHBvcG92ZXIgYmFzZWQgb24gdGhlIG5ldyBwb3NpdGlvbi4gVGhpcyBlbnN1cmVzIHRoZSBhbmltYXRpb24gb3JpZ2luIGlzIGFsd2F5c1xyXG4gICAgKiBjb3JyZWN0LCBldmVuIGlmIGEgZmFsbGJhY2sgcG9zaXRpb24gaXMgdXNlZCBmb3IgdGhlIG92ZXJsYXkuXHJcbiAgICAqL1xyXG4gICAgcHJpdmF0ZSBfc3Vic2NyaWJlVG9Qb3NpdGlvbnMocG9zaXRpb246IEZsZXhpYmxlQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneSk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX3Bvc2l0aW9uU3Vic2NyaXB0aW9uID0gcG9zaXRpb24ucG9zaXRpb25DaGFuZ2VzLnN1YnNjcmliZShjaGFuZ2UgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBwb3Npc2lvblg6IE1kZVBvcG92ZXJQb3NpdGlvblggPSBjaGFuZ2UuY29ubmVjdGlvblBhaXIub3ZlcmxheVggPT09ICdzdGFydCcgPyAnYWZ0ZXInIDogJ2JlZm9yZSc7XHJcbiAgICAgICAgICAgIGxldCBwb3Npc2lvblk6IE1kZVBvcG92ZXJQb3NpdGlvblkgPSBjaGFuZ2UuY29ubmVjdGlvblBhaXIub3ZlcmxheVkgPT09ICd0b3AnID8gJ2JlbG93JyA6ICdhYm92ZSc7XHJcblxyXG4gICAgICAgICAgICBpZiAoIXRoaXMucG9wb3Zlci5vdmVybGFwVHJpZ2dlcikge1xyXG4gICAgICAgICAgICAgICAgcG9zaXNpb25ZID0gcG9zaXNpb25ZID09PSAnYmVsb3cnID8gJ2Fib3ZlJyA6ICdiZWxvdyc7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMucG9wb3Zlci5wb3NpdGlvblggPSBwb3Npc2lvblg7XHJcbiAgICAgICAgICAgIHRoaXMucG9wb3Zlci5wb3NpdGlvblkgPSBwb3Npc2lvblk7XHJcbiAgICAgICAgICAgIHRoaXMucG9wb3Zlci5zZXRDdXJyZW50U3R5bGVzKCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnBvcG92ZXIuc2V0UG9zaXRpb25DbGFzc2VzKHBvc2lzaW9uWCwgcG9zaXNpb25ZKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogVGhpcyBtZXRob2QgYnVpbGRzIHRoZSBwb3NpdGlvbiBzdHJhdGVneSBmb3IgdGhlIG92ZXJsYXksIHNvIHRoZSBwb3BvdmVyIGlzIHByb3Blcmx5IGNvbm5lY3RlZFxyXG4gICAgKiB0byB0aGUgdHJpZ2dlci5cclxuICAgICogQHJldHVybnMgQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneVxyXG4gICAgKi9cclxuICAgIHByaXZhdGUgX2dldFBvc2l0aW9uKCk6IEZsZXhpYmxlQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneSB7XHJcbiAgICAgICAgY29uc3QgW29yaWdpblgsIG9yaWdpbkZhbGxiYWNrWF06IEhvcml6b250YWxDb25uZWN0aW9uUG9zW10gPVxyXG4gICAgICAgICAgdGhpcy5wb3BvdmVyLnBvc2l0aW9uWCA9PT0gJ2JlZm9yZScgPyBbJ2VuZCcsICdzdGFydCddIDogWydzdGFydCcsICdlbmQnXTtcclxuXHJcbiAgICAgICAgY29uc3QgW292ZXJsYXlZLCBvdmVybGF5RmFsbGJhY2tZXTogVmVydGljYWxDb25uZWN0aW9uUG9zW10gPVxyXG4gICAgICAgICAgdGhpcy5wb3BvdmVyLnBvc2l0aW9uWSA9PT0gJ2Fib3ZlJyA/IFsnYm90dG9tJywgJ3RvcCddIDogWyd0b3AnLCAnYm90dG9tJ107XHJcblxyXG4gICAgICAgIC8vIGxldCBvcmlnaW5ZID0gb3ZlcmxheVk7XHJcbiAgICAgICAgLy8gbGV0IGZhbGxiYWNrT3JpZ2luWSA9IG92ZXJsYXlGYWxsYmFja1k7XHJcblxyXG4gICAgICAgIGxldCBvcmlnaW5ZID0gb3ZlcmxheVk7XHJcbiAgICAgICAgbGV0IG9yaWdpbkZhbGxiYWNrWSA9IG92ZXJsYXlGYWxsYmFja1k7XHJcblxyXG4gICAgICAgIGNvbnN0IG92ZXJsYXlYID0gb3JpZ2luWDtcclxuICAgICAgICBjb25zdCBvdmVybGF5RmFsbGJhY2tYID0gb3JpZ2luRmFsbGJhY2tYO1xyXG5cclxuICAgICAgICAvLyBsZXQgW29yaWdpblksIG9yaWdpbkZhbGxiYWNrWV0gPSBbb3ZlcmxheVksIG92ZXJsYXlGYWxsYmFja1ldO1xyXG4gICAgICAgIC8vIGxldCBbb3ZlcmxheVgsIG92ZXJsYXlGYWxsYmFja1hdID0gW29yaWdpblgsIG9yaWdpbkZhbGxiYWNrWF07XHJcblxyXG4gICAgICAgIC8qKiBSZXZlcnNlIG92ZXJsYXlZIGFuZCBmYWxsYmFja092ZXJsYXlZIHdoZW4gb3ZlcmxhcFRyaWdnZXIgaXMgZmFsc2UgKi9cclxuICAgICAgICBpZiAoIXRoaXMucG9wb3Zlci5vdmVybGFwVHJpZ2dlcikge1xyXG4gICAgICAgICAgb3JpZ2luWSA9IG92ZXJsYXlZID09PSAndG9wJyA/ICdib3R0b20nIDogJ3RvcCc7XHJcbiAgICAgICAgICBvcmlnaW5GYWxsYmFja1kgPSBvdmVybGF5RmFsbGJhY2tZID09PSAndG9wJyA/ICdib3R0b20nIDogJ3RvcCc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgb2Zmc2V0WCA9IDA7XHJcbiAgICAgICAgbGV0IG9mZnNldFkgPSAwO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5wb3BvdmVyLnRhcmdldE9mZnNldFggJiYgIWlzTmFOKE51bWJlcih0aGlzLnBvcG92ZXIudGFyZ2V0T2Zmc2V0WCkpKSB7XHJcbiAgICAgICAgICBvZmZzZXRYID0gTnVtYmVyKHRoaXMucG9wb3Zlci50YXJnZXRPZmZzZXRYKTtcclxuICAgICAgICAgIC8vIG9mZnNldFggPSAtMTY7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5wb3BvdmVyLnRhcmdldE9mZnNldFkgJiYgIWlzTmFOKE51bWJlcih0aGlzLnBvcG92ZXIudGFyZ2V0T2Zmc2V0WSkpKSB7XHJcbiAgICAgICAgICBvZmZzZXRZID0gTnVtYmVyKHRoaXMucG9wb3Zlci50YXJnZXRPZmZzZXRZKTtcclxuICAgICAgICAgIC8vIG9mZnNldFkgPSAtMTA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGb3Igb3ZlcnJpZGluZyBwb3NpdGlvbiBlbGVtZW50LCB3aGVuIG1kZVBvcG92ZXJUYXJnZXRBdCBoYXMgYSB2YWxpZCBlbGVtZW50IHJlZmVyZW5jZS5cclxuICAgICAgICAgKiBVc2VmdWwgZm9yIHN0aWNraW5nIHBvcG92ZXIgdG8gcGFyZW50IGVsZW1lbnQgYW5kIG9mZnNldHRpbmcgYXJyb3cgdG8gdHJpZ2dlciBlbGVtZW50LlxyXG4gICAgICAgICAqIElmIHVuZGVmaW5lZCBkZWZhdWx0cyB0byB0aGUgdHJpZ2dlciBlbGVtZW50IHJlZmVyZW5jZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBsZXQgZWxlbWVudCA9IHRoaXMuX2VsZW1lbnRSZWY7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnRhcmdldEVsZW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHRoaXMucG9wb3Zlci5jb250YWluZXJQb3NpdGlvbmluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIGVsZW1lbnQgPSB0aGlzLnRhcmdldEVsZW1lbnQuX2VsZW1lbnRSZWY7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5fb3ZlcmxheS5wb3NpdGlvbigpXHJcbiAgICAgICAgLmZsZXhpYmxlQ29ubmVjdGVkVG8oZWxlbWVudClcclxuICAgICAgICAud2l0aFBvc2l0aW9ucyhbXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgb3JpZ2luWCxcclxuICAgICAgICAgICAgICBvcmlnaW5ZLFxyXG4gICAgICAgICAgICAgIG92ZXJsYXlYLFxyXG4gICAgICAgICAgICAgIG92ZXJsYXlZLFxyXG4gICAgICAgICAgICAgIG9mZnNldFlcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgb3JpZ2luWDogb3JpZ2luRmFsbGJhY2tYLFxyXG4gICAgICAgICAgICAgIG9yaWdpblksXHJcbiAgICAgICAgICAgICAgb3ZlcmxheVg6IG92ZXJsYXlGYWxsYmFja1gsXHJcbiAgICAgICAgICAgICAgb3ZlcmxheVksXHJcbiAgICAgICAgICAgICAgb2Zmc2V0WVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgb3JpZ2luWCxcclxuICAgICAgICAgICAgb3JpZ2luWTogb3JpZ2luRmFsbGJhY2tZLFxyXG4gICAgICAgICAgICBvdmVybGF5WCxcclxuICAgICAgICAgICAgb3ZlcmxheVk6IG92ZXJsYXlGYWxsYmFja1ksXHJcbiAgICAgICAgICAgIG9mZnNldFk6IC1vZmZzZXRZXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBvcmlnaW5YOiBvcmlnaW5GYWxsYmFja1gsXHJcbiAgICAgICAgICAgIG9yaWdpblk6IG9yaWdpbkZhbGxiYWNrWSxcclxuICAgICAgICAgICAgb3ZlcmxheVg6IG92ZXJsYXlGYWxsYmFja1gsXHJcbiAgICAgICAgICAgIG92ZXJsYXlZOiBvdmVybGF5RmFsbGJhY2tZLFxyXG4gICAgICAgICAgICBvZmZzZXRZOiAtb2Zmc2V0WVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIF0pXHJcbiAgICAgICAgLndpdGhEZWZhdWx0T2Zmc2V0WChvZmZzZXRYKVxyXG4gICAgICAgIC53aXRoRGVmYXVsdE9mZnNldFkob2Zmc2V0WSk7XHJcbiAgICAgICAgLypcclxuICAgICAgICByZXR1cm4gdGhpcy5fb3ZlcmxheS5wb3NpdGlvbigpXHJcbiAgICAgICAgICAuY29ubmVjdGVkVG8oZWxlbWVudCxcclxuICAgICAgICAgICAgICB7b3JpZ2luWDogcG9zWCwgb3JpZ2luWTogb3JpZ2luWX0sXHJcbiAgICAgICAgICAgICAge292ZXJsYXlYOiBwb3NYLCBvdmVybGF5WTogb3ZlcmxheVl9KVxyXG4gICAgICAgICAgLndpdGhGYWxsYmFja1Bvc2l0aW9uKFxyXG4gICAgICAgICAgICAgIHtvcmlnaW5YOiBmYWxsYmFja1gsIG9yaWdpblk6IG9yaWdpbll9LFxyXG4gICAgICAgICAgICAgIHtvdmVybGF5WDogZmFsbGJhY2tYLCBvdmVybGF5WTogb3ZlcmxheVl9KVxyXG4gICAgICAgICAgLndpdGhGYWxsYmFja1Bvc2l0aW9uKFxyXG4gICAgICAgICAgICAgIHtvcmlnaW5YOiBwb3NYLCBvcmlnaW5ZOiBmYWxsYmFja09yaWdpbll9LFxyXG4gICAgICAgICAgICAgIHtvdmVybGF5WDogcG9zWCwgb3ZlcmxheVk6IGZhbGxiYWNrT3ZlcmxheVl9KVxyXG4gICAgICAgICAgLndpdGhGYWxsYmFja1Bvc2l0aW9uKFxyXG4gICAgICAgICAgICAgIHtvcmlnaW5YOiBmYWxsYmFja1gsIG9yaWdpblk6IGZhbGxiYWNrT3JpZ2luWX0sXHJcbiAgICAgICAgICAgICAge292ZXJsYXlYOiBmYWxsYmFja1gsIG92ZXJsYXlZOiBmYWxsYmFja092ZXJsYXlZfSlcclxuICAgICAgICAgIC53aXRoT2Zmc2V0WChvZmZzZXRYKVxyXG4gICAgICAgICAgLndpdGhPZmZzZXRZKG9mZnNldFkpO1xyXG4gICAgICAgICAgKi9cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9jbGVhblVwU3Vic2NyaXB0aW9ucygpOiB2b2lkIHtcclxuICAgICAgICBpZiAodGhpcy5fYmFja2Ryb3BTdWJzY3JpcHRpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5fYmFja2Ryb3BTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX3Bvc2l0aW9uU3Vic2NyaXB0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Bvc2l0aW9uU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIEBIb3N0TGlzdGVuZXIoJ21vdXNlZG93bicpIF9oYW5kbGVNb3VzZWRvd24oZXZlbnQ6IE1vdXNlRXZlbnQpOiB2b2lkIHtcclxuICAgICAgICBpZiAoZXZlbnQgJiYgIWlzRmFrZU1vdXNlZG93bkZyb21TY3JlZW5SZWFkZXIoZXZlbnQpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX29wZW5lZEJ5TW91c2UgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuXHJcblxyXG5ARGlyZWN0aXZlKHtcclxuICBzZWxlY3RvcjogJ21kZS1wb3BvdmVyLXRhcmdldCwgW21kZVBvcG92ZXJUYXJnZXRdJyxcclxuICBleHBvcnRBczogJ21kZVBvcG92ZXJUYXJnZXQnXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBNZGVQb3BvdmVyVGFyZ2V0IHsgLy8gdHNsaW50OmRpc2FibGUtbGluZTpkaXJlY3RpdmUtY2xhc3Mtc3VmZml4XHJcblxyXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBfZWxlbWVudFJlZjogRWxlbWVudFJlZikgeyB9XHJcblxyXG59XHJcbiIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XHJcblxyXG5pbXBvcnQgeyBPdmVybGF5TW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL292ZXJsYXknO1xyXG5cclxuaW1wb3J0IHsgTWRlUG9wb3ZlciB9IGZyb20gJy4vcG9wb3Zlcic7XHJcbmltcG9ydCB7IE1kZVBvcG92ZXJUcmlnZ2VyIH0gZnJvbSAnLi9wb3BvdmVyLXRyaWdnZXInO1xyXG5pbXBvcnQgeyBNZGVQb3BvdmVyVGFyZ2V0IH0gZnJvbSAnLi9wb3BvdmVyLXRhcmdldCc7XHJcblxyXG5ATmdNb2R1bGUoe1xyXG4gIGltcG9ydHM6IFtcclxuICAgIE92ZXJsYXlNb2R1bGUsXHJcbiAgICBDb21tb25Nb2R1bGVcclxuICBdLFxyXG4gIGV4cG9ydHM6IFtNZGVQb3BvdmVyLCBNZGVQb3BvdmVyVHJpZ2dlciwgTWRlUG9wb3ZlclRhcmdldF0sXHJcbiAgZGVjbGFyYXRpb25zOiBbTWRlUG9wb3ZlciwgTWRlUG9wb3ZlclRyaWdnZXIsIE1kZVBvcG92ZXJUYXJnZXRdLFxyXG59KVxyXG5leHBvcnQgY2xhc3MgTWRlUG9wb3Zlck1vZHVsZSB7fVxyXG4iXSwibmFtZXMiOlsidHJpZ2dlciIsInN0YXRlIiwic3R5bGUiLCJ0cmFuc2l0aW9uIiwiYW5pbWF0ZSIsIkV2ZW50RW1pdHRlciIsIkVTQ0FQRSIsIkNvbXBvbmVudCIsIkNoYW5nZURldGVjdGlvblN0cmF0ZWd5IiwiVmlld0VuY2Fwc3VsYXRpb24iLCJFbGVtZW50UmVmIiwiSG9zdEJpbmRpbmciLCJJbnB1dCIsIk91dHB1dCIsIlZpZXdDaGlsZCIsIlRlbXBsYXRlUmVmIiwiVGVtcGxhdGVQb3J0YWwiLCJPdmVybGF5Q29uZmlnIiwiaXNGYWtlTW91c2Vkb3duRnJvbVNjcmVlblJlYWRlciIsIkRpcmVjdGl2ZSIsIk92ZXJsYXkiLCJWaWV3Q29udGFpbmVyUmVmIiwiRGlyZWN0aW9uYWxpdHkiLCJPcHRpb25hbCIsIkhvc3RMaXN0ZW5lciIsIk5nTW9kdWxlIiwiT3ZlcmxheU1vZHVsZSIsIkNvbW1vbk1vZHVsZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFHQTtRQUNFLE1BQU0sS0FBSyxDQUFDLG1NQUkyQyxDQUFDLENBQUM7S0FDMUQ7Ozs7OztBQU1EO1FBQ0UsTUFBTSxLQUFLLENBQUMsaUtBQ2dGLENBQUMsQ0FBQztLQUMvRjs7Ozs7O0FBTUQ7UUFDRSxNQUFNLEtBQUssQ0FBQywrSkFDK0UsQ0FBQyxDQUFDO0tBQzlGOzs7Ozs7QUMzQkQ7Ozs7Ozs7O0FBdUJBLHlCQUFhLGdCQUFnQixHQUE2QkEsa0JBQU8sQ0FBQyxrQkFBa0IsRUFBRTtRQUNwRkMsZ0JBQUssQ0FBQyxPQUFPLEVBQUVDLGdCQUFLLENBQUM7WUFDbkIsT0FBTyxFQUFFLENBQUM7WUFDVixTQUFTLEVBQUUsVUFBVTtTQUN0QixDQUFDLENBQUM7UUFDSEMscUJBQVUsQ0FBQyxXQUFXLEVBQUU7WUFDdEJELGdCQUFLLENBQUM7Z0JBQ0osT0FBTyxFQUFFLENBQUM7Z0JBQ1YsU0FBUyxFQUFFLFVBQVU7YUFDdEIsQ0FBQztZQUNGRSxrQkFBTyxDQUFDLHdDQUF3QyxDQUFDO1NBQ2xELENBQUM7UUFDRkQscUJBQVUsQ0FBQyxXQUFXLEVBQUU7WUFDdEJDLGtCQUFPLENBQUMsbUJBQW1CLEVBQUVGLGdCQUFLLENBQUMsRUFBQyxPQUFPLEVBQUUsQ0FBQyxFQUFDLENBQUMsQ0FBQztTQUNsRCxDQUFDO0tBQ0gsQ0FBQzs7Ozs7O0FDdENGO1FBZ05FLG9CQUFvQixXQUF1QjtZQUF2QixnQkFBVyxHQUFYLFdBQVcsQ0FBWTs7d0JBL0pWLFFBQVE7Ozs7OEJBR0MsT0FBTzs4QkFDUCxPQUFPO2lDQUNELE9BQU87K0JBQ2pDLEdBQUc7K0JBQ0gsR0FBRzttQ0FDQyxJQUFJO2tDQUNMLENBQUM7a0NBQ0QsQ0FBQztpQ0FDRixFQUFFOytCQUNKLENBQUM7K0JBQ0QscUJBQXFCO2lDQUNuQixJQUFJO3FDQUNBLElBQUk7Ozs7OEJBR08sRUFBRTs7Ozt3Q0FJWCxLQUFLOzs7O2lDQUdaLEtBQUs7Ozs7MkNBWUYsSUFBSUcsaUJBQVksRUFBa0I7Ozs7eUJBc0gxQyxJQUFJQSxpQkFBWSxFQUFRO1lBS3hDLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO1NBQzNCOzhCQXZIRyxpQ0FBUzs7Ozs4QkFBSyxPQUFPLElBQUksQ0FBQyxVQUFVLENBQUM7Ozs7Z0JBQ3pDLFVBQWMsS0FBMEI7Z0JBQ3RDLElBQUksS0FBSyxLQUFLLFFBQVEsSUFBSSxLQUFLLEtBQUssT0FBTyxFQUFFO29CQUMzQywrQkFBK0IsRUFBRSxDQUFDO2lCQUNuQztnQkFDRCxJQUFJLENBQUMsVUFBVSxHQUFHLEtBQUssQ0FBQztnQkFDeEIsSUFBSSxDQUFDLGtCQUFrQixFQUFFLENBQUM7YUFDM0I7Ozs7OEJBSUcsaUNBQVM7Ozs7OEJBQUssT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDOzs7O2dCQUN6QyxVQUFjLEtBQTBCO2dCQUN0QyxJQUFJLEtBQUssS0FBSyxPQUFPLElBQUksS0FBSyxLQUFLLE9BQU8sRUFBRTtvQkFDMUMsK0JBQStCLEVBQUUsQ0FBQztpQkFDbkM7Z0JBQ0QsSUFBSSxDQUFDLFVBQVUsR0FBRyxLQUFLLENBQUM7Z0JBQ3hCLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO2FBQzNCOzs7OzhCQUlHLG9DQUFZOzs7OzhCQUE2QixPQUFPLElBQUksQ0FBQyxhQUFhLENBQUM7Ozs7Z0JBQ3ZFLFVBQWlCLENBQXlCLElBQUksSUFBSSxDQUFDLGFBQWEsR0FBRyxDQUFDLENBQUMsRUFBRTs7Ozs4QkFJbkUsa0NBQVU7Ozs7OEJBQWEsT0FBTyxJQUFJLENBQUMsV0FBVyxDQUFDOzs7O2dCQUNuRCxVQUFlLENBQVMsSUFBSSxJQUFJLENBQUMsV0FBVyxHQUFHLENBQUMsQ0FBQyxFQUFFOzs7OzhCQUkvQyxrQ0FBVTs7Ozs4QkFBYSxPQUFPLElBQUksQ0FBQyxXQUFXLENBQUM7Ozs7Z0JBQ25ELFVBQWUsQ0FBUyxJQUFJLElBQUksQ0FBQyxXQUFXLEdBQUcsQ0FBQyxDQUFDLEVBQUU7Ozs7OEJBSS9DLHNDQUFjOzs7OzhCQUFjLE9BQU8sSUFBSSxDQUFDLGVBQWUsQ0FBQzs7OztnQkFDNUQsVUFBbUIsQ0FBVSxJQUFJLElBQUksQ0FBQyxlQUFlLEdBQUcsQ0FBQyxDQUFDLEVBQUU7Ozs7OEJBSXhELHFDQUFhOzs7OzhCQUFhLE9BQU8sSUFBSSxDQUFDLGNBQWMsQ0FBQzs7OztnQkFDekQsVUFBa0IsQ0FBUyxJQUFJLElBQUksQ0FBQyxjQUFjLEdBQUcsQ0FBQyxDQUFDLEVBQUU7Ozs7OEJBSXJELHFDQUFhOzs7OzhCQUFhLE9BQU8sSUFBSSxDQUFDLGNBQWMsQ0FBQzs7OztnQkFDekQsVUFBa0IsQ0FBUyxJQUFJLElBQUksQ0FBQyxjQUFjLEdBQUcsQ0FBQyxDQUFDLEVBQUU7Ozs7OEJBSXJELG9DQUFZOzs7OzhCQUFhLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQzs7OztnQkFDdkQsVUFBaUIsQ0FBUyxJQUFJLElBQUksQ0FBQyxhQUFhLEdBQUcsQ0FBQyxDQUFDLEVBQUU7Ozs7OEJBSW5ELGtDQUFVOzs7OzhCQUFhLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQzs7OztnQkFDbkQsVUFBZSxDQUFTLElBQUksSUFBSSxDQUFDLFdBQVcsR0FBRyxDQUFDLENBQUMsRUFBRTs7Ozs4QkFJL0Msa0NBQVU7Ozs7OEJBQWEsT0FBTyxJQUFJLENBQUMsV0FBVyxDQUFDOzs7O2dCQUNuRCxVQUFlLENBQVMsSUFBSSxJQUFJLENBQUMsV0FBVyxHQUFHLENBQUMsQ0FBQyxFQUFFOzs7OzhCQU8vQyxvQ0FBWTs7Ozs7OEJBQWMsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDOzs7O2dCQUN4RCxVQUFpQixDQUFVLElBQUksSUFBSSxDQUFDLGFBQWEsR0FBRyxDQUFDLENBQUMsRUFBRTs7Ozs4QkFRcEQsd0NBQWdCOzs7Ozs4QkFBYyxPQUFPLElBQUksQ0FBQyxpQkFBaUIsQ0FBQzs7OztnQkFDaEUsVUFBcUIsQ0FBVSxJQUFJLElBQUksQ0FBQyxpQkFBaUIsR0FBRyxDQUFDLENBQUMsRUFBRTs7Ozs4QkFVNUQsa0NBQVU7Ozs7Ozs7MEJBQUMsT0FBZTtnQkFDNUIsSUFBSSxPQUFPLElBQUksT0FBTyxDQUFDLE1BQU0sRUFBRTtvQkFDN0IsSUFBSSxDQUFDLFVBQVUsR0FBRyxPQUFPLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxVQUFDLEdBQVEsRUFBRSxTQUFpQjt3QkFDdEUsR0FBRyxDQUFDLFNBQVMsQ0FBQyxHQUFHLElBQUksQ0FBQzt3QkFDdEIsT0FBTyxHQUFHLENBQUM7cUJBQ1osRUFBRSxFQUFFLENBQUMsQ0FBQztvQkFFUCxJQUFJLENBQUMsV0FBVyxDQUFDLGFBQWEsQ0FBQyxTQUFTLEdBQUcsRUFBRSxDQUFDO29CQUM5QyxJQUFJLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztpQkFDM0I7Ozs7OzhCQVVDLGlDQUFTOzs7Ozs7OzhCQUFhLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQzs7OztnQkFDakQsVUFBYyxPQUFlLElBQUksSUFBSSxDQUFDLFVBQVUsR0FBRyxPQUFPLENBQUMsRUFBRTs7Ozs7OztRQVc3RCxnQ0FBVzs7O1lBQVg7Z0JBQ0UsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO2dCQUN2QixJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFDO2FBQ3ZCOzs7Ozs7O1FBSUQsbUNBQWM7Ozs7O1lBQWQsVUFBZSxLQUFvQjtnQkFDakMsUUFBUSxLQUFLLENBQUMsT0FBTztvQkFDbkIsS0FBS0MsZUFBTTt3QkFDVCxJQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7d0JBQ3ZCLE9BQU87aUJBQ1Y7YUFDRjs7Ozs7Ozs7OztRQU1ELG9DQUFlOzs7OztZQUFmO2dCQUNFLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLENBQUM7YUFDbkI7Ozs7OztRQUdELDRCQUFPOzs7O1lBQVA7Z0JBQ0UsSUFBSSxJQUFJLENBQUMsWUFBWSxFQUFFO29CQUNyQixJQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7aUJBQ3hCO2FBQ0Y7Ozs7Ozs7Ozs7UUFPRCxnQ0FBVzs7OztZQUFYO2dCQUNFLElBQUksSUFBSSxDQUFDLFlBQVksS0FBSyxPQUFPLEVBQUU7b0JBQ2pDLElBQUksQ0FBQyxhQUFhLEdBQUcsSUFBSSxDQUFDO2lCQUMzQjthQUNGOzs7Ozs7UUFFRCxpQ0FBWTs7OztZQUFaO2dCQUNFLElBQUksSUFBSSxDQUFDLFlBQVksS0FBSyxPQUFPLEVBQUU7b0JBQ2pDLElBQUksQ0FBQyxhQUFhLEdBQUcsS0FBSyxDQUFDO29CQUMzQixJQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7aUJBQ3hCO2FBQ0Y7Ozs7Ozs7O1FBS0QscUNBQWdCOzs7O1lBQWhCOzs7Z0JBSUUsSUFBSSxDQUFDLGtCQUFrQixHQUFHO29CQUN4QixPQUFPLEVBQUUsSUFBSSxDQUFDLFNBQVMsS0FBSyxRQUFRLEdBQUcsQ0FBQyxJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQyxVQUFVLElBQUksSUFBSSxHQUFHLEVBQUU7b0JBQ3hGLE1BQU0sRUFBRSxJQUFJLENBQUMsU0FBUyxLQUFLLE9BQU8sR0FBRyxDQUFDLElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDLFVBQVUsSUFBSSxJQUFJLEdBQUcsRUFBRTtvQkFDdEYsWUFBWSxFQUFFLElBQUksQ0FBQyxTQUFTLEtBQUssT0FBTzt3QkFDdEMsSUFBSSxDQUFDLFVBQVUsR0FBRyxXQUFXLEdBQUcsSUFBSSxDQUFDLFVBQVUsR0FBRyx1QkFBdUI7b0JBQzNFLGNBQWMsRUFBRSxXQUFXLEtBQUssU0FBUzt3QkFDdkMsSUFBSSxDQUFDLFVBQVUsR0FBRyxXQUFXLEdBQUcsSUFBSSxDQUFDLFVBQVU7d0JBQy9DLElBQUksQ0FBQyxVQUFVLEdBQUcsc0JBQXNCO29CQUMxQyxlQUFlLEVBQUUsSUFBSSxDQUFDLFNBQVMsS0FBSyxPQUFPO3dCQUN6QyxJQUFJLENBQUMsVUFBVSxHQUFHLFdBQVcsR0FBRyxJQUFJLENBQUMsVUFBVTt3QkFDL0MsSUFBSSxDQUFDLFVBQVUsR0FBRyxzQkFBc0I7b0JBQzFDLGFBQWEsRUFBRSxXQUFXLEtBQUssU0FBUzt3QkFDdEMsSUFBSSxDQUFDLFVBQVUsR0FBRyxXQUFXLEdBQUcsSUFBSSxDQUFDLFVBQVU7d0JBQy9DLElBQUksQ0FBQyxVQUFVLEdBQUcsc0JBQXNCO2lCQUMzQyxDQUFDOztnQkFHRixJQUFJLENBQUMsb0JBQW9CLEdBQUc7b0JBQzFCLGFBQWEsRUFBRSxJQUFJLENBQUMsY0FBYyxLQUFLLElBQUksR0FBRyxLQUFLLEdBQUcsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJO29CQUM1RSxnQkFBZ0IsRUFBRSxJQUFJLENBQUMsY0FBYyxLQUFLLElBQUksR0FBRyxLQUFLLEdBQUcsQ0FBQyxJQUFJLENBQUMsVUFBVSxJQUFJLElBQUk7b0JBQ2pGLFlBQVksRUFBRSxJQUFJLENBQUMsY0FBYyxLQUFLLEtBQUssSUFBSSxJQUFJLENBQUMsU0FBUyxLQUFLLE9BQU8sSUFBSSxJQUFJLENBQUMsb0JBQW9CLEtBQUssS0FBSzt3QkFDOUcsRUFBRSxJQUFJLENBQUMsVUFBVSxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksR0FBRyxLQUFLO2lCQUN4QyxDQUFDO2FBQ0g7Ozs7Ozs7Ozs7OztRQU1ELHVDQUFrQjs7Ozs7OztZQUFsQixVQUFtQixJQUFxQixFQUFFLElBQXFCO2dCQUE1QyxxQkFBQTtvQkFBQSxPQUFPLElBQUksQ0FBQyxTQUFTOztnQkFBRSxxQkFBQTtvQkFBQSxPQUFPLElBQUksQ0FBQyxTQUFTOztnQkFDN0QsSUFBSSxDQUFDLFVBQVUsQ0FBQyxvQkFBb0IsQ0FBQyxHQUFHLElBQUksS0FBSyxRQUFRLENBQUM7Z0JBQzFELElBQUksQ0FBQyxVQUFVLENBQUMsbUJBQW1CLENBQUMsR0FBRyxJQUFJLEtBQUssT0FBTyxDQUFDO2dCQUN4RCxJQUFJLENBQUMsVUFBVSxDQUFDLG1CQUFtQixDQUFDLEdBQUcsSUFBSSxLQUFLLE9BQU8sQ0FBQztnQkFDeEQsSUFBSSxDQUFDLFVBQVUsQ0FBQyxtQkFBbUIsQ0FBQyxHQUFHLElBQUksS0FBSyxPQUFPLENBQUM7YUFDekQ7O29CQXBSRkMsY0FBUyxTQUFDO3dCQUNULFFBQVEsRUFBRSxhQUFhO3dCQUN2QixRQUFRLEVBQUUsdW9CQVdYO3dCQUNDLE1BQU0sRUFBRSxDQUFDLDhoQkFBOGhCLENBQUM7d0JBQ3hpQixlQUFlLEVBQUVDLDRCQUF1QixDQUFDLE1BQU07d0JBQy9DLGFBQWEsRUFBRUMsc0JBQWlCLENBQUMsSUFBSTt3QkFDckMsVUFBVSxFQUFFOzRCQUNWLGdCQUFnQjt5QkFDakI7d0JBQ0QsUUFBUSxFQUFFLFlBQVk7cUJBQ3ZCOzs7Ozt3QkFyQ0NDLGVBQVU7Ozs7NkJBd0NUQyxnQkFBVyxTQUFDLFdBQVc7a0NBeUN2QkMsVUFBSyxTQUFDLHFCQUFxQjtrQ0FXM0JBLFVBQUssU0FBQyxxQkFBcUI7cUNBVzNCQSxVQUFLLFNBQUMscUJBQXFCO21DQUszQkEsVUFBSyxTQUFDLHNCQUFzQjttQ0FLNUJBLFVBQUssU0FBQyxzQkFBc0I7dUNBSzVCQSxVQUFLLFNBQUMsMEJBQTBCO3NDQUtoQ0EsVUFBSyxTQUFDLG1CQUFtQjtzQ0FLekJBLFVBQUssU0FBQyxtQkFBbUI7cUNBS3pCQSxVQUFLLFNBQUMsd0JBQXdCO21DQUs5QkEsVUFBSyxTQUFDLHNCQUFzQjttQ0FLNUJBLFVBQUssU0FBQyxzQkFBc0I7cUNBUTVCQSxVQUFLLFNBQUMsd0JBQXdCO3lDQVM5QkEsVUFBSyxTQUFDLHFCQUFxQjttQ0FXM0JBLFVBQUssU0FBQyxPQUFPO2tDQW1CYkEsVUFBSzs4QkFLTEMsV0FBTTtvQ0FFTkMsY0FBUyxTQUFDQyxnQkFBVzs7eUJBOU14Qjs7Ozs7Ozs7Ozs7O1FDcUhJLDJCQUFvQixRQUFpQixFQUFTLFdBQXVCLEVBQ25ELG1CQUNZO1lBRlYsYUFBUSxHQUFSLFFBQVEsQ0FBUztZQUFTLGdCQUFXLEdBQVgsV0FBVyxDQUFZO1lBQ25ELHNCQUFpQixHQUFqQixpQkFBaUI7WUFDTCxTQUFJLEdBQUosSUFBSTs7Z0NBdEVnQixJQUFJOytCQUdiLElBQUk7Z0NBQ3RCLEtBQUs7eUJBQ1osS0FBSztrQ0FRSSxLQUFLOzs7OzBCQWlEWCxJQUFJVixpQkFBWSxFQUFROzs7OzBCQUd4QixJQUFJQSxpQkFBWSxFQUFRO1NBS1k7Ozs7UUFFdkQsMkNBQWU7OztZQUFmO2dCQUFBLGlCQUlDO2dCQUhHLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztnQkFDckIsSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUM7Z0JBQ3pCLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxjQUFNLE9BQUEsS0FBSSxDQUFDLFlBQVksRUFBRSxHQUFBLENBQUMsQ0FBQzthQUMzRDs7OztRQUVELHVDQUFXOzs7WUFBWCxjQUFnQixJQUFJLENBQUMsY0FBYyxFQUFFLENBQUMsRUFBRTs7OztRQUdoQyw2Q0FBaUI7Ozs7Z0JBRXJCLElBQUksSUFBSSxDQUFDLFNBQVMsS0FBSyxRQUFRLElBQUksSUFBSSxDQUFDLFNBQVMsS0FBSyxPQUFPLEVBQUU7b0JBQzdELElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUM7aUJBQ3pDO2dCQUVELElBQUksSUFBSSxDQUFDLFNBQVMsS0FBSyxPQUFPLElBQUksSUFBSSxDQUFDLFNBQVMsS0FBSyxPQUFPLEVBQUU7b0JBQzVELElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUM7aUJBQ3pDO2dCQUVELElBQUksSUFBSSxDQUFDLFlBQVksRUFBRTtvQkFDbkIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQztpQkFDakQ7Z0JBRUQsSUFBSSxJQUFJLENBQUMsVUFBVSxFQUFFO29CQUNuQixJQUFJLENBQUMsT0FBTyxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDO2lCQUMzQztnQkFFRCxJQUFJLElBQUksQ0FBQyxVQUFVLEVBQUU7b0JBQ25CLElBQUksQ0FBQyxPQUFPLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUM7aUJBQzNDO2dCQUVELElBQUksSUFBSSxDQUFDLGNBQWMsS0FBSyxJQUFJLElBQUksSUFBSSxDQUFDLGNBQWMsS0FBSyxLQUFLLEVBQUU7b0JBQy9ELElBQUksQ0FBQyxPQUFPLENBQUMsY0FBYyxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUM7aUJBQ3JEO2dCQUVELElBQUksSUFBSSxDQUFDLGFBQWEsRUFBRTtvQkFDcEIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxhQUFhLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQztpQkFDbkQ7Z0JBRUQsSUFBSSxJQUFJLENBQUMsYUFBYSxFQUFFO29CQUNwQixJQUFJLENBQUMsT0FBTyxDQUFDLGFBQWEsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDO2lCQUNuRDtnQkFFRCxJQUFJLElBQUksQ0FBQyxZQUFZLEVBQUU7b0JBQ25CLElBQUksQ0FBQyxPQUFPLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUM7aUJBQ2pEO2dCQUVELElBQUksSUFBSSxDQUFDLFVBQVUsRUFBRTtvQkFDakIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQztpQkFDN0M7Z0JBRUQsSUFBSSxJQUFJLENBQUMsVUFBVSxFQUFFO29CQUNqQixJQUFJLENBQUMsT0FBTyxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDO2lCQUM3QztnQkFFRCxJQUFJLElBQUksQ0FBQyxZQUFZLEtBQUssSUFBSSxJQUFJLElBQUksQ0FBQyxZQUFZLEtBQUssS0FBSyxFQUFFO29CQUMzRCxJQUFJLENBQUMsT0FBTyxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDO2lCQUNqRDtnQkFFRCxJQUFJLENBQUMsT0FBTyxDQUFDLGdCQUFnQixFQUFFLENBQUM7O1FBS3BDLHNCQUFJLDBDQUFXOzs7OztnQkFBZixjQUE2QixPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsRUFBRTs7O1dBQUE7Ozs7UUFFakMsbUNBQU87Ozs7Z0JBQzVCLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxZQUFZLEtBQUssT0FBTyxFQUFFOzs7b0JBR3ZDLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztpQkFDeEI7Ozs7O1FBR3lCLHdDQUFZOzs7OztnQkFDdEMsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7Z0JBQ25CLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxZQUFZLEtBQUssT0FBTyxFQUFFO29CQUN2QyxJQUFJLENBQUMsZUFBZSxHQUFHLFVBQVUsQ0FBQzt3QkFDOUIsS0FBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO3FCQUN0QixFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLENBQUM7aUJBQy9COzs7OztRQUd5Qix3Q0FBWTs7Ozs7Z0JBQ3RDLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxZQUFZLEtBQUssT0FBTyxFQUFFO29CQUN6QyxJQUFJLElBQUksQ0FBQyxlQUFlLEVBQUU7d0JBQ3RCLFlBQVksQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUM7d0JBQ25DLElBQUksQ0FBQyxlQUFlLEdBQUcsSUFBSSxDQUFDO3FCQUMvQjtvQkFDRCxJQUFJLElBQUksQ0FBQyxZQUFZLEVBQUU7d0JBQ25CLFVBQVUsQ0FBQzs0QkFDUCxJQUFJLENBQUMsS0FBSSxDQUFDLE9BQU8sQ0FBQyxhQUFhLEVBQUU7Z0NBQzdCLEtBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQzs2QkFDdkI7eUJBQ0osRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFDO3FCQUMvQjt5QkFBTTt3QkFDTCxJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQztxQkFDbkI7aUJBQ0Y7Ozs7Ozs7UUFJSCx5Q0FBYTs7OztZQUFiO2dCQUNJLE9BQU8sSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsWUFBWSxFQUFFLEdBQUcsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO2FBQ3ZFOzs7Ozs7UUFHRCx1Q0FBVzs7OztZQUFYO2dCQUNJLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRTtvQkFDbkMsSUFBSSxDQUFDLGNBQWMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7O29CQUczQyxJQUFJLElBQUksQ0FBQyxZQUFZLEtBQUssT0FBTyxFQUFFO3dCQUNqQyxJQUFJLENBQUMsb0JBQW9CLEVBQUUsQ0FBQztxQkFDN0I7b0JBRUQsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO2lCQUN2QjthQUNKOzs7Ozs7UUFHRCx3Q0FBWTs7OztZQUFaO2dCQUNJLElBQUksSUFBSSxDQUFDLFdBQVcsRUFBRTtvQkFDcEIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLEVBQUUsQ0FBQzs7b0JBRzFCLElBQUksSUFBSSxDQUFDLFlBQVksS0FBSyxPQUFPLEVBQUU7d0JBQ2pDLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxXQUFXLEVBQUUsQ0FBQztxQkFDMUM7b0JBRUQsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO2lCQUN0QjthQUNKOzs7Ozs7UUFHRCwwQ0FBYzs7OztZQUFkO2dCQUNJLElBQUksSUFBSSxDQUFDLFdBQVcsRUFBRTtvQkFDcEIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxPQUFPLEVBQUUsQ0FBQztvQkFDM0IsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUM7b0JBQ3hCLElBQUksQ0FBQyxxQkFBcUIsRUFBRSxDQUFDO2lCQUM5QjthQUNKOzs7Ozs7UUFHRCxpQ0FBSzs7OztZQUFMO2dCQUNJLElBQUksQ0FBQyxXQUFXLENBQUMsYUFBYSxDQUFDLEtBQUssRUFBRSxDQUFDO2FBQzFDO1FBR0Qsc0JBQUksa0NBQUc7Ozs7O2dCQUFQO2dCQUNJLE9BQU8sSUFBSSxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssS0FBSyxLQUFLLEdBQUcsS0FBSyxHQUFHLEtBQUssQ0FBQzthQUNqRTs7O1dBQUE7Ozs7Ozs7O1FBUU8sZ0RBQW9COzs7Ozs7Ozs7Z0JBQ3hCLElBQUksSUFBSSxDQUFDLFdBQVcsRUFBRTtvQkFDcEIsSUFBSSxDQUFDLHFCQUFxQixHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsYUFBYSxFQUFFLENBQUMsU0FBUyxDQUFDO3dCQUN0RSxLQUFJLENBQUMsT0FBTyxDQUFDLGVBQWUsRUFBRSxDQUFDO3FCQUNoQyxDQUFDLENBQUM7aUJBQ0o7Ozs7Ozs7UUFPRyx3Q0FBWTs7Ozs7O2dCQUNoQixJQUFJLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLENBQUM7Ozs7Ozs7UUFPekIseUNBQWE7Ozs7OztnQkFDakIsSUFBSSxDQUFDLGlCQUFpQixDQUFDLEtBQUssQ0FBQyxDQUFDOzs7Z0JBSTlCLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxFQUFFO29CQUN4QixJQUFJLENBQUMsS0FBSyxFQUFFLENBQUM7aUJBQ2Q7Z0JBQ0QsSUFBSSxDQUFDLGNBQWMsR0FBRyxLQUFLLENBQUM7Ozs7Ozs7UUFJeEIsNkNBQWlCOzs7OztzQkFBQyxNQUFlO2dCQUNyQyxJQUFJLENBQUMsWUFBWSxHQUFHLE1BQU0sQ0FBQztnQkFDM0IsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxFQUFFLENBQUM7Ozs7Ozs7UUFPeEQseUNBQWE7Ozs7OztnQkFDakIsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUU7b0JBQ2pCLDJCQUEyQixFQUFFLENBQUM7aUJBQy9COzs7Ozs7O1FBT0csMENBQWM7Ozs7OztnQkFDbEIsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUU7b0JBQ3JCLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSVcscUJBQWMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLFdBQVcsRUFBRSxJQUFJLENBQUMsaUJBQWlCLENBQUMsQ0FBQztvQkFDcEYscUJBQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO29CQUN4QyxJQUFJLENBQUMscUJBQXFCLG1CQUFDLE1BQU0sQ0FBQyxnQkFBcUQsRUFBQyxDQUFDO29CQUN6RixJQUFJLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO2lCQUNqRDtnQkFFRCxPQUFPLElBQUksQ0FBQyxXQUFXLENBQUM7Ozs7OztRQU9wQiw2Q0FBaUI7Ozs7O2dCQUNyQixxQkFBTSxZQUFZLEdBQUcsSUFBSUMscUJBQWEsRUFBRSxDQUFDO2dCQUN6QyxZQUFZLENBQUMsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDOztnQkFHcEQsSUFBSSxJQUFJLENBQUMsWUFBWSxLQUFLLE9BQU8sRUFBRTtvQkFDakMsWUFBWSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUM7b0JBQ2hDLFlBQVksQ0FBQyxhQUFhLEdBQUcsa0NBQWtDLENBQUM7aUJBQ2pFO2dCQUVELFlBQVksQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQztnQkFDbEMsWUFBWSxDQUFDLGNBQWMsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLGdCQUFnQixDQUFDLFVBQVUsRUFBRSxDQUFDO2dCQUMxRSxPQUFPLFlBQVksQ0FBQzs7Ozs7Ozs7O1FBUWhCLGlEQUFxQjs7Ozs7OztzQkFBQyxRQUEyQzs7Z0JBQ3JFLElBQUksQ0FBQyxxQkFBcUIsR0FBRyxRQUFRLENBQUMsZUFBZSxDQUFDLFNBQVMsQ0FBQyxVQUFBLE1BQU07b0JBQ2xFLHFCQUFNLFNBQVMsR0FBd0IsTUFBTSxDQUFDLGNBQWMsQ0FBQyxRQUFRLEtBQUssT0FBTyxHQUFHLE9BQU8sR0FBRyxRQUFRLENBQUM7b0JBQ3ZHLHFCQUFJLFNBQVMsR0FBd0IsTUFBTSxDQUFDLGNBQWMsQ0FBQyxRQUFRLEtBQUssS0FBSyxHQUFHLE9BQU8sR0FBRyxPQUFPLENBQUM7b0JBRWxHLElBQUksQ0FBQyxLQUFJLENBQUMsT0FBTyxDQUFDLGNBQWMsRUFBRTt3QkFDOUIsU0FBUyxHQUFHLFNBQVMsS0FBSyxPQUFPLEdBQUcsT0FBTyxHQUFHLE9BQU8sQ0FBQztxQkFDekQ7b0JBRUQsS0FBSSxDQUFDLE9BQU8sQ0FBQyxTQUFTLEdBQUcsU0FBUyxDQUFDO29CQUNuQyxLQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsR0FBRyxTQUFTLENBQUM7b0JBQ25DLEtBQUksQ0FBQyxPQUFPLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztvQkFFaEMsS0FBSSxDQUFDLE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQyxTQUFTLEVBQUUsU0FBUyxDQUFDLENBQUM7aUJBQ3pELENBQUMsQ0FBQzs7Ozs7OztRQVFDLHdDQUFZOzs7Ozs7Z0JBQ2hCLHVHQUFPLGVBQU8sRUFBRSx1QkFBZSxDQUM2QztnQkFFNUUsd0dBQU8sZ0JBQVEsRUFBRSx3QkFBZ0IsQ0FDNEM7OztnQkFLN0UscUJBQUksT0FBTyxHQUFHLFFBQVEsQ0FBQztnQkFDdkIscUJBQUksZUFBZSxHQUFHLGdCQUFnQixDQUFDO2dCQUV2QyxxQkFBTSxRQUFRLEdBQUcsT0FBTyxDQUFDO2dCQUN6QixxQkFBTSxnQkFBZ0IsR0FBRyxlQUFlLENBQUM7Ozs7Z0JBTXpDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLGNBQWMsRUFBRTtvQkFDaEMsT0FBTyxHQUFHLFFBQVEsS0FBSyxLQUFLLEdBQUcsUUFBUSxHQUFHLEtBQUssQ0FBQztvQkFDaEQsZUFBZSxHQUFHLGdCQUFnQixLQUFLLEtBQUssR0FBRyxRQUFRLEdBQUcsS0FBSyxDQUFDO2lCQUNqRTtnQkFFRCxxQkFBSSxPQUFPLEdBQUcsQ0FBQyxDQUFDO2dCQUNoQixxQkFBSSxPQUFPLEdBQUcsQ0FBQyxDQUFDO2dCQUVoQixJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsYUFBYSxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFDLEVBQUU7b0JBQzVFLE9BQU8sR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUMsQ0FBQzs7aUJBRTlDO2dCQUVELElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxhQUFhLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLENBQUMsRUFBRTtvQkFDNUUsT0FBTyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFDOztpQkFFOUM7Ozs7OztnQkFPRCxxQkFBSSxPQUFPLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQztnQkFDL0IsSUFBSSxPQUFPLElBQUksQ0FBQyxhQUFhLEtBQUssV0FBVyxFQUFFO29CQUMzQyxJQUFJLENBQUMsT0FBTyxDQUFDLG9CQUFvQixHQUFHLElBQUksQ0FBQztvQkFDekMsT0FBTyxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsV0FBVyxDQUFDO2lCQUM1QztnQkFFRCxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxFQUFFO3FCQUM5QixtQkFBbUIsQ0FBQyxPQUFPLENBQUM7cUJBQzVCLGFBQWEsQ0FBQztvQkFDYjt3QkFDSSxPQUFPLFNBQUE7d0JBQ1AsT0FBTyxTQUFBO3dCQUNQLFFBQVEsVUFBQTt3QkFDUixRQUFRLFVBQUE7d0JBQ1IsT0FBTyxTQUFBO3FCQUNWO29CQUNEO3dCQUNJLE9BQU8sRUFBRSxlQUFlO3dCQUN4QixPQUFPLFNBQUE7d0JBQ1AsUUFBUSxFQUFFLGdCQUFnQjt3QkFDMUIsUUFBUSxVQUFBO3dCQUNSLE9BQU8sU0FBQTtxQkFDVjtvQkFDRDt3QkFDRSxPQUFPLFNBQUE7d0JBQ1AsT0FBTyxFQUFFLGVBQWU7d0JBQ3hCLFFBQVEsVUFBQTt3QkFDUixRQUFRLEVBQUUsZ0JBQWdCO3dCQUMxQixPQUFPLEVBQUUsQ0FBQyxPQUFPO3FCQUNsQjtvQkFDRDt3QkFDRSxPQUFPLEVBQUUsZUFBZTt3QkFDeEIsT0FBTyxFQUFFLGVBQWU7d0JBQ3hCLFFBQVEsRUFBRSxnQkFBZ0I7d0JBQzFCLFFBQVEsRUFBRSxnQkFBZ0I7d0JBQzFCLE9BQU8sRUFBRSxDQUFDLE9BQU87cUJBQ2xCO2lCQUNGLENBQUM7cUJBQ0Qsa0JBQWtCLENBQUMsT0FBTyxDQUFDO3FCQUMzQixrQkFBa0IsQ0FBQyxPQUFPLENBQUMsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztRQW9CekIsaURBQXFCOzs7O2dCQUN6QixJQUFJLElBQUksQ0FBQyxxQkFBcUIsRUFBRTtvQkFDNUIsSUFBSSxDQUFDLHFCQUFxQixDQUFDLFdBQVcsRUFBRSxDQUFDO2lCQUM1QztnQkFDRCxJQUFJLElBQUksQ0FBQyxxQkFBcUIsRUFBRTtvQkFDNUIsSUFBSSxDQUFDLHFCQUFxQixDQUFDLFdBQVcsRUFBRSxDQUFDO2lCQUM1Qzs7Ozs7O1FBR3NCLDRDQUFnQjs7OztzQkFBQyxLQUFpQjtnQkFDekQsSUFBSSxLQUFLLElBQUksQ0FBQ0Msb0NBQStCLENBQUMsS0FBSyxDQUFDLEVBQUU7b0JBQ2xELElBQUksQ0FBQyxjQUFjLEdBQUcsSUFBSSxDQUFDO2lCQUM5Qjs7O29CQTNjUkMsY0FBUyxTQUFDO3dCQUNULFFBQVEsRUFBRSx3QkFBd0I7d0JBQ2xDLFFBQVEsRUFBRSxtQkFBbUI7cUJBQzlCOzs7Ozt3QkEzQkNDLGVBQU87d0JBaEJQVixlQUFVO3dCQU1WVyxxQkFBZ0I7d0JBT0VDLG1CQUFjLHVCQXVHbkJDLGFBQVE7Ozs7cUNBdEVsQlosZ0JBQVcsU0FBQyxvQkFBb0I7Z0NBZ0JoQ0MsVUFBSyxTQUFDLHNCQUFzQjtzQ0FHNUJBLFVBQUssU0FBQyxvQkFBb0I7a0NBRzFCQSxVQUFLLFNBQUMscUJBQXFCO2tDQUczQkEsVUFBSyxTQUFDLHFCQUFxQjtxQ0FHM0JBLFVBQUssU0FBQyxxQkFBcUI7bUNBRzNCQSxVQUFLLFNBQUMsc0JBQXNCO21DQUc1QkEsVUFBSyxTQUFDLHNCQUFzQjt1Q0FHNUJBLFVBQUssU0FBQywwQkFBMEI7c0NBR2hDQSxVQUFLLFNBQUMsbUJBQW1CO3NDQUd6QkEsVUFBSyxTQUFDLG1CQUFtQjtxQ0FHekJBLFVBQUssU0FBQyx3QkFBd0I7bUNBSTlCQSxVQUFLLFNBQUMsc0JBQXNCO21DQUk1QkEsVUFBSyxTQUFDLHNCQUFzQjtxQ0FJNUJBLFVBQUssU0FBQyx3QkFBd0I7K0JBSTlCQyxXQUFNOytCQUdOQSxXQUFNO2dDQXlFTlcsaUJBQVksU0FBQyxPQUFPO3FDQVFwQkEsaUJBQVksU0FBQyxZQUFZO3FDQVN6QkEsaUJBQVksU0FBQyxZQUFZO3lDQXVTekJBLGlCQUFZLFNBQUMsV0FBVzs7Z0NBbmY3Qjs7Ozs7OztBQ0FBO1FBU0UsMEJBQW1CLFdBQXVCO1lBQXZCLGdCQUFXLEdBQVgsV0FBVyxDQUFZO1NBQUs7O29CQU5oREwsY0FBUyxTQUFDO3dCQUNULFFBQVEsRUFBRSx3Q0FBd0M7d0JBQ2xELFFBQVEsRUFBRSxrQkFBa0I7cUJBQzdCOzs7Ozt3QkFObUJULGVBQVU7OzsrQkFBOUI7Ozs7Ozs7QUNBQTs7OztvQkFTQ2UsYUFBUSxTQUFDO3dCQUNSLE9BQU8sRUFBRTs0QkFDUEMscUJBQWE7NEJBQ2JDLG1CQUFZO3lCQUNiO3dCQUNELE9BQU8sRUFBRSxDQUFDLFVBQVUsRUFBRSxpQkFBaUIsRUFBRSxnQkFBZ0IsQ0FBQzt3QkFDMUQsWUFBWSxFQUFFLENBQUMsVUFBVSxFQUFFLGlCQUFpQixFQUFFLGdCQUFnQixDQUFDO3FCQUNoRTs7K0JBaEJEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsifQ==