import { trigger, state, style, animate, transition } from '@angular/animations';
import { Component, EventEmitter, Input, Output, TemplateRef, ViewChild, ViewEncapsulation, ElementRef, ChangeDetectionStrategy, HostBinding, Directive, Optional, ViewContainerRef, HostListener, NgModule } from '@angular/core';
import { ESCAPE } from '@angular/cdk/keycodes';
import { isFakeMousedownFromScreenReader } from '@angular/cdk/a11y';
import { Directionality } from '@angular/cdk/bidi';
import { Overlay, OverlayConfig, OverlayModule } from '@angular/cdk/overlay';
import { TemplatePortal } from '@angular/cdk/portal';
import { CommonModule } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Throws an exception for the case when popover trigger doesn't have a valid mde-popover instance
 * @return {?}
 */
function throwMdePopoverMissingError() {
    throw Error(`mde-popover-trigger: must pass in an mde-popover instance.

    Example:
      <mde-popover #popover="mdePopover"></mde-popover>
      <button [mdePopoverTriggerFor]="popover"></button>`);
}
/**
 * Throws an exception for the case when popover's mdePopoverPositionX value isn't valid.
 * In other words, it doesn't match 'before' or 'after'.
 * @return {?}
 */
function throwMdePopoverInvalidPositionX() {
    throw Error(`mdePopoverPositionX value must be either 'before' or after'.
      Example: <mde-popover mdePopoverPositionX="before" #popover="mdePopover"></mde-popover>`);
}
/**
 * Throws an exception for the case when popover's mdePopoverPositionY value isn't valid.
 * In other words, it doesn't match 'above' or 'below'.
 * @return {?}
 */
function throwMdePopoverInvalidPositionY() {
    throw Error(`mdePopoverPositionY value must be either 'above' or below'.
      Example: <mde-popover mdePopoverPositionY="above" #popover="mdePopover"></mde-popover>`);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * This animation controls the popover panel's entry and exit from the page.
 *
 * When the popover panel is added to the DOM, it scales in and fades in its border.
 *
 * When the popover panel is removed from the DOM, it simply fades out after a brief
 * delay to display the ripple.
 */
const /** @type {?} */ transformPopover = trigger('transformPopover', [
    state('enter', style({
        opacity: 1,
        transform: `scale(1)`
    })),
    transition('void => *', [
        style({
            opacity: 0,
            transform: `scale(0)`
        }),
        animate(`200ms cubic-bezier(0.25, 0.8, 0.25, 1)`)
    ]),
    transition('* => void', [
        animate('50ms 100ms linear', style({ opacity: 0 }))
    ])
]);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class MdePopover {
    /**
     * @param {?} _elementRef
     */
    constructor(_elementRef) {
        this._elementRef = _elementRef;
        // tslint:disable-line:component-class-suffix
        this.role = 'dialog';
        /**
         * Settings for popover, view setters and getters for more detail
         */
        this._positionX = 'after';
        this._positionY = 'below';
        this._triggerEvent = 'hover';
        this._enterDelay = 200;
        this._leaveDelay = 200;
        this._overlapTrigger = true;
        this._targetOffsetX = 0;
        this._targetOffsetY = 0;
        this._arrowOffsetX = 20;
        this._arrowWidth = 8;
        this._arrowColor = 'rgba(0, 0, 0, 0.12)';
        this._closeOnClick = true;
        this._focusTrapEnabled = true;
        /**
         * Config object to be passed into the popover's ngClass
         */
        this._classList = {};
        /**
         *
         */
        this.containerPositioning = false;
        /**
         * Closing disabled on popover
         */
        this.closeDisabled = false;
        /**
         * Emits the current animation state whenever it changes.
         */
        this._onAnimationStateChange = new EventEmitter();
        /**
         * Event emitted when the popover is closed.
         */
        this.close = new EventEmitter();
        this.setPositionClasses();
    }
    /**
     * Position of the popover in the X axis.
     * @return {?}
     */
    get positionX() { return this._positionX; }
    /**
     * @param {?} value
     * @return {?}
     */
    set positionX(value) {
        if (value !== 'before' && value !== 'after') {
            throwMdePopoverInvalidPositionX();
        }
        this._positionX = value;
        this.setPositionClasses();
    }
    /**
     * Position of the popover in the Y axis.
     * @return {?}
     */
    get positionY() { return this._positionY; }
    /**
     * @param {?} value
     * @return {?}
     */
    set positionY(value) {
        if (value !== 'above' && value !== 'below') {
            throwMdePopoverInvalidPositionY();
        }
        this._positionY = value;
        this.setPositionClasses();
    }
    /**
     * Popover trigger event
     * @return {?}
     */
    get triggerEvent() { return this._triggerEvent; }
    /**
     * @param {?} v
     * @return {?}
     */
    set triggerEvent(v) { this._triggerEvent = v; }
    /**
     * Popover enter delay
     * @return {?}
     */
    get enterDelay() { return this._enterDelay; }
    /**
     * @param {?} v
     * @return {?}
     */
    set enterDelay(v) { this._enterDelay = v; }
    /**
     * Popover leave delay
     * @return {?}
     */
    get leaveDelay() { return this._leaveDelay; }
    /**
     * @param {?} v
     * @return {?}
     */
    set leaveDelay(v) { this._leaveDelay = v; }
    /**
     * Popover overlap trigger
     * @return {?}
     */
    get overlapTrigger() { return this._overlapTrigger; }
    /**
     * @param {?} v
     * @return {?}
     */
    set overlapTrigger(v) { this._overlapTrigger = v; }
    /**
     * Popover target offset x
     * @return {?}
     */
    get targetOffsetX() { return this._targetOffsetX; }
    /**
     * @param {?} v
     * @return {?}
     */
    set targetOffsetX(v) { this._targetOffsetX = v; }
    /**
     * Popover target offset y
     * @return {?}
     */
    get targetOffsetY() { return this._targetOffsetY; }
    /**
     * @param {?} v
     * @return {?}
     */
    set targetOffsetY(v) { this._targetOffsetY = v; }
    /**
     * Popover arrow offset x
     * @return {?}
     */
    get arrowOffsetX() { return this._arrowOffsetX; }
    /**
     * @param {?} v
     * @return {?}
     */
    set arrowOffsetX(v) { this._arrowOffsetX = v; }
    /**
     * Popover arrow width
     * @return {?}
     */
    get arrowWidth() { return this._arrowWidth; }
    /**
     * @param {?} v
     * @return {?}
     */
    set arrowWidth(v) { this._arrowWidth = v; }
    /**
     * Popover arrow color
     * @return {?}
     */
    get arrowColor() { return this._arrowColor; }
    /**
     * @param {?} v
     * @return {?}
     */
    set arrowColor(v) { this._arrowColor = v; }
    /**
     * Popover container close on click
     * default: true
     * @return {?}
     */
    get closeOnClick() { return this._closeOnClick; }
    /**
     * @param {?} v
     * @return {?}
     */
    set closeOnClick(v) { this._closeOnClick = v; }
    /**
     * Popover focus trap using cdkTrapFocus
     * default: true
     * @return {?}
     */
    get focusTrapEnabled() { return this._focusTrapEnabled; }
    /**
     * @param {?} v
     * @return {?}
     */
    set focusTrapEnabled(v) { this._focusTrapEnabled = v; }
    /**
     * This method takes classes set on the host md-popover element and applies them on the
     * popover template that displays in the overlay container.  Otherwise, it's difficult
     * to style the containing popover from outside the component.
     * @param {?} classes list of class names
     * @return {?}
     */
    set panelClass(classes) {
        if (classes && classes.length) {
            this._classList = classes.split(' ').reduce((obj, className) => {
                obj[className] = true;
                return obj;
            }, {});
            this._elementRef.nativeElement.className = '';
            this.setPositionClasses();
        }
    }
    /**
     * This method takes classes set on the host md-popover element and applies them on the
     * popover template that displays in the overlay container.  Otherwise, it's difficult
     * to style the containing popover from outside the component.
     * @deprecated Use `panelClass` instead.
     * @return {?}
     */
    get classList() { return this.panelClass; }
    /**
     * @param {?} classes
     * @return {?}
     */
    set classList(classes) { this.panelClass = classes; }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._emitCloseEvent();
        this.close.complete();
    }
    /**
     * Handle a keyboard event from the popover, delegating to the appropriate action.
     * @param {?} event
     * @return {?}
     */
    _handleKeydown(event) {
        switch (event.keyCode) {
            case ESCAPE:
                this._emitCloseEvent();
                return;
        }
    }
    /**
     * This emits a close event to which the trigger is subscribed. When emitted, the
     * trigger will close the popover.
     * @return {?}
     */
    _emitCloseEvent() {
        this.close.emit();
    }
    /**
     * Close popover on click if closeOnClick is true
     * @return {?}
     */
    onClick() {
        if (this.closeOnClick) {
            this._emitCloseEvent();
        }
    }
    /**
     * Disables close of popover when leaving trigger element and mouse over the popover
     * @return {?}
     */
    onMouseOver() {
        if (this.triggerEvent === 'hover') {
            this.closeDisabled = true;
        }
    }
    /**
     * Enables close of popover when mouse leaving popover element
     * @return {?}
     */
    onMouseLeave() {
        if (this.triggerEvent === 'hover') {
            this.closeDisabled = false;
            this._emitCloseEvent();
        }
    }
    /**
     * Sets the current styles for the popover to allow for dynamically changing settings
     * @return {?}
     */
    setCurrentStyles() {
        // TODO: See if arrow position can be calculated automatically and allow override.
        // TODO: See if flex order is a better alternative to position arrow top or bottom.
        this.popoverArrowStyles = {
            'right': this.positionX === 'before' ? (this.arrowOffsetX - this.arrowWidth) + 'px' : '',
            'left': this.positionX === 'after' ? (this.arrowOffsetX - this.arrowWidth) + 'px' : '',
            'border-top': this.positionY === 'below' ?
                this.arrowWidth + 'px solid ' + this.arrowColor : '0px solid transparent',
            'border-right': 'undefined' === undefined ?
                this.arrowWidth + 'px solid ' + this.arrowColor :
                this.arrowWidth + 'px solid transparent',
            'border-bottom': this.positionY === 'above' ?
                this.arrowWidth + 'px solid ' + this.arrowColor :
                this.arrowWidth + 'px solid transparent',
            'border-left': 'undefined' === undefined ?
                this.arrowWidth + 'px solid ' + this.arrowColor :
                this.arrowWidth + 'px solid transparent',
        };
        // TODO: Remove if flex order is added.
        this.popoverContentStyles = {
            'padding-top': this.overlapTrigger === true ? '0px' : this.arrowWidth + 'px',
            'padding-bottom': this.overlapTrigger === true ? '0px' : (this.arrowWidth) + 'px',
            'margin-top': this.overlapTrigger === false && this.positionY === 'below' && this.containerPositioning === false ?
                -(this.arrowWidth * 2) + 'px' : '0px'
        };
    }
    /**
     * It's necessary to set position-based classes to ensure the popover panel animation
     * folds out from the correct direction.
     * @param {?=} posX
     * @param {?=} posY
     * @return {?}
     */
    setPositionClasses(posX = this.positionX, posY = this.positionY) {
        this._classList['mde-popover-before'] = posX === 'before';
        this._classList['mde-popover-after'] = posX === 'after';
        this._classList['mde-popover-above'] = posY === 'above';
        this._classList['mde-popover-below'] = posY === 'below';
    }
}
MdePopover.decorators = [
    { type: Component, args: [{
                selector: 'mde-popover',
                template: `<ng-template>
  <div class="mde-popover-panel" role="dialog" [class.mde-popover-overlap]="overlapTrigger"
       [ngClass]="_classList" [ngStyle]="popoverPanelStyles" (keydown)="_handleKeydown($event)"
       (click)="onClick()" (mouseover)="onMouseOver()" (mouseleave)="onMouseLeave()"
       [@transformPopover]="'enter'">
    <div class="mde-popover-direction-arrow" [ngStyle]="popoverArrowStyles" *ngIf="!overlapTrigger"></div>
    <div class="mde-popover-content" [ngStyle]="popoverContentStyles" cdkTrapFocus="focusTrapEnabled">
      <ng-content></ng-content>
    </div>
  </div>
</ng-template>
`,
                styles: [`.mde-popover-panel{display:flex;flex-direction:column;max-height:calc(100vh + 48px)}.mde-popover-ripple{position:absolute;top:0;left:0;bottom:0;right:0}.mde-popover-below .mde-popover-direction-arrow{position:absolute;bottom:0;width:0;height:0;border-bottom-width:0!important;z-index:99999}.mde-popover-above .mde-popover-direction-arrow{position:absolute;top:0;width:0;height:0;border-top-width:0!important;z-index:99999}.mde-popover-after .mde-popover-direction-arrow{left:20px}.mde-popover-before .mde-popover-direction-arrow{right:20px}`],
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                animations: [
                    transformPopover
                ],
                exportAs: 'mdePopover'
            },] },
];
/** @nocollapse */
MdePopover.ctorParameters = () => [
    { type: ElementRef, },
];
MdePopover.propDecorators = {
    "role": [{ type: HostBinding, args: ['attr.role',] },],
    "positionX": [{ type: Input, args: ['mdePopoverPositionX',] },],
    "positionY": [{ type: Input, args: ['mdePopoverPositionY',] },],
    "triggerEvent": [{ type: Input, args: ['mdePopoverTriggerOn',] },],
    "enterDelay": [{ type: Input, args: ['mdePopoverEnterDelay',] },],
    "leaveDelay": [{ type: Input, args: ['mdePopoverLeaveDelay',] },],
    "overlapTrigger": [{ type: Input, args: ['mdePopoverOverlapTrigger',] },],
    "targetOffsetX": [{ type: Input, args: ['mdePopoverOffsetX',] },],
    "targetOffsetY": [{ type: Input, args: ['mdePopoverOffsetY',] },],
    "arrowOffsetX": [{ type: Input, args: ['mdePopoverArrowOffsetX',] },],
    "arrowWidth": [{ type: Input, args: ['mdePopoverArrowWidth',] },],
    "arrowColor": [{ type: Input, args: ['mdePopoverArrowColor',] },],
    "closeOnClick": [{ type: Input, args: ['mdePopoverCloseOnClick',] },],
    "focusTrapEnabled": [{ type: Input, args: ['mdeFocusTrapEnabled',] },],
    "panelClass": [{ type: Input, args: ['class',] },],
    "classList": [{ type: Input },],
    "close": [{ type: Output },],
    "templateRef": [{ type: ViewChild, args: [TemplateRef,] },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * This directive is intended to be used in conjunction with an mde-popover tag. It is
 * responsible for toggling the display of the provided popover instance.
 */
class MdePopoverTrigger {
    /**
     * @param {?} _overlay
     * @param {?} _elementRef
     * @param {?} _viewContainerRef
     * @param {?} _dir
     */
    constructor(_overlay, _elementRef, _viewContainerRef, _dir) {
        this._overlay = _overlay;
        this._elementRef = _elementRef;
        this._viewContainerRef = _viewContainerRef;
        this._dir = _dir;
        // tslint:disable-line:directive-class-suffix
        this.ariaHaspopup = true;
        this._overlayRef = null;
        this._popoverOpen = false;
        this._halt = false;
        this._openedByMouse = false;
        /**
         * Event emitted when the associated popover is opened.
         */
        this.opened = new EventEmitter();
        /**
         * Event emitted when the associated popover is closed.
         */
        this.closed = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this._checkPopover();
        this._setCurrentConfig();
        this.popover.close.subscribe(() => this.closePopover());
    }
    /**
     * @return {?}
     */
    ngOnDestroy() { this.destroyPopover(); }
    /**
     * @return {?}
     */
    _setCurrentConfig() {
        if (this.positionX === 'before' || this.positionX === 'after') {
            this.popover.positionX = this.positionX;
        }
        if (this.positionY === 'above' || this.positionY === 'below') {
            this.popover.positionY = this.positionY;
        }
        if (this.triggerEvent) {
            this.popover.triggerEvent = this.triggerEvent;
        }
        if (this.enterDelay) {
            this.popover.enterDelay = this.enterDelay;
        }
        if (this.leaveDelay) {
            this.popover.leaveDelay = this.leaveDelay;
        }
        if (this.overlapTrigger === true || this.overlapTrigger === false) {
            this.popover.overlapTrigger = this.overlapTrigger;
        }
        if (this.targetOffsetX) {
            this.popover.targetOffsetX = this.targetOffsetX;
        }
        if (this.targetOffsetY) {
            this.popover.targetOffsetY = this.targetOffsetY;
        }
        if (this.arrowOffsetX) {
            this.popover.arrowOffsetX = this.arrowOffsetX;
        }
        if (this.arrowWidth) {
            this.popover.arrowWidth = this.arrowWidth;
        }
        if (this.arrowColor) {
            this.popover.arrowColor = this.arrowColor;
        }
        if (this.closeOnClick === true || this.closeOnClick === false) {
            this.popover.closeOnClick = this.closeOnClick;
        }
        this.popover.setCurrentStyles();
    }
    /**
     * Whether the popover is open.
     * @return {?}
     */
    get popoverOpen() { return this._popoverOpen; }
    /**
     * @return {?}
     */
    onClick() {
        if (this.popover.triggerEvent === 'click') {
            // this.popover.setCurrentStyles();
            // this._setCurrentConfig();
            this.togglePopover();
        }
    }
    /**
     * @return {?}
     */
    onMouseEnter() {
        this._halt = false;
        if (this.popover.triggerEvent === 'hover') {
            this._mouseoverTimer = setTimeout(() => {
                this.openPopover();
            }, this.popover.enterDelay);
        }
    }
    /**
     * @return {?}
     */
    onMouseLeave() {
        if (this.popover.triggerEvent === 'hover') {
            if (this._mouseoverTimer) {
                clearTimeout(this._mouseoverTimer);
                this._mouseoverTimer = null;
            }
            if (this._popoverOpen) {
                setTimeout(() => {
                    if (!this.popover.closeDisabled) {
                        this.closePopover();
                    }
                }, this.popover.leaveDelay);
            }
            else {
                this._halt = true;
            }
        }
    }
    /**
     * Toggles the popover between the open and closed states.
     * @return {?}
     */
    togglePopover() {
        return this._popoverOpen ? this.closePopover() : this.openPopover();
    }
    /**
     * Opens the popover.
     * @return {?}
     */
    openPopover() {
        if (!this._popoverOpen && !this._halt) {
            this._createOverlay().attach(this._portal);
            /** Only subscribe to backdrop if trigger event is click */
            if (this.triggerEvent === 'click') {
                this._subscribeToBackdrop();
            }
            this._initPopover();
        }
    }
    /**
     * Closes the popover.
     * @return {?}
     */
    closePopover() {
        if (this._overlayRef) {
            this._overlayRef.detach();
            /** Only unsubscribe to backdrop if trigger event is click */
            if (this.triggerEvent === 'click') {
                this._backdropSubscription.unsubscribe();
            }
            this._resetPopover();
        }
    }
    /**
     * Removes the popover from the DOM.
     * @return {?}
     */
    destroyPopover() {
        if (this._overlayRef) {
            this._overlayRef.dispose();
            this._overlayRef = null;
            this._cleanUpSubscriptions();
        }
    }
    /**
     * Focuses the popover trigger.
     * @return {?}
     */
    focus() {
        this._elementRef.nativeElement.focus();
    }
    /**
     * The text direction of the containing app.
     * @return {?}
     */
    get dir() {
        return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';
    }
    /**
     * This method ensures that the popover closes when the overlay backdrop is clicked.
     * We do not use first() here because doing so would not catch clicks from within
     * the popover, and it would fail to unsubscribe properly. Instead, we unsubscribe
     * explicitly when the popover is closed or destroyed.
     * @return {?}
     */
    _subscribeToBackdrop() {
        if (this._overlayRef) {
            this._backdropSubscription = this._overlayRef.backdropClick().subscribe(() => {
                this.popover._emitCloseEvent();
            });
        }
    }
    /**
     * This method sets the popover state to open and focuses the first item if
     * the popover was opened via the keyboard.
     * @return {?}
     */
    _initPopover() {
        this._setIsPopoverOpen(true);
    }
    /**
     * This method resets the popover when it's closed, most importantly restoring
     * focus to the popover trigger if the popover was opened via the keyboard.
     * @return {?}
     */
    _resetPopover() {
        this._setIsPopoverOpen(false);
        // Focus only needs to be reset to the host element if the popover was opened
        // by the keyboard and manually shifted to the first popover item.
        if (!this._openedByMouse) {
            this.focus();
        }
        this._openedByMouse = false;
    }
    /**
     * set state rather than toggle to support triggers sharing a popover
     * @param {?} isOpen
     * @return {?}
     */
    _setIsPopoverOpen(isOpen) {
        this._popoverOpen = isOpen;
        this._popoverOpen ? this.opened.emit() : this.closed.emit();
    }
    /**
     *  This method checks that a valid instance of MdPopover has been passed into
     *  mdPopoverTriggerFor. If not, an exception is thrown.
     * @return {?}
     */
    _checkPopover() {
        if (!this.popover) {
            throwMdePopoverMissingError();
        }
    }
    /**
     *  This method creates the overlay from the provided popover's template and saves its
     *  OverlayRef so that it can be attached to the DOM when openPopover is called.
     * @return {?}
     */
    _createOverlay() {
        if (!this._overlayRef) {
            this._portal = new TemplatePortal(this.popover.templateRef, this._viewContainerRef);
            const /** @type {?} */ config = this._getOverlayConfig();
            this._subscribeToPositions(/** @type {?} */ (config.positionStrategy));
            this._overlayRef = this._overlay.create(config);
        }
        return this._overlayRef;
    }
    /**
     * This method builds the configuration object needed to create the overlay, the OverlayConfig.
     * @return {?} OverlayConfig
     */
    _getOverlayConfig() {
        const /** @type {?} */ overlayState = new OverlayConfig();
        overlayState.positionStrategy = this._getPosition();
        /** Display overlay backdrop if trigger event is click */
        if (this.triggerEvent === 'click') {
            overlayState.hasBackdrop = true;
            overlayState.backdropClass = 'cdk-overlay-transparent-backdrop';
        }
        overlayState.direction = this.dir;
        overlayState.scrollStrategy = this._overlay.scrollStrategies.reposition();
        return overlayState;
    }
    /**
     * Listens to changes in the position of the overlay and sets the correct classes
     * on the popover based on the new position. This ensures the animation origin is always
     * correct, even if a fallback position is used for the overlay.
     * @param {?} position
     * @return {?}
     */
    _subscribeToPositions(position) {
        this._positionSubscription = position.positionChanges.subscribe(change => {
            const /** @type {?} */ posisionX = change.connectionPair.overlayX === 'start' ? 'after' : 'before';
            let /** @type {?} */ posisionY = change.connectionPair.overlayY === 'top' ? 'below' : 'above';
            if (!this.popover.overlapTrigger) {
                posisionY = posisionY === 'below' ? 'above' : 'below';
            }
            this.popover.positionX = posisionX;
            this.popover.positionY = posisionY;
            this.popover.setCurrentStyles();
            this.popover.setPositionClasses(posisionX, posisionY);
        });
    }
    /**
     * This method builds the position strategy for the overlay, so the popover is properly connected
     * to the trigger.
     * @return {?} ConnectedPositionStrategy
     */
    _getPosition() {
        const [originX, originFallbackX] = this.popover.positionX === 'before' ? ['end', 'start'] : ['start', 'end'];
        const [overlayY, overlayFallbackY] = this.popover.positionY === 'above' ? ['bottom', 'top'] : ['top', 'bottom'];
        // let originY = overlayY;
        // let fallbackOriginY = overlayFallbackY;
        let /** @type {?} */ originY = overlayY;
        let /** @type {?} */ originFallbackY = overlayFallbackY;
        const /** @type {?} */ overlayX = originX;
        const /** @type {?} */ overlayFallbackX = originFallbackX;
        // let [originY, originFallbackY] = [overlayY, overlayFallbackY];
        // let [overlayX, overlayFallbackX] = [originX, originFallbackX];
        /** Reverse overlayY and fallbackOverlayY when overlapTrigger is false */
        if (!this.popover.overlapTrigger) {
            originY = overlayY === 'top' ? 'bottom' : 'top';
            originFallbackY = overlayFallbackY === 'top' ? 'bottom' : 'top';
        }
        let /** @type {?} */ offsetX = 0;
        let /** @type {?} */ offsetY = 0;
        if (this.popover.targetOffsetX && !isNaN(Number(this.popover.targetOffsetX))) {
            offsetX = Number(this.popover.targetOffsetX);
            // offsetX = -16;
        }
        if (this.popover.targetOffsetY && !isNaN(Number(this.popover.targetOffsetY))) {
            offsetY = Number(this.popover.targetOffsetY);
            // offsetY = -10;
        }
        /**
         * For overriding position element, when mdePopoverTargetAt has a valid element reference.
         * Useful for sticking popover to parent element and offsetting arrow to trigger element.
         * If undefined defaults to the trigger element reference.
         */
        let /** @type {?} */ element = this._elementRef;
        if (typeof this.targetElement !== 'undefined') {
            this.popover.containerPositioning = true;
            element = this.targetElement._elementRef;
        }
        return this._overlay.position()
            .flexibleConnectedTo(element)
            .withPositions([
            {
                originX,
                originY,
                overlayX,
                overlayY,
                offsetY
            },
            {
                originX: originFallbackX,
                originY,
                overlayX: overlayFallbackX,
                overlayY,
                offsetY
            },
            {
                originX,
                originY: originFallbackY,
                overlayX,
                overlayY: overlayFallbackY,
                offsetY: -offsetY
            },
            {
                originX: originFallbackX,
                originY: originFallbackY,
                overlayX: overlayFallbackX,
                overlayY: overlayFallbackY,
                offsetY: -offsetY
            }
        ])
            .withDefaultOffsetX(offsetX)
            .withDefaultOffsetY(offsetY);
        /*
                return this._overlay.position()
                  .connectedTo(element,
                      {originX: posX, originY: originY},
                      {overlayX: posX, overlayY: overlayY})
                  .withFallbackPosition(
                      {originX: fallbackX, originY: originY},
                      {overlayX: fallbackX, overlayY: overlayY})
                  .withFallbackPosition(
                      {originX: posX, originY: fallbackOriginY},
                      {overlayX: posX, overlayY: fallbackOverlayY})
                  .withFallbackPosition(
                      {originX: fallbackX, originY: fallbackOriginY},
                      {overlayX: fallbackX, overlayY: fallbackOverlayY})
                  .withOffsetX(offsetX)
                  .withOffsetY(offsetY);
                  */
    }
    /**
     * @return {?}
     */
    _cleanUpSubscriptions() {
        if (this._backdropSubscription) {
            this._backdropSubscription.unsubscribe();
        }
        if (this._positionSubscription) {
            this._positionSubscription.unsubscribe();
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    _handleMousedown(event) {
        if (event && !isFakeMousedownFromScreenReader(event)) {
            this._openedByMouse = true;
        }
    }
}
MdePopoverTrigger.decorators = [
    { type: Directive, args: [{
                selector: '[mdePopoverTriggerFor]',
                exportAs: 'mdePopoverTrigger'
            },] },
];
/** @nocollapse */
MdePopoverTrigger.ctorParameters = () => [
    { type: Overlay, },
    { type: ElementRef, },
    { type: ViewContainerRef, },
    { type: Directionality, decorators: [{ type: Optional },] },
];
MdePopoverTrigger.propDecorators = {
    "ariaHaspopup": [{ type: HostBinding, args: ['attr.aria-haspopup',] },],
    "popover": [{ type: Input, args: ['mdePopoverTriggerFor',] },],
    "targetElement": [{ type: Input, args: ['mdePopoverTargetAt',] },],
    "positionX": [{ type: Input, args: ['mdePopoverPositionX',] },],
    "positionY": [{ type: Input, args: ['mdePopoverPositionY',] },],
    "triggerEvent": [{ type: Input, args: ['mdePopoverTriggerOn',] },],
    "enterDelay": [{ type: Input, args: ['mdePopoverEnterDelay',] },],
    "leaveDelay": [{ type: Input, args: ['mdePopoverLeaveDelay',] },],
    "overlapTrigger": [{ type: Input, args: ['mdePopoverOverlapTrigger',] },],
    "targetOffsetX": [{ type: Input, args: ['mdePopoverOffsetX',] },],
    "targetOffsetY": [{ type: Input, args: ['mdePopoverOffsetY',] },],
    "arrowOffsetX": [{ type: Input, args: ['mdePopoverArrowOffsetX',] },],
    "arrowWidth": [{ type: Input, args: ['mdePopoverArrowWidth',] },],
    "arrowColor": [{ type: Input, args: ['mdePopoverArrowColor',] },],
    "closeOnClick": [{ type: Input, args: ['mdePopoverCloseOnClick',] },],
    "opened": [{ type: Output },],
    "closed": [{ type: Output },],
    "onClick": [{ type: HostListener, args: ['click',] },],
    "onMouseEnter": [{ type: HostListener, args: ['mouseenter',] },],
    "onMouseLeave": [{ type: HostListener, args: ['mouseleave',] },],
    "_handleMousedown": [{ type: HostListener, args: ['mousedown',] },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class MdePopoverTarget {
    /**
     * @param {?} _elementRef
     */
    constructor(_elementRef) {
        this._elementRef = _elementRef;
    }
}
MdePopoverTarget.decorators = [
    { type: Directive, args: [{
                selector: 'mde-popover-target, [mdePopoverTarget]',
                exportAs: 'mdePopoverTarget'
            },] },
];
/** @nocollapse */
MdePopoverTarget.ctorParameters = () => [
    { type: ElementRef, },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class MdePopoverModule {
}
MdePopoverModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    OverlayModule,
                    CommonModule
                ],
                exports: [MdePopover, MdePopoverTrigger, MdePopoverTarget],
                declarations: [MdePopover, MdePopoverTrigger, MdePopoverTarget],
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
// export { MdePopoverPositionX, MdePopoverPositionY, MdePopoverTriggerEvent } from './popover-types';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

export { MdePopoverModule, MdePopover, transformPopover, MdePopoverTrigger, MdePopoverTarget };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWF0ZXJpYWwtZXh0ZW5kZWQtbWRlLmpzLm1hcCIsInNvdXJjZXMiOlsibmc6Ly9AbWF0ZXJpYWwtZXh0ZW5kZWQvbWRlL2xpYi9wb3BvdmVyL3BvcG92ZXItZXJyb3JzLnRzIiwibmc6Ly9AbWF0ZXJpYWwtZXh0ZW5kZWQvbWRlL2xpYi9wb3BvdmVyL3BvcG92ZXItYW5pbWF0aW9ucy50cyIsIm5nOi8vQG1hdGVyaWFsLWV4dGVuZGVkL21kZS9saWIvcG9wb3Zlci9wb3BvdmVyLnRzIiwibmc6Ly9AbWF0ZXJpYWwtZXh0ZW5kZWQvbWRlL2xpYi9wb3BvdmVyL3BvcG92ZXItdHJpZ2dlci50cyIsIm5nOi8vQG1hdGVyaWFsLWV4dGVuZGVkL21kZS9saWIvcG9wb3Zlci9wb3BvdmVyLXRhcmdldC50cyIsIm5nOi8vQG1hdGVyaWFsLWV4dGVuZGVkL21kZS9saWIvcG9wb3Zlci9wb3BvdmVyLW1vZHVsZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogVGhyb3dzIGFuIGV4Y2VwdGlvbiBmb3IgdGhlIGNhc2Ugd2hlbiBwb3BvdmVyIHRyaWdnZXIgZG9lc24ndCBoYXZlIGEgdmFsaWQgbWRlLXBvcG92ZXIgaW5zdGFuY2VcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB0aHJvd01kZVBvcG92ZXJNaXNzaW5nRXJyb3IoKSB7XHJcbiAgdGhyb3cgRXJyb3IoYG1kZS1wb3BvdmVyLXRyaWdnZXI6IG11c3QgcGFzcyBpbiBhbiBtZGUtcG9wb3ZlciBpbnN0YW5jZS5cclxuXHJcbiAgICBFeGFtcGxlOlxyXG4gICAgICA8bWRlLXBvcG92ZXIgI3BvcG92ZXI9XCJtZGVQb3BvdmVyXCI+PC9tZGUtcG9wb3Zlcj5cclxuICAgICAgPGJ1dHRvbiBbbWRlUG9wb3ZlclRyaWdnZXJGb3JdPVwicG9wb3ZlclwiPjwvYnV0dG9uPmApO1xyXG59XHJcblxyXG4vKipcclxuICogVGhyb3dzIGFuIGV4Y2VwdGlvbiBmb3IgdGhlIGNhc2Ugd2hlbiBwb3BvdmVyJ3MgbWRlUG9wb3ZlclBvc2l0aW9uWCB2YWx1ZSBpc24ndCB2YWxpZC5cclxuICogSW4gb3RoZXIgd29yZHMsIGl0IGRvZXNuJ3QgbWF0Y2ggJ2JlZm9yZScgb3IgJ2FmdGVyJy5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB0aHJvd01kZVBvcG92ZXJJbnZhbGlkUG9zaXRpb25YKCkge1xyXG4gIHRocm93IEVycm9yKGBtZGVQb3BvdmVyUG9zaXRpb25YIHZhbHVlIG11c3QgYmUgZWl0aGVyICdiZWZvcmUnIG9yIGFmdGVyJy5cclxuICAgICAgRXhhbXBsZTogPG1kZS1wb3BvdmVyIG1kZVBvcG92ZXJQb3NpdGlvblg9XCJiZWZvcmVcIiAjcG9wb3Zlcj1cIm1kZVBvcG92ZXJcIj48L21kZS1wb3BvdmVyPmApO1xyXG59XHJcblxyXG4vKipcclxuICogVGhyb3dzIGFuIGV4Y2VwdGlvbiBmb3IgdGhlIGNhc2Ugd2hlbiBwb3BvdmVyJ3MgbWRlUG9wb3ZlclBvc2l0aW9uWSB2YWx1ZSBpc24ndCB2YWxpZC5cclxuICogSW4gb3RoZXIgd29yZHMsIGl0IGRvZXNuJ3QgbWF0Y2ggJ2Fib3ZlJyBvciAnYmVsb3cnLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHRocm93TWRlUG9wb3ZlckludmFsaWRQb3NpdGlvblkoKSB7XHJcbiAgdGhyb3cgRXJyb3IoYG1kZVBvcG92ZXJQb3NpdGlvblkgdmFsdWUgbXVzdCBiZSBlaXRoZXIgJ2Fib3ZlJyBvciBiZWxvdycuXHJcbiAgICAgIEV4YW1wbGU6IDxtZGUtcG9wb3ZlciBtZGVQb3BvdmVyUG9zaXRpb25ZPVwiYWJvdmVcIiAjcG9wb3Zlcj1cIm1kZVBvcG92ZXJcIj48L21kZS1wb3BvdmVyPmApO1xyXG59XHJcbiIsImltcG9ydCB7XHJcbiAgdHJpZ2dlcixcclxuICBzdGF0ZSxcclxuICBzdHlsZSxcclxuICBhbmltYXRlLFxyXG4gIHRyYW5zaXRpb24sXHJcbiAgQW5pbWF0aW9uVHJpZ2dlck1ldGFkYXRhLFxyXG59IGZyb20gJ0Bhbmd1bGFyL2FuaW1hdGlvbnMnO1xyXG5cclxuLyoqXHJcbiAqIEJlbG93IGFyZSBhbGwgdGhlIGFuaW1hdGlvbnMgZm9yIHRoZSBtZC1wb3BvdmVyIGNvbXBvbmVudC5cclxuICogQW5pbWF0aW9uIGR1cmF0aW9uIGFuZCB0aW1pbmcgdmFsdWVzIGFyZSBiYXNlZCBvbiBBbmd1bGFySlMgTWF0ZXJpYWwuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgYW5pbWF0aW9uIGNvbnRyb2xzIHRoZSBwb3BvdmVyIHBhbmVsJ3MgZW50cnkgYW5kIGV4aXQgZnJvbSB0aGUgcGFnZS5cclxuICpcclxuICogV2hlbiB0aGUgcG9wb3ZlciBwYW5lbCBpcyBhZGRlZCB0byB0aGUgRE9NLCBpdCBzY2FsZXMgaW4gYW5kIGZhZGVzIGluIGl0cyBib3JkZXIuXHJcbiAqXHJcbiAqIFdoZW4gdGhlIHBvcG92ZXIgcGFuZWwgaXMgcmVtb3ZlZCBmcm9tIHRoZSBET00sIGl0IHNpbXBseSBmYWRlcyBvdXQgYWZ0ZXIgYSBicmllZlxyXG4gKiBkZWxheSB0byBkaXNwbGF5IHRoZSByaXBwbGUuXHJcbiAqL1xyXG5cclxuZXhwb3J0IGNvbnN0IHRyYW5zZm9ybVBvcG92ZXI6IEFuaW1hdGlvblRyaWdnZXJNZXRhZGF0YSA9IHRyaWdnZXIoJ3RyYW5zZm9ybVBvcG92ZXInLCBbXHJcbiAgc3RhdGUoJ2VudGVyJywgc3R5bGUoe1xyXG4gICAgb3BhY2l0eTogMSxcclxuICAgIHRyYW5zZm9ybTogYHNjYWxlKDEpYFxyXG4gIH0pKSxcclxuICB0cmFuc2l0aW9uKCd2b2lkID0+IConLCBbXHJcbiAgICBzdHlsZSh7XHJcbiAgICAgIG9wYWNpdHk6IDAsXHJcbiAgICAgIHRyYW5zZm9ybTogYHNjYWxlKDApYFxyXG4gICAgfSksXHJcbiAgICBhbmltYXRlKGAyMDBtcyBjdWJpYy1iZXppZXIoMC4yNSwgMC44LCAwLjI1LCAxKWApXHJcbiAgXSksXHJcbiAgdHJhbnNpdGlvbignKiA9PiB2b2lkJywgW1xyXG4gICAgYW5pbWF0ZSgnNTBtcyAxMDBtcyBsaW5lYXInLCBzdHlsZSh7b3BhY2l0eTogMH0pKVxyXG4gIF0pXHJcbl0pO1xyXG4iLCJpbXBvcnQge1xyXG4gIENvbXBvbmVudCxcclxuICBFdmVudEVtaXR0ZXIsXHJcbiAgSW5wdXQsXHJcbiAgT25EZXN0cm95LFxyXG4gIE91dHB1dCxcclxuICBUZW1wbGF0ZVJlZixcclxuICBWaWV3Q2hpbGQsXHJcbiAgVmlld0VuY2Fwc3VsYXRpb24sXHJcbiAgRWxlbWVudFJlZixcclxuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcclxuICBIb3N0QmluZGluZyxcclxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuXHJcbmltcG9ydCB7IEVTQ0FQRSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9rZXljb2Rlcyc7XHJcblxyXG5pbXBvcnQgeyBNZGVQb3BvdmVyUG9zaXRpb25YLCBNZGVQb3BvdmVyUG9zaXRpb25ZLCBNZGVQb3BvdmVyVHJpZ2dlckV2ZW50IH0gZnJvbSAnLi9wb3BvdmVyLXR5cGVzJztcclxuaW1wb3J0IHsgdGhyb3dNZGVQb3BvdmVySW52YWxpZFBvc2l0aW9uWCwgdGhyb3dNZGVQb3BvdmVySW52YWxpZFBvc2l0aW9uWSB9IGZyb20gJy4vcG9wb3Zlci1lcnJvcnMnO1xyXG5pbXBvcnQgeyBNZGVQb3BvdmVyUGFuZWwgfSBmcm9tICcuL3BvcG92ZXItaW50ZXJmYWNlcyc7XHJcbmltcG9ydCB7IHRyYW5zZm9ybVBvcG92ZXIgfSBmcm9tICcuL3BvcG92ZXItYW5pbWF0aW9ucyc7XHJcblxyXG5pbXBvcnQgeyBBbmltYXRpb25FdmVudCB9IGZyb20gJ0Bhbmd1bGFyL2FuaW1hdGlvbnMnO1xyXG5cclxuXHJcblxyXG5AQ29tcG9uZW50KHtcclxuICBzZWxlY3RvcjogJ21kZS1wb3BvdmVyJyxcclxuICB0ZW1wbGF0ZTogYDxuZy10ZW1wbGF0ZT5cclxuICA8ZGl2IGNsYXNzPVwibWRlLXBvcG92ZXItcGFuZWxcIiByb2xlPVwiZGlhbG9nXCIgW2NsYXNzLm1kZS1wb3BvdmVyLW92ZXJsYXBdPVwib3ZlcmxhcFRyaWdnZXJcIlxyXG4gICAgICAgW25nQ2xhc3NdPVwiX2NsYXNzTGlzdFwiIFtuZ1N0eWxlXT1cInBvcG92ZXJQYW5lbFN0eWxlc1wiIChrZXlkb3duKT1cIl9oYW5kbGVLZXlkb3duKCRldmVudClcIlxyXG4gICAgICAgKGNsaWNrKT1cIm9uQ2xpY2soKVwiIChtb3VzZW92ZXIpPVwib25Nb3VzZU92ZXIoKVwiIChtb3VzZWxlYXZlKT1cIm9uTW91c2VMZWF2ZSgpXCJcclxuICAgICAgIFtAdHJhbnNmb3JtUG9wb3Zlcl09XCInZW50ZXInXCI+XHJcbiAgICA8ZGl2IGNsYXNzPVwibWRlLXBvcG92ZXItZGlyZWN0aW9uLWFycm93XCIgW25nU3R5bGVdPVwicG9wb3ZlckFycm93U3R5bGVzXCIgKm5nSWY9XCIhb3ZlcmxhcFRyaWdnZXJcIj48L2Rpdj5cclxuICAgIDxkaXYgY2xhc3M9XCJtZGUtcG9wb3Zlci1jb250ZW50XCIgW25nU3R5bGVdPVwicG9wb3ZlckNvbnRlbnRTdHlsZXNcIiBjZGtUcmFwRm9jdXM9XCJmb2N1c1RyYXBFbmFibGVkXCI+XHJcbiAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cclxuICAgIDwvZGl2PlxyXG4gIDwvZGl2PlxyXG48L25nLXRlbXBsYXRlPlxyXG5gLFxyXG4gIHN0eWxlczogW2AubWRlLXBvcG92ZXItcGFuZWx7ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjttYXgtaGVpZ2h0OmNhbGMoMTAwdmggKyA0OHB4KX0ubWRlLXBvcG92ZXItcmlwcGxle3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2xlZnQ6MDtib3R0b206MDtyaWdodDowfS5tZGUtcG9wb3Zlci1iZWxvdyAubWRlLXBvcG92ZXItZGlyZWN0aW9uLWFycm93e3Bvc2l0aW9uOmFic29sdXRlO2JvdHRvbTowO3dpZHRoOjA7aGVpZ2h0OjA7Ym9yZGVyLWJvdHRvbS13aWR0aDowIWltcG9ydGFudDt6LWluZGV4Ojk5OTk5fS5tZGUtcG9wb3Zlci1hYm92ZSAubWRlLXBvcG92ZXItZGlyZWN0aW9uLWFycm93e3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO3dpZHRoOjA7aGVpZ2h0OjA7Ym9yZGVyLXRvcC13aWR0aDowIWltcG9ydGFudDt6LWluZGV4Ojk5OTk5fS5tZGUtcG9wb3Zlci1hZnRlciAubWRlLXBvcG92ZXItZGlyZWN0aW9uLWFycm93e2xlZnQ6MjBweH0ubWRlLXBvcG92ZXItYmVmb3JlIC5tZGUtcG9wb3Zlci1kaXJlY3Rpb24tYXJyb3d7cmlnaHQ6MjBweH1gXSxcclxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcclxuICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxyXG4gIGFuaW1hdGlvbnM6IFtcclxuICAgIHRyYW5zZm9ybVBvcG92ZXJcclxuICBdLFxyXG4gIGV4cG9ydEFzOiAnbWRlUG9wb3ZlcidcclxufSlcclxuZXhwb3J0IGNsYXNzIE1kZVBvcG92ZXIgaW1wbGVtZW50cyBNZGVQb3BvdmVyUGFuZWwsIE9uRGVzdHJveSB7IC8vIHRzbGludDpkaXNhYmxlLWxpbmU6Y29tcG9uZW50LWNsYXNzLXN1ZmZpeFxyXG5cclxuICBASG9zdEJpbmRpbmcoJ2F0dHIucm9sZScpIHJvbGUgPSAnZGlhbG9nJztcclxuXHJcbiAgLyoqIFNldHRpbmdzIGZvciBwb3BvdmVyLCB2aWV3IHNldHRlcnMgYW5kIGdldHRlcnMgZm9yIG1vcmUgZGV0YWlsICovXHJcbiAgcHJpdmF0ZSBfcG9zaXRpb25YOiBNZGVQb3BvdmVyUG9zaXRpb25YID0gJ2FmdGVyJztcclxuICBwcml2YXRlIF9wb3NpdGlvblk6IE1kZVBvcG92ZXJQb3NpdGlvblkgPSAnYmVsb3cnO1xyXG4gIHByaXZhdGUgX3RyaWdnZXJFdmVudDogTWRlUG9wb3ZlclRyaWdnZXJFdmVudCA9ICdob3Zlcic7XHJcbiAgcHJpdmF0ZSBfZW50ZXJEZWxheSA9IDIwMDtcclxuICBwcml2YXRlIF9sZWF2ZURlbGF5ID0gMjAwO1xyXG4gIHByaXZhdGUgX292ZXJsYXBUcmlnZ2VyID0gdHJ1ZTtcclxuICBwcml2YXRlIF90YXJnZXRPZmZzZXRYID0gMDtcclxuICBwcml2YXRlIF90YXJnZXRPZmZzZXRZID0gMDtcclxuICBwcml2YXRlIF9hcnJvd09mZnNldFggPSAyMDtcclxuICBwcml2YXRlIF9hcnJvd1dpZHRoID0gODtcclxuICBwcml2YXRlIF9hcnJvd0NvbG9yID0gJ3JnYmEoMCwgMCwgMCwgMC4xMiknO1xyXG4gIHByaXZhdGUgX2Nsb3NlT25DbGljayA9IHRydWU7XHJcbiAgcHJpdmF0ZSBfZm9jdXNUcmFwRW5hYmxlZCA9IHRydWU7XHJcblxyXG4gIC8qKiBDb25maWcgb2JqZWN0IHRvIGJlIHBhc3NlZCBpbnRvIHRoZSBwb3BvdmVyJ3MgbmdDbGFzcyAqL1xyXG4gIF9jbGFzc0xpc3Q6IHtba2V5OiBzdHJpbmddOiBib29sZWFufSA9IHt9O1xyXG5cclxuICAvLyBUT0RPOiBXcml0ZSBjb21tZW50IGRlc2NyaXB0aW9uXHJcbiAgLyoqICovXHJcbiAgcHVibGljIGNvbnRhaW5lclBvc2l0aW9uaW5nID0gZmFsc2U7XHJcblxyXG4gIC8qKiBDbG9zaW5nIGRpc2FibGVkIG9uIHBvcG92ZXIgKi9cclxuICBwdWJsaWMgY2xvc2VEaXNhYmxlZCA9IGZhbHNlO1xyXG5cclxuICAvKiogQ29uZmlnIG9iamVjdCB0byBiZSBwYXNzZWQgaW50byB0aGUgcG9wb3ZlcidzIGFycm93IG5nU3R5bGUgKi9cclxuICBwdWJsaWMgcG9wb3ZlclBhbmVsU3R5bGVzOiB7fTtcclxuXHJcbiAgLyoqIENvbmZpZyBvYmplY3QgdG8gYmUgcGFzc2VkIGludG8gdGhlIHBvcG92ZXIncyBhcnJvdyBuZ1N0eWxlICovXHJcbiAgcHVibGljIHBvcG92ZXJBcnJvd1N0eWxlczoge307XHJcblxyXG4gIC8qKiBDb25maWcgb2JqZWN0IHRvIGJlIHBhc3NlZCBpbnRvIHRoZSBwb3BvdmVyJ3MgY29udGVudCBuZ1N0eWxlICovXHJcbiAgcHVibGljIHBvcG92ZXJDb250ZW50U3R5bGVzOiB7fTtcclxuXHJcbiAgLyoqIEVtaXRzIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBzdGF0ZSB3aGVuZXZlciBpdCBjaGFuZ2VzLiAqL1xyXG4gIF9vbkFuaW1hdGlvblN0YXRlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxBbmltYXRpb25FdmVudD4oKTtcclxuXHJcblxyXG4gIC8qKiBQb3NpdGlvbiBvZiB0aGUgcG9wb3ZlciBpbiB0aGUgWCBheGlzLiAqL1xyXG4gIEBJbnB1dCgnbWRlUG9wb3ZlclBvc2l0aW9uWCcpXHJcbiAgZ2V0IHBvc2l0aW9uWCgpIHsgcmV0dXJuIHRoaXMuX3Bvc2l0aW9uWDsgfVxyXG4gIHNldCBwb3NpdGlvblgodmFsdWU6IE1kZVBvcG92ZXJQb3NpdGlvblgpIHtcclxuICAgIGlmICh2YWx1ZSAhPT0gJ2JlZm9yZScgJiYgdmFsdWUgIT09ICdhZnRlcicpIHtcclxuICAgICAgdGhyb3dNZGVQb3BvdmVySW52YWxpZFBvc2l0aW9uWCgpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fcG9zaXRpb25YID0gdmFsdWU7XHJcbiAgICB0aGlzLnNldFBvc2l0aW9uQ2xhc3NlcygpO1xyXG4gIH1cclxuXHJcbiAgLyoqIFBvc2l0aW9uIG9mIHRoZSBwb3BvdmVyIGluIHRoZSBZIGF4aXMuICovXHJcbiAgQElucHV0KCdtZGVQb3BvdmVyUG9zaXRpb25ZJylcclxuICBnZXQgcG9zaXRpb25ZKCkgeyByZXR1cm4gdGhpcy5fcG9zaXRpb25ZOyB9XHJcbiAgc2V0IHBvc2l0aW9uWSh2YWx1ZTogTWRlUG9wb3ZlclBvc2l0aW9uWSkge1xyXG4gICAgaWYgKHZhbHVlICE9PSAnYWJvdmUnICYmIHZhbHVlICE9PSAnYmVsb3cnKSB7XHJcbiAgICAgIHRocm93TWRlUG9wb3ZlckludmFsaWRQb3NpdGlvblkoKTtcclxuICAgIH1cclxuICAgIHRoaXMuX3Bvc2l0aW9uWSA9IHZhbHVlO1xyXG4gICAgdGhpcy5zZXRQb3NpdGlvbkNsYXNzZXMoKTtcclxuICB9XHJcblxyXG4gIC8qKiBQb3BvdmVyIHRyaWdnZXIgZXZlbnQgKi9cclxuICBASW5wdXQoJ21kZVBvcG92ZXJUcmlnZ2VyT24nKVxyXG4gIGdldCB0cmlnZ2VyRXZlbnQoKTogTWRlUG9wb3ZlclRyaWdnZXJFdmVudCB7IHJldHVybiB0aGlzLl90cmlnZ2VyRXZlbnQ7IH1cclxuICBzZXQgdHJpZ2dlckV2ZW50KHY6IE1kZVBvcG92ZXJUcmlnZ2VyRXZlbnQpIHsgdGhpcy5fdHJpZ2dlckV2ZW50ID0gdjsgfVxyXG5cclxuICAvKiogUG9wb3ZlciBlbnRlciBkZWxheSAqL1xyXG4gIEBJbnB1dCgnbWRlUG9wb3ZlckVudGVyRGVsYXknKVxyXG4gIGdldCBlbnRlckRlbGF5KCk6IG51bWJlciB7IHJldHVybiB0aGlzLl9lbnRlckRlbGF5OyB9XHJcbiAgc2V0IGVudGVyRGVsYXkodjogbnVtYmVyKSB7IHRoaXMuX2VudGVyRGVsYXkgPSB2OyB9XHJcblxyXG4gIC8qKiBQb3BvdmVyIGxlYXZlIGRlbGF5ICovXHJcbiAgQElucHV0KCdtZGVQb3BvdmVyTGVhdmVEZWxheScpXHJcbiAgZ2V0IGxlYXZlRGVsYXkoKTogbnVtYmVyIHsgcmV0dXJuIHRoaXMuX2xlYXZlRGVsYXk7IH1cclxuICBzZXQgbGVhdmVEZWxheSh2OiBudW1iZXIpIHsgdGhpcy5fbGVhdmVEZWxheSA9IHY7IH1cclxuXHJcbiAgLyoqIFBvcG92ZXIgb3ZlcmxhcCB0cmlnZ2VyICovXHJcbiAgQElucHV0KCdtZGVQb3BvdmVyT3ZlcmxhcFRyaWdnZXInKVxyXG4gIGdldCBvdmVybGFwVHJpZ2dlcigpOiBib29sZWFuIHsgcmV0dXJuIHRoaXMuX292ZXJsYXBUcmlnZ2VyOyB9XHJcbiAgc2V0IG92ZXJsYXBUcmlnZ2VyKHY6IGJvb2xlYW4pIHsgdGhpcy5fb3ZlcmxhcFRyaWdnZXIgPSB2OyB9XHJcblxyXG4gIC8qKiBQb3BvdmVyIHRhcmdldCBvZmZzZXQgeCAqL1xyXG4gIEBJbnB1dCgnbWRlUG9wb3Zlck9mZnNldFgnKVxyXG4gIGdldCB0YXJnZXRPZmZzZXRYKCk6IG51bWJlciB7IHJldHVybiB0aGlzLl90YXJnZXRPZmZzZXRYOyB9XHJcbiAgc2V0IHRhcmdldE9mZnNldFgodjogbnVtYmVyKSB7IHRoaXMuX3RhcmdldE9mZnNldFggPSB2OyB9XHJcblxyXG4gIC8qKiBQb3BvdmVyIHRhcmdldCBvZmZzZXQgeSAqL1xyXG4gIEBJbnB1dCgnbWRlUG9wb3Zlck9mZnNldFknKVxyXG4gIGdldCB0YXJnZXRPZmZzZXRZKCk6IG51bWJlciB7IHJldHVybiB0aGlzLl90YXJnZXRPZmZzZXRZOyB9XHJcbiAgc2V0IHRhcmdldE9mZnNldFkodjogbnVtYmVyKSB7IHRoaXMuX3RhcmdldE9mZnNldFkgPSB2OyB9XHJcblxyXG4gIC8qKiBQb3BvdmVyIGFycm93IG9mZnNldCB4ICovXHJcbiAgQElucHV0KCdtZGVQb3BvdmVyQXJyb3dPZmZzZXRYJylcclxuICBnZXQgYXJyb3dPZmZzZXRYKCk6IG51bWJlciB7IHJldHVybiB0aGlzLl9hcnJvd09mZnNldFg7IH1cclxuICBzZXQgYXJyb3dPZmZzZXRYKHY6IG51bWJlcikgeyB0aGlzLl9hcnJvd09mZnNldFggPSB2OyB9XHJcblxyXG4gIC8qKiBQb3BvdmVyIGFycm93IHdpZHRoICovXHJcbiAgQElucHV0KCdtZGVQb3BvdmVyQXJyb3dXaWR0aCcpXHJcbiAgZ2V0IGFycm93V2lkdGgoKTogbnVtYmVyIHsgcmV0dXJuIHRoaXMuX2Fycm93V2lkdGg7IH1cclxuICBzZXQgYXJyb3dXaWR0aCh2OiBudW1iZXIpIHsgdGhpcy5fYXJyb3dXaWR0aCA9IHY7IH1cclxuXHJcbiAgLyoqIFBvcG92ZXIgYXJyb3cgY29sb3IgKi9cclxuICBASW5wdXQoJ21kZVBvcG92ZXJBcnJvd0NvbG9yJylcclxuICBnZXQgYXJyb3dDb2xvcigpOiBzdHJpbmcgeyByZXR1cm4gdGhpcy5fYXJyb3dDb2xvcjsgfVxyXG4gIHNldCBhcnJvd0NvbG9yKHY6IHN0cmluZykgeyB0aGlzLl9hcnJvd0NvbG9yID0gdjsgfVxyXG5cclxuICAvKipcclxuICAgKiBQb3BvdmVyIGNvbnRhaW5lciBjbG9zZSBvbiBjbGlja1xyXG4gICAqIGRlZmF1bHQ6IHRydWVcclxuICAgKi9cclxuICBASW5wdXQoJ21kZVBvcG92ZXJDbG9zZU9uQ2xpY2snKVxyXG4gIGdldCBjbG9zZU9uQ2xpY2soKTogYm9vbGVhbiB7IHJldHVybiB0aGlzLl9jbG9zZU9uQ2xpY2s7IH1cclxuICBzZXQgY2xvc2VPbkNsaWNrKHY6IGJvb2xlYW4pIHsgdGhpcy5fY2xvc2VPbkNsaWNrID0gdjsgfVxyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogUG9wb3ZlciBmb2N1cyB0cmFwIHVzaW5nIGNka1RyYXBGb2N1c1xyXG4gICAqIGRlZmF1bHQ6IHRydWVcclxuICAgKi9cclxuICBASW5wdXQoJ21kZUZvY3VzVHJhcEVuYWJsZWQnKVxyXG4gIGdldCBmb2N1c1RyYXBFbmFibGVkKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5fZm9jdXNUcmFwRW5hYmxlZDsgfVxyXG4gIHNldCBmb2N1c1RyYXBFbmFibGVkKHY6IGJvb2xlYW4pIHsgdGhpcy5fZm9jdXNUcmFwRW5hYmxlZCA9IHY7IH1cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgbWV0aG9kIHRha2VzIGNsYXNzZXMgc2V0IG9uIHRoZSBob3N0IG1kLXBvcG92ZXIgZWxlbWVudCBhbmQgYXBwbGllcyB0aGVtIG9uIHRoZVxyXG4gICAqIHBvcG92ZXIgdGVtcGxhdGUgdGhhdCBkaXNwbGF5cyBpbiB0aGUgb3ZlcmxheSBjb250YWluZXIuICBPdGhlcndpc2UsIGl0J3MgZGlmZmljdWx0XHJcbiAgICogdG8gc3R5bGUgdGhlIGNvbnRhaW5pbmcgcG9wb3ZlciBmcm9tIG91dHNpZGUgdGhlIGNvbXBvbmVudC5cclxuICAgKiBAcGFyYW0gY2xhc3NlcyBsaXN0IG9mIGNsYXNzIG5hbWVzXHJcbiAgICovXHJcbiAgQElucHV0KCdjbGFzcycpXHJcbiAgc2V0IHBhbmVsQ2xhc3MoY2xhc3Nlczogc3RyaW5nKSB7XHJcbiAgICBpZiAoY2xhc3NlcyAmJiBjbGFzc2VzLmxlbmd0aCkge1xyXG4gICAgICB0aGlzLl9jbGFzc0xpc3QgPSBjbGFzc2VzLnNwbGl0KCcgJykucmVkdWNlKChvYmo6IGFueSwgY2xhc3NOYW1lOiBzdHJpbmcpID0+IHtcclxuICAgICAgICBvYmpbY2xhc3NOYW1lXSA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuIG9iajtcclxuICAgICAgfSwge30pO1xyXG5cclxuICAgICAgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmNsYXNzTmFtZSA9ICcnO1xyXG4gICAgICB0aGlzLnNldFBvc2l0aW9uQ2xhc3NlcygpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBtZXRob2QgdGFrZXMgY2xhc3NlcyBzZXQgb24gdGhlIGhvc3QgbWQtcG9wb3ZlciBlbGVtZW50IGFuZCBhcHBsaWVzIHRoZW0gb24gdGhlXHJcbiAgICogcG9wb3ZlciB0ZW1wbGF0ZSB0aGF0IGRpc3BsYXlzIGluIHRoZSBvdmVybGF5IGNvbnRhaW5lci4gIE90aGVyd2lzZSwgaXQncyBkaWZmaWN1bHRcclxuICAgKiB0byBzdHlsZSB0aGUgY29udGFpbmluZyBwb3BvdmVyIGZyb20gb3V0c2lkZSB0aGUgY29tcG9uZW50LlxyXG4gICAqIEBkZXByZWNhdGVkIFVzZSBgcGFuZWxDbGFzc2AgaW5zdGVhZC5cclxuICAgKi9cclxuICBASW5wdXQoKVxyXG4gIGdldCBjbGFzc0xpc3QoKTogc3RyaW5nIHsgcmV0dXJuIHRoaXMucGFuZWxDbGFzczsgfVxyXG4gIHNldCBjbGFzc0xpc3QoY2xhc3Nlczogc3RyaW5nKSB7IHRoaXMucGFuZWxDbGFzcyA9IGNsYXNzZXM7IH1cclxuXHJcbiAgLyoqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgcG9wb3ZlciBpcyBjbG9zZWQuICovXHJcbiAgQE91dHB1dCgpIGNsb3NlID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xyXG5cclxuICBAVmlld0NoaWxkKFRlbXBsYXRlUmVmKSB0ZW1wbGF0ZVJlZjogVGVtcGxhdGVSZWY8YW55PjtcclxuXHJcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZikge1xyXG4gICAgdGhpcy5zZXRQb3NpdGlvbkNsYXNzZXMoKTtcclxuICB9XHJcblxyXG4gIG5nT25EZXN0cm95KCkge1xyXG4gICAgdGhpcy5fZW1pdENsb3NlRXZlbnQoKTtcclxuICAgIHRoaXMuY2xvc2UuY29tcGxldGUoKTtcclxuICB9XHJcblxyXG5cclxuICAvKiogSGFuZGxlIGEga2V5Ym9hcmQgZXZlbnQgZnJvbSB0aGUgcG9wb3ZlciwgZGVsZWdhdGluZyB0byB0aGUgYXBwcm9wcmlhdGUgYWN0aW9uLiAqL1xyXG4gIF9oYW5kbGVLZXlkb3duKGV2ZW50OiBLZXlib2FyZEV2ZW50KSB7XHJcbiAgICBzd2l0Y2ggKGV2ZW50LmtleUNvZGUpIHtcclxuICAgICAgY2FzZSBFU0NBUEU6XHJcbiAgICAgICAgdGhpcy5fZW1pdENsb3NlRXZlbnQoKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGlzIGVtaXRzIGEgY2xvc2UgZXZlbnQgdG8gd2hpY2ggdGhlIHRyaWdnZXIgaXMgc3Vic2NyaWJlZC4gV2hlbiBlbWl0dGVkLCB0aGVcclxuICAgKiB0cmlnZ2VyIHdpbGwgY2xvc2UgdGhlIHBvcG92ZXIuXHJcbiAgICovXHJcbiAgX2VtaXRDbG9zZUV2ZW50KCk6IHZvaWQge1xyXG4gICAgdGhpcy5jbG9zZS5lbWl0KCk7XHJcbiAgfVxyXG5cclxuICAvKiogQ2xvc2UgcG9wb3ZlciBvbiBjbGljayBpZiBjbG9zZU9uQ2xpY2sgaXMgdHJ1ZSAqL1xyXG4gIG9uQ2xpY2soKSB7XHJcbiAgICBpZiAodGhpcy5jbG9zZU9uQ2xpY2spIHtcclxuICAgICAgdGhpcy5fZW1pdENsb3NlRXZlbnQoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRPRE86IFJlZmFjdG9yIHdoZW4gQGFuZ3VsYXIvY2RrIGluY2x1ZGVzIGZlYXR1cmUgSSBtZW50aW9uZWQgb24gZ2l0aHViIHNlZSBsaW5rIGJlbG93LlxyXG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL21hdGVyaWFsMi9wdWxsLzU0OTMjaXNzdWVjb21tZW50LTMxMzA4NTMyM1xyXG4gICAqL1xyXG4gIC8qKiBEaXNhYmxlcyBjbG9zZSBvZiBwb3BvdmVyIHdoZW4gbGVhdmluZyB0cmlnZ2VyIGVsZW1lbnQgYW5kIG1vdXNlIG92ZXIgdGhlIHBvcG92ZXIgKi9cclxuICBvbk1vdXNlT3ZlcigpIHtcclxuICAgIGlmICh0aGlzLnRyaWdnZXJFdmVudCA9PT0gJ2hvdmVyJykge1xyXG4gICAgICB0aGlzLmNsb3NlRGlzYWJsZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxuICAvKiogRW5hYmxlcyBjbG9zZSBvZiBwb3BvdmVyIHdoZW4gbW91c2UgbGVhdmluZyBwb3BvdmVyIGVsZW1lbnQgKi9cclxuICBvbk1vdXNlTGVhdmUoKSB7XHJcbiAgICBpZiAodGhpcy50cmlnZ2VyRXZlbnQgPT09ICdob3ZlcicpIHtcclxuICAgICAgdGhpcy5jbG9zZURpc2FibGVkID0gZmFsc2U7XHJcbiAgICAgIHRoaXMuX2VtaXRDbG9zZUV2ZW50KCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBUT0RPOiBSZWZhY3RvciBob3cgc3R5bGVzIGFyZSBzZXQgYW5kIHVwZGF0ZWQgb24gdGhlIGNvbXBvbmVudCwgdXNlIGJlc3QgcHJhY3RpY2VzLlxyXG4gIC8vIFRPRE86IElmIGFycm93IGxlZnQgYW5kIHJpZ2h0IHBvc2l0aW9uaW5nIGlzIHJlcXVlc3RlZCwgc2VlIGlmIGZsZXggZGlyZWN0aW9uIGNhbiBiZSB1c2VkIHRvIHdvcmsgd2l0aCBvcmRlci5cclxuICAvKiogU2V0cyB0aGUgY3VycmVudCBzdHlsZXMgZm9yIHRoZSBwb3BvdmVyIHRvIGFsbG93IGZvciBkeW5hbWljYWxseSBjaGFuZ2luZyBzZXR0aW5ncyAqL1xyXG4gIHNldEN1cnJlbnRTdHlsZXMoKSB7XHJcblxyXG4gICAgLy8gVE9ETzogU2VlIGlmIGFycm93IHBvc2l0aW9uIGNhbiBiZSBjYWxjdWxhdGVkIGF1dG9tYXRpY2FsbHkgYW5kIGFsbG93IG92ZXJyaWRlLlxyXG4gICAgLy8gVE9ETzogU2VlIGlmIGZsZXggb3JkZXIgaXMgYSBiZXR0ZXIgYWx0ZXJuYXRpdmUgdG8gcG9zaXRpb24gYXJyb3cgdG9wIG9yIGJvdHRvbS5cclxuICAgIHRoaXMucG9wb3ZlckFycm93U3R5bGVzID0ge1xyXG4gICAgICAncmlnaHQnOiB0aGlzLnBvc2l0aW9uWCA9PT0gJ2JlZm9yZScgPyAodGhpcy5hcnJvd09mZnNldFggLSB0aGlzLmFycm93V2lkdGgpICsgJ3B4JyA6ICcnLFxyXG4gICAgICAnbGVmdCc6IHRoaXMucG9zaXRpb25YID09PSAnYWZ0ZXInID8gKHRoaXMuYXJyb3dPZmZzZXRYIC0gdGhpcy5hcnJvd1dpZHRoKSArICdweCcgOiAnJyxcclxuICAgICAgJ2JvcmRlci10b3AnOiB0aGlzLnBvc2l0aW9uWSA9PT0gJ2JlbG93JyA/XHJcbiAgICAgICAgdGhpcy5hcnJvd1dpZHRoICsgJ3B4IHNvbGlkICcgKyB0aGlzLmFycm93Q29sb3IgOiAnMHB4IHNvbGlkIHRyYW5zcGFyZW50JyxcclxuICAgICAgJ2JvcmRlci1yaWdodCc6ICd1bmRlZmluZWQnID09PSB1bmRlZmluZWQgP1xyXG4gICAgICAgIHRoaXMuYXJyb3dXaWR0aCArICdweCBzb2xpZCAnICsgdGhpcy5hcnJvd0NvbG9yIDpcclxuICAgICAgICB0aGlzLmFycm93V2lkdGggKyAncHggc29saWQgdHJhbnNwYXJlbnQnLFxyXG4gICAgICAnYm9yZGVyLWJvdHRvbSc6IHRoaXMucG9zaXRpb25ZID09PSAnYWJvdmUnID9cclxuICAgICAgICB0aGlzLmFycm93V2lkdGggKyAncHggc29saWQgJyArIHRoaXMuYXJyb3dDb2xvciA6XHJcbiAgICAgICAgdGhpcy5hcnJvd1dpZHRoICsgJ3B4IHNvbGlkIHRyYW5zcGFyZW50JyxcclxuICAgICAgJ2JvcmRlci1sZWZ0JzogJ3VuZGVmaW5lZCcgPT09IHVuZGVmaW5lZCA/XHJcbiAgICAgICAgdGhpcy5hcnJvd1dpZHRoICsgJ3B4IHNvbGlkICcgKyB0aGlzLmFycm93Q29sb3IgOlxyXG4gICAgICAgIHRoaXMuYXJyb3dXaWR0aCArICdweCBzb2xpZCB0cmFuc3BhcmVudCcsXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFRPRE86IFJlbW92ZSBpZiBmbGV4IG9yZGVyIGlzIGFkZGVkLlxyXG4gICAgdGhpcy5wb3BvdmVyQ29udGVudFN0eWxlcyA9IHtcclxuICAgICAgJ3BhZGRpbmctdG9wJzogdGhpcy5vdmVybGFwVHJpZ2dlciA9PT0gdHJ1ZSA/ICcwcHgnIDogdGhpcy5hcnJvd1dpZHRoICsgJ3B4JyxcclxuICAgICAgJ3BhZGRpbmctYm90dG9tJzogdGhpcy5vdmVybGFwVHJpZ2dlciA9PT0gdHJ1ZSA/ICcwcHgnIDogKHRoaXMuYXJyb3dXaWR0aCkgKyAncHgnLFxyXG4gICAgICAnbWFyZ2luLXRvcCc6IHRoaXMub3ZlcmxhcFRyaWdnZXIgPT09IGZhbHNlICYmIHRoaXMucG9zaXRpb25ZID09PSAnYmVsb3cnICYmIHRoaXMuY29udGFpbmVyUG9zaXRpb25pbmcgPT09IGZhbHNlID9cclxuICAgICAgICAtKHRoaXMuYXJyb3dXaWR0aCAqIDIpICsgJ3B4JyA6ICcwcHgnXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSXQncyBuZWNlc3NhcnkgdG8gc2V0IHBvc2l0aW9uLWJhc2VkIGNsYXNzZXMgdG8gZW5zdXJlIHRoZSBwb3BvdmVyIHBhbmVsIGFuaW1hdGlvblxyXG4gICAqIGZvbGRzIG91dCBmcm9tIHRoZSBjb3JyZWN0IGRpcmVjdGlvbi5cclxuICAgKi9cclxuICBzZXRQb3NpdGlvbkNsYXNzZXMocG9zWCA9IHRoaXMucG9zaXRpb25YLCBwb3NZID0gdGhpcy5wb3NpdGlvblkpOiB2b2lkIHtcclxuICAgIHRoaXMuX2NsYXNzTGlzdFsnbWRlLXBvcG92ZXItYmVmb3JlJ10gPSBwb3NYID09PSAnYmVmb3JlJztcclxuICAgIHRoaXMuX2NsYXNzTGlzdFsnbWRlLXBvcG92ZXItYWZ0ZXInXSA9IHBvc1ggPT09ICdhZnRlcic7XHJcbiAgICB0aGlzLl9jbGFzc0xpc3RbJ21kZS1wb3BvdmVyLWFib3ZlJ10gPSBwb3NZID09PSAnYWJvdmUnO1xyXG4gICAgdGhpcy5fY2xhc3NMaXN0WydtZGUtcG9wb3Zlci1iZWxvdyddID0gcG9zWSA9PT0gJ2JlbG93JztcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IHtcclxuICBBZnRlclZpZXdJbml0LFxyXG4gIERpcmVjdGl2ZSxcclxuICBFbGVtZW50UmVmLFxyXG4gIEV2ZW50RW1pdHRlcixcclxuICBJbnB1dCxcclxuICBPbkRlc3Ryb3ksXHJcbiAgT3B0aW9uYWwsXHJcbiAgT3V0cHV0LFxyXG4gIFZpZXdDb250YWluZXJSZWYsXHJcbiAgSG9zdExpc3RlbmVyLFxyXG4gIEhvc3RCaW5kaW5nLFxyXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuXHJcbmltcG9ydCB7IGlzRmFrZU1vdXNlZG93bkZyb21TY3JlZW5SZWFkZXIgfSBmcm9tICdAYW5ndWxhci9jZGsvYTExeSc7XHJcbmltcG9ydCB7IERpcmVjdGlvbiwgRGlyZWN0aW9uYWxpdHkgfSBmcm9tICdAYW5ndWxhci9jZGsvYmlkaSc7XHJcbmltcG9ydCB7XHJcbiAgQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneSxcclxuICBPdmVybGF5LFxyXG4gIE92ZXJsYXlSZWYsXHJcbiAgT3ZlcmxheUNvbmZpZyxcclxuICBIb3Jpem9udGFsQ29ubmVjdGlvblBvcyxcclxuICBWZXJ0aWNhbENvbm5lY3Rpb25Qb3MsXHJcbiAgRmxleGlibGVDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5XHJcbn0gZnJvbSAnQGFuZ3VsYXIvY2RrL292ZXJsYXknO1xyXG5pbXBvcnQgeyBUZW1wbGF0ZVBvcnRhbCB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9wb3J0YWwnO1xyXG5cclxuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XHJcblxyXG5pbXBvcnQgeyBmaXJzdCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuXHJcbmltcG9ydCB7IE1kZVBvcG92ZXJQYW5lbCwgTWRlVGFyZ2V0IH0gZnJvbSAnLi9wb3BvdmVyLWludGVyZmFjZXMnO1xyXG5pbXBvcnQgeyBNZGVQb3BvdmVyUG9zaXRpb25YLCBNZGVQb3BvdmVyUG9zaXRpb25ZLCBNZGVQb3BvdmVyVHJpZ2dlckV2ZW50IH0gZnJvbSAnLi9wb3BvdmVyLXR5cGVzJztcclxuaW1wb3J0IHsgdGhyb3dNZGVQb3BvdmVyTWlzc2luZ0Vycm9yIH0gZnJvbSAnLi9wb3BvdmVyLWVycm9ycyc7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGlzIGRpcmVjdGl2ZSBpcyBpbnRlbmRlZCB0byBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggYW4gbWRlLXBvcG92ZXIgdGFnLiBJdCBpc1xyXG4gKiByZXNwb25zaWJsZSBmb3IgdG9nZ2xpbmcgdGhlIGRpc3BsYXkgb2YgdGhlIHByb3ZpZGVkIHBvcG92ZXIgaW5zdGFuY2UuXHJcbiAqL1xyXG5cclxuQERpcmVjdGl2ZSh7XHJcbiAgc2VsZWN0b3I6ICdbbWRlUG9wb3ZlclRyaWdnZXJGb3JdJyxcclxuICBleHBvcnRBczogJ21kZVBvcG92ZXJUcmlnZ2VyJ1xyXG59KVxyXG5leHBvcnQgY2xhc3MgTWRlUG9wb3ZlclRyaWdnZXIgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0LCBPbkRlc3Ryb3kgeyAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOmRpcmVjdGl2ZS1jbGFzcy1zdWZmaXhcclxuXHJcbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIuYXJpYS1oYXNwb3B1cCcpIGFyaWFIYXNwb3B1cCA9IHRydWU7XHJcblxyXG4gICAgcHJpdmF0ZSBfcG9ydGFsOiBUZW1wbGF0ZVBvcnRhbDxhbnk+O1xyXG4gICAgcHJpdmF0ZSBfb3ZlcmxheVJlZjogT3ZlcmxheVJlZiB8IG51bGwgPSBudWxsO1xyXG4gICAgcHJpdmF0ZSBfcG9wb3Zlck9wZW4gPSBmYWxzZTtcclxuICAgIHByaXZhdGUgX2hhbHQgPSBmYWxzZTtcclxuICAgIHByaXZhdGUgX2JhY2tkcm9wU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XHJcbiAgICBwcml2YXRlIF9wb3NpdGlvblN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xyXG5cclxuICAgIHByaXZhdGUgX21vdXNlb3ZlclRpbWVyOiBhbnk7XHJcblxyXG4gICAgLy8gdHJhY2tpbmcgaW5wdXQgdHlwZSBpcyBuZWNlc3Nhcnkgc28gaXQncyBwb3NzaWJsZSB0byBvbmx5IGF1dG8tZm9jdXNcclxuICAgIC8vIHRoZSBmaXJzdCBpdGVtIG9mIHRoZSBsaXN0IHdoZW4gdGhlIHBvcG92ZXIgaXMgb3BlbmVkIHZpYSB0aGUga2V5Ym9hcmRcclxuICAgIHByaXZhdGUgX29wZW5lZEJ5TW91c2UgPSBmYWxzZTtcclxuXHJcbiAgICAvKiogUmVmZXJlbmNlcyB0aGUgcG9wb3ZlciBpbnN0YW5jZSB0aGF0IHRoZSB0cmlnZ2VyIGlzIGFzc29jaWF0ZWQgd2l0aC4gKi9cclxuICAgIEBJbnB1dCgnbWRlUG9wb3ZlclRyaWdnZXJGb3InKSBwb3BvdmVyOiBNZGVQb3BvdmVyUGFuZWw7XHJcblxyXG4gICAgLyoqIFJlZmVyZW5jZXMgdGhlIHBvcG92ZXIgdGFyZ2V0IGluc3RhbmNlIHRoYXQgdGhlIHRyaWdnZXIgaXMgYXNzb2NpYXRlZCB3aXRoLiAqL1xyXG4gICAgQElucHV0KCdtZGVQb3BvdmVyVGFyZ2V0QXQnKSB0YXJnZXRFbGVtZW50OiBNZGVUYXJnZXQ7XHJcblxyXG4gICAgLyoqIFBvc2l0aW9uIG9mIHRoZSBwb3BvdmVyIGluIHRoZSBYIGF4aXMgKi9cclxuICAgIEBJbnB1dCgnbWRlUG9wb3ZlclBvc2l0aW9uWCcpIHBvc2l0aW9uWDogTWRlUG9wb3ZlclBvc2l0aW9uWDtcclxuXHJcbiAgICAvKiogUG9zaXRpb24gb2YgdGhlIHBvcG92ZXIgaW4gdGhlIFkgYXhpcyAqL1xyXG4gICAgQElucHV0KCdtZGVQb3BvdmVyUG9zaXRpb25ZJykgcG9zaXRpb25ZOiBNZGVQb3BvdmVyUG9zaXRpb25ZO1xyXG5cclxuICAgIC8qKiBQb3BvdmVyIHRyaWdnZXIgZXZlbnQgKi9cclxuICAgIEBJbnB1dCgnbWRlUG9wb3ZlclRyaWdnZXJPbicpIHRyaWdnZXJFdmVudDogTWRlUG9wb3ZlclRyaWdnZXJFdmVudDtcclxuXHJcbiAgICAvKiogUG9wb3ZlciBkZWxheSAqL1xyXG4gICAgQElucHV0KCdtZGVQb3BvdmVyRW50ZXJEZWxheScpIGVudGVyRGVsYXk6IG51bWJlcjtcclxuXHJcbiAgICAvKiogUG9wb3ZlciBkZWxheSAqL1xyXG4gICAgQElucHV0KCdtZGVQb3BvdmVyTGVhdmVEZWxheScpIGxlYXZlRGVsYXk6IG51bWJlcjtcclxuXHJcbiAgICAvKiogUG9wb3ZlciBvdmVybGFwIHRyaWdnZXIgKi9cclxuICAgIEBJbnB1dCgnbWRlUG9wb3Zlck92ZXJsYXBUcmlnZ2VyJykgb3ZlcmxhcFRyaWdnZXI6IGJvb2xlYW47XHJcblxyXG4gICAgLyoqIFBvcG92ZXIgdGFyZ2V0IG9mZnNldCB4ICovXHJcbiAgICBASW5wdXQoJ21kZVBvcG92ZXJPZmZzZXRYJykgdGFyZ2V0T2Zmc2V0WDogbnVtYmVyO1xyXG5cclxuICAgIC8qKiBQb3BvdmVyIHRhcmdldCBvZmZzZXQgeSAqL1xyXG4gICAgQElucHV0KCdtZGVQb3BvdmVyT2Zmc2V0WScpIHRhcmdldE9mZnNldFk6IG51bWJlcjtcclxuXHJcbiAgICAvKiogUG9wb3ZlciBhcnJvdyBvZmZzZXQgeCAqL1xyXG4gICAgQElucHV0KCdtZGVQb3BvdmVyQXJyb3dPZmZzZXRYJykgYXJyb3dPZmZzZXRYOiBudW1iZXI7XHJcblxyXG5cclxuICAgIC8qKiBQb3BvdmVyIGFycm93IHdpZHRoICovXHJcbiAgICBASW5wdXQoJ21kZVBvcG92ZXJBcnJvd1dpZHRoJykgYXJyb3dXaWR0aDogbnVtYmVyO1xyXG5cclxuXHJcbiAgICAvKiogUG9wb3ZlciBhcnJvdyBjb2xvciAqL1xyXG4gICAgQElucHV0KCdtZGVQb3BvdmVyQXJyb3dDb2xvcicpIGFycm93Q29sb3I6IHN0cmluZztcclxuXHJcblxyXG4gICAgLyoqIFBvcG92ZXIgY29udGFpbmVyIGNsb3NlIG9uIGNsaWNrICovXHJcbiAgICBASW5wdXQoJ21kZVBvcG92ZXJDbG9zZU9uQ2xpY2snKSBjbG9zZU9uQ2xpY2s6IGJvb2xlYW47XHJcblxyXG5cclxuICAgIC8qKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIGFzc29jaWF0ZWQgcG9wb3ZlciBpcyBvcGVuZWQuICovXHJcbiAgICBAT3V0cHV0KCkgb3BlbmVkID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xyXG5cclxuICAgIC8qKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIGFzc29jaWF0ZWQgcG9wb3ZlciBpcyBjbG9zZWQuICovXHJcbiAgICBAT3V0cHV0KCkgY2xvc2VkID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xyXG5cclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9vdmVybGF5OiBPdmVybGF5LCBwdWJsaWMgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYsXHJcbiAgICAgICAgICAgICAgcHJpdmF0ZSBfdmlld0NvbnRhaW5lclJlZjogVmlld0NvbnRhaW5lclJlZixcclxuICAgICAgICAgICAgICBAT3B0aW9uYWwoKSBwcml2YXRlIF9kaXI6IERpcmVjdGlvbmFsaXR5KSB7IH1cclxuXHJcbiAgICBuZ0FmdGVyVmlld0luaXQoKSB7XHJcbiAgICAgICAgdGhpcy5fY2hlY2tQb3BvdmVyKCk7XHJcbiAgICAgICAgdGhpcy5fc2V0Q3VycmVudENvbmZpZygpO1xyXG4gICAgICAgIHRoaXMucG9wb3Zlci5jbG9zZS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5jbG9zZVBvcG92ZXIoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgbmdPbkRlc3Ryb3koKSB7IHRoaXMuZGVzdHJveVBvcG92ZXIoKTsgfVxyXG5cclxuXHJcbiAgICBwcml2YXRlIF9zZXRDdXJyZW50Q29uZmlnKCkge1xyXG5cclxuICAgICAgICBpZiAodGhpcy5wb3NpdGlvblggPT09ICdiZWZvcmUnIHx8IHRoaXMucG9zaXRpb25YID09PSAnYWZ0ZXInKSB7XHJcbiAgICAgICAgICB0aGlzLnBvcG92ZXIucG9zaXRpb25YID0gdGhpcy5wb3NpdGlvblg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5wb3NpdGlvblkgPT09ICdhYm92ZScgfHwgdGhpcy5wb3NpdGlvblkgPT09ICdiZWxvdycpIHtcclxuICAgICAgICAgIHRoaXMucG9wb3Zlci5wb3NpdGlvblkgPSB0aGlzLnBvc2l0aW9uWTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnRyaWdnZXJFdmVudCkge1xyXG4gICAgICAgICAgICB0aGlzLnBvcG92ZXIudHJpZ2dlckV2ZW50ID0gdGhpcy50cmlnZ2VyRXZlbnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5lbnRlckRlbGF5KSB7XHJcbiAgICAgICAgICB0aGlzLnBvcG92ZXIuZW50ZXJEZWxheSA9IHRoaXMuZW50ZXJEZWxheTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmxlYXZlRGVsYXkpIHtcclxuICAgICAgICAgIHRoaXMucG9wb3Zlci5sZWF2ZURlbGF5ID0gdGhpcy5sZWF2ZURlbGF5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMub3ZlcmxhcFRyaWdnZXIgPT09IHRydWUgfHwgdGhpcy5vdmVybGFwVHJpZ2dlciA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgdGhpcy5wb3BvdmVyLm92ZXJsYXBUcmlnZ2VyID0gdGhpcy5vdmVybGFwVHJpZ2dlcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnRhcmdldE9mZnNldFgpIHtcclxuICAgICAgICAgICAgdGhpcy5wb3BvdmVyLnRhcmdldE9mZnNldFggPSB0aGlzLnRhcmdldE9mZnNldFg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy50YXJnZXRPZmZzZXRZKSB7XHJcbiAgICAgICAgICAgIHRoaXMucG9wb3Zlci50YXJnZXRPZmZzZXRZID0gdGhpcy50YXJnZXRPZmZzZXRZO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuYXJyb3dPZmZzZXRYKSB7XHJcbiAgICAgICAgICAgIHRoaXMucG9wb3Zlci5hcnJvd09mZnNldFggPSB0aGlzLmFycm93T2Zmc2V0WDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmFycm93V2lkdGgpIHtcclxuICAgICAgICAgICAgdGhpcy5wb3BvdmVyLmFycm93V2lkdGggPSB0aGlzLmFycm93V2lkdGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5hcnJvd0NvbG9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMucG9wb3Zlci5hcnJvd0NvbG9yID0gdGhpcy5hcnJvd0NvbG9yO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VPbkNsaWNrID09PSB0cnVlIHx8IHRoaXMuY2xvc2VPbkNsaWNrID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICB0aGlzLnBvcG92ZXIuY2xvc2VPbkNsaWNrID0gdGhpcy5jbG9zZU9uQ2xpY2s7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnBvcG92ZXIuc2V0Q3VycmVudFN0eWxlcygpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKiogV2hldGhlciB0aGUgcG9wb3ZlciBpcyBvcGVuLiAqL1xyXG4gICAgZ2V0IHBvcG92ZXJPcGVuKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5fcG9wb3Zlck9wZW47IH1cclxuXHJcbiAgICBASG9zdExpc3RlbmVyKCdjbGljaycpIG9uQ2xpY2soKSB7XHJcbiAgICAgIGlmICh0aGlzLnBvcG92ZXIudHJpZ2dlckV2ZW50ID09PSAnY2xpY2snKSB7XHJcbiAgICAgICAgICAvLyB0aGlzLnBvcG92ZXIuc2V0Q3VycmVudFN0eWxlcygpO1xyXG4gICAgICAgICAgLy8gdGhpcy5fc2V0Q3VycmVudENvbmZpZygpO1xyXG4gICAgICAgICAgdGhpcy50b2dnbGVQb3BvdmVyKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBASG9zdExpc3RlbmVyKCdtb3VzZWVudGVyJykgb25Nb3VzZUVudGVyKCkge1xyXG4gICAgICB0aGlzLl9oYWx0ID0gZmFsc2U7XHJcbiAgICAgIGlmICh0aGlzLnBvcG92ZXIudHJpZ2dlckV2ZW50ID09PSAnaG92ZXInKSB7XHJcbiAgICAgICAgICB0aGlzLl9tb3VzZW92ZXJUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgIHRoaXMub3BlblBvcG92ZXIoKTtcclxuICAgICAgICAgIH0sIHRoaXMucG9wb3Zlci5lbnRlckRlbGF5KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIEBIb3N0TGlzdGVuZXIoJ21vdXNlbGVhdmUnKSBvbk1vdXNlTGVhdmUoKSB7XHJcbiAgICAgIGlmICh0aGlzLnBvcG92ZXIudHJpZ2dlckV2ZW50ID09PSAnaG92ZXInKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX21vdXNlb3ZlclRpbWVyKSB7XHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9tb3VzZW92ZXJUaW1lcik7XHJcbiAgICAgICAgICAgIHRoaXMuX21vdXNlb3ZlclRpbWVyID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX3BvcG92ZXJPcGVuKSB7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnBvcG92ZXIuY2xvc2VEaXNhYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VQb3BvdmVyKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIHRoaXMucG9wb3Zlci5sZWF2ZURlbGF5KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy5faGFsdCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFRvZ2dsZXMgdGhlIHBvcG92ZXIgYmV0d2VlbiB0aGUgb3BlbiBhbmQgY2xvc2VkIHN0YXRlcy4gKi9cclxuICAgIHRvZ2dsZVBvcG92ZXIoKTogdm9pZCB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvcG92ZXJPcGVuID8gdGhpcy5jbG9zZVBvcG92ZXIoKSA6IHRoaXMub3BlblBvcG92ZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogT3BlbnMgdGhlIHBvcG92ZXIuICovXHJcbiAgICBvcGVuUG9wb3ZlcigpOiB2b2lkIHtcclxuICAgICAgICBpZiAoIXRoaXMuX3BvcG92ZXJPcGVuICYmICF0aGlzLl9oYWx0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZU92ZXJsYXkoKS5hdHRhY2godGhpcy5fcG9ydGFsKTtcclxuXHJcbiAgICAgICAgICAgIC8qKiBPbmx5IHN1YnNjcmliZSB0byBiYWNrZHJvcCBpZiB0cmlnZ2VyIGV2ZW50IGlzIGNsaWNrICovXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnRyaWdnZXJFdmVudCA9PT0gJ2NsaWNrJykge1xyXG4gICAgICAgICAgICAgIHRoaXMuX3N1YnNjcmliZVRvQmFja2Ryb3AoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5faW5pdFBvcG92ZXIoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIENsb3NlcyB0aGUgcG9wb3Zlci4gKi9cclxuICAgIGNsb3NlUG9wb3ZlcigpOiB2b2lkIHtcclxuICAgICAgICBpZiAodGhpcy5fb3ZlcmxheVJlZikge1xyXG4gICAgICAgICAgdGhpcy5fb3ZlcmxheVJlZi5kZXRhY2goKTtcclxuXHJcbiAgICAgICAgICAvKiogT25seSB1bnN1YnNjcmliZSB0byBiYWNrZHJvcCBpZiB0cmlnZ2VyIGV2ZW50IGlzIGNsaWNrICovXHJcbiAgICAgICAgICBpZiAodGhpcy50cmlnZ2VyRXZlbnQgPT09ICdjbGljaycpIHtcclxuICAgICAgICAgICAgdGhpcy5fYmFja2Ryb3BTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB0aGlzLl9yZXNldFBvcG92ZXIoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFJlbW92ZXMgdGhlIHBvcG92ZXIgZnJvbSB0aGUgRE9NLiAqL1xyXG4gICAgZGVzdHJveVBvcG92ZXIoKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKHRoaXMuX292ZXJsYXlSZWYpIHtcclxuICAgICAgICAgIHRoaXMuX292ZXJsYXlSZWYuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgdGhpcy5fb3ZlcmxheVJlZiA9IG51bGw7XHJcbiAgICAgICAgICB0aGlzLl9jbGVhblVwU3Vic2NyaXB0aW9ucygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKiogRm9jdXNlcyB0aGUgcG9wb3ZlciB0cmlnZ2VyLiAqL1xyXG4gICAgZm9jdXMoKSB7XHJcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFRoZSB0ZXh0IGRpcmVjdGlvbiBvZiB0aGUgY29udGFpbmluZyBhcHAuICovXHJcbiAgICBnZXQgZGlyKCk6IERpcmVjdGlvbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpciAmJiB0aGlzLl9kaXIudmFsdWUgPT09ICdydGwnID8gJ3J0bCcgOiAnbHRyJztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogVGhpcyBtZXRob2QgZW5zdXJlcyB0aGF0IHRoZSBwb3BvdmVyIGNsb3NlcyB3aGVuIHRoZSBvdmVybGF5IGJhY2tkcm9wIGlzIGNsaWNrZWQuXHJcbiAgICAqIFdlIGRvIG5vdCB1c2UgZmlyc3QoKSBoZXJlIGJlY2F1c2UgZG9pbmcgc28gd291bGQgbm90IGNhdGNoIGNsaWNrcyBmcm9tIHdpdGhpblxyXG4gICAgKiB0aGUgcG9wb3ZlciwgYW5kIGl0IHdvdWxkIGZhaWwgdG8gdW5zdWJzY3JpYmUgcHJvcGVybHkuIEluc3RlYWQsIHdlIHVuc3Vic2NyaWJlXHJcbiAgICAqIGV4cGxpY2l0bHkgd2hlbiB0aGUgcG9wb3ZlciBpcyBjbG9zZWQgb3IgZGVzdHJveWVkLlxyXG4gICAgKi9cclxuICAgIHByaXZhdGUgX3N1YnNjcmliZVRvQmFja2Ryb3AoKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKHRoaXMuX292ZXJsYXlSZWYpIHtcclxuICAgICAgICAgIHRoaXMuX2JhY2tkcm9wU3Vic2NyaXB0aW9uID0gdGhpcy5fb3ZlcmxheVJlZi5iYWNrZHJvcENsaWNrKCkuc3Vic2NyaWJlKCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5wb3BvdmVyLl9lbWl0Q2xvc2VFdmVudCgpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBUaGlzIG1ldGhvZCBzZXRzIHRoZSBwb3BvdmVyIHN0YXRlIHRvIG9wZW4gYW5kIGZvY3VzZXMgdGhlIGZpcnN0IGl0ZW0gaWZcclxuICAgICogdGhlIHBvcG92ZXIgd2FzIG9wZW5lZCB2aWEgdGhlIGtleWJvYXJkLlxyXG4gICAgKi9cclxuICAgIHByaXZhdGUgX2luaXRQb3BvdmVyKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX3NldElzUG9wb3Zlck9wZW4odHJ1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFRoaXMgbWV0aG9kIHJlc2V0cyB0aGUgcG9wb3ZlciB3aGVuIGl0J3MgY2xvc2VkLCBtb3N0IGltcG9ydGFudGx5IHJlc3RvcmluZ1xyXG4gICAgKiBmb2N1cyB0byB0aGUgcG9wb3ZlciB0cmlnZ2VyIGlmIHRoZSBwb3BvdmVyIHdhcyBvcGVuZWQgdmlhIHRoZSBrZXlib2FyZC5cclxuICAgICovXHJcbiAgICBwcml2YXRlIF9yZXNldFBvcG92ZXIoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fc2V0SXNQb3BvdmVyT3BlbihmYWxzZSk7XHJcblxyXG4gICAgICAgIC8vIEZvY3VzIG9ubHkgbmVlZHMgdG8gYmUgcmVzZXQgdG8gdGhlIGhvc3QgZWxlbWVudCBpZiB0aGUgcG9wb3ZlciB3YXMgb3BlbmVkXHJcbiAgICAgICAgLy8gYnkgdGhlIGtleWJvYXJkIGFuZCBtYW51YWxseSBzaGlmdGVkIHRvIHRoZSBmaXJzdCBwb3BvdmVyIGl0ZW0uXHJcbiAgICAgICAgaWYgKCF0aGlzLl9vcGVuZWRCeU1vdXNlKSB7XHJcbiAgICAgICAgICB0aGlzLmZvY3VzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX29wZW5lZEJ5TW91c2UgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogc2V0IHN0YXRlIHJhdGhlciB0aGFuIHRvZ2dsZSB0byBzdXBwb3J0IHRyaWdnZXJzIHNoYXJpbmcgYSBwb3BvdmVyICovXHJcbiAgICBwcml2YXRlIF9zZXRJc1BvcG92ZXJPcGVuKGlzT3BlbjogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX3BvcG92ZXJPcGVuID0gaXNPcGVuO1xyXG4gICAgICAgIHRoaXMuX3BvcG92ZXJPcGVuID8gdGhpcy5vcGVuZWQuZW1pdCgpIDogdGhpcy5jbG9zZWQuZW1pdCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiAgVGhpcyBtZXRob2QgY2hlY2tzIHRoYXQgYSB2YWxpZCBpbnN0YW5jZSBvZiBNZFBvcG92ZXIgaGFzIGJlZW4gcGFzc2VkIGludG9cclxuICAgICogIG1kUG9wb3ZlclRyaWdnZXJGb3IuIElmIG5vdCwgYW4gZXhjZXB0aW9uIGlzIHRocm93bi5cclxuICAgICovXHJcbiAgICBwcml2YXRlIF9jaGVja1BvcG92ZXIoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnBvcG92ZXIpIHtcclxuICAgICAgICAgIHRocm93TWRlUG9wb3Zlck1pc3NpbmdFcnJvcigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogIFRoaXMgbWV0aG9kIGNyZWF0ZXMgdGhlIG92ZXJsYXkgZnJvbSB0aGUgcHJvdmlkZWQgcG9wb3ZlcidzIHRlbXBsYXRlIGFuZCBzYXZlcyBpdHNcclxuICAgICogIE92ZXJsYXlSZWYgc28gdGhhdCBpdCBjYW4gYmUgYXR0YWNoZWQgdG8gdGhlIERPTSB3aGVuIG9wZW5Qb3BvdmVyIGlzIGNhbGxlZC5cclxuICAgICovXHJcbiAgICBwcml2YXRlIF9jcmVhdGVPdmVybGF5KCk6IE92ZXJsYXlSZWYge1xyXG4gICAgICAgIGlmICghdGhpcy5fb3ZlcmxheVJlZikge1xyXG4gICAgICAgICAgdGhpcy5fcG9ydGFsID0gbmV3IFRlbXBsYXRlUG9ydGFsKHRoaXMucG9wb3Zlci50ZW1wbGF0ZVJlZiwgdGhpcy5fdmlld0NvbnRhaW5lclJlZik7XHJcbiAgICAgICAgICBjb25zdCBjb25maWcgPSB0aGlzLl9nZXRPdmVybGF5Q29uZmlnKCk7XHJcbiAgICAgICAgICB0aGlzLl9zdWJzY3JpYmVUb1Bvc2l0aW9ucyhjb25maWcucG9zaXRpb25TdHJhdGVneSBhcyBGbGV4aWJsZUNvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kpO1xyXG4gICAgICAgICAgdGhpcy5fb3ZlcmxheVJlZiA9IHRoaXMuX292ZXJsYXkuY3JlYXRlKGNvbmZpZyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5fb3ZlcmxheVJlZjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogVGhpcyBtZXRob2QgYnVpbGRzIHRoZSBjb25maWd1cmF0aW9uIG9iamVjdCBuZWVkZWQgdG8gY3JlYXRlIHRoZSBvdmVybGF5LCB0aGUgT3ZlcmxheUNvbmZpZy5cclxuICAgICogQHJldHVybnMgT3ZlcmxheUNvbmZpZ1xyXG4gICAgKi9cclxuICAgIHByaXZhdGUgX2dldE92ZXJsYXlDb25maWcoKTogT3ZlcmxheUNvbmZpZyB7XHJcbiAgICAgICAgY29uc3Qgb3ZlcmxheVN0YXRlID0gbmV3IE92ZXJsYXlDb25maWcoKTtcclxuICAgICAgICBvdmVybGF5U3RhdGUucG9zaXRpb25TdHJhdGVneSA9IHRoaXMuX2dldFBvc2l0aW9uKCk7XHJcblxyXG4gICAgICAgIC8qKiBEaXNwbGF5IG92ZXJsYXkgYmFja2Ryb3AgaWYgdHJpZ2dlciBldmVudCBpcyBjbGljayAqL1xyXG4gICAgICAgIGlmICh0aGlzLnRyaWdnZXJFdmVudCA9PT0gJ2NsaWNrJykge1xyXG4gICAgICAgICAgb3ZlcmxheVN0YXRlLmhhc0JhY2tkcm9wID0gdHJ1ZTtcclxuICAgICAgICAgIG92ZXJsYXlTdGF0ZS5iYWNrZHJvcENsYXNzID0gJ2Nkay1vdmVybGF5LXRyYW5zcGFyZW50LWJhY2tkcm9wJztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG92ZXJsYXlTdGF0ZS5kaXJlY3Rpb24gPSB0aGlzLmRpcjtcclxuICAgICAgICBvdmVybGF5U3RhdGUuc2Nyb2xsU3RyYXRlZ3kgPSB0aGlzLl9vdmVybGF5LnNjcm9sbFN0cmF0ZWdpZXMucmVwb3NpdGlvbigpO1xyXG4gICAgICAgIHJldHVybiBvdmVybGF5U3RhdGU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIExpc3RlbnMgdG8gY2hhbmdlcyBpbiB0aGUgcG9zaXRpb24gb2YgdGhlIG92ZXJsYXkgYW5kIHNldHMgdGhlIGNvcnJlY3QgY2xhc3Nlc1xyXG4gICAgKiBvbiB0aGUgcG9wb3ZlciBiYXNlZCBvbiB0aGUgbmV3IHBvc2l0aW9uLiBUaGlzIGVuc3VyZXMgdGhlIGFuaW1hdGlvbiBvcmlnaW4gaXMgYWx3YXlzXHJcbiAgICAqIGNvcnJlY3QsIGV2ZW4gaWYgYSBmYWxsYmFjayBwb3NpdGlvbiBpcyB1c2VkIGZvciB0aGUgb3ZlcmxheS5cclxuICAgICovXHJcbiAgICBwcml2YXRlIF9zdWJzY3JpYmVUb1Bvc2l0aW9ucyhwb3NpdGlvbjogRmxleGlibGVDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5KTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fcG9zaXRpb25TdWJzY3JpcHRpb24gPSBwb3NpdGlvbi5wb3NpdGlvbkNoYW5nZXMuc3Vic2NyaWJlKGNoYW5nZSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBvc2lzaW9uWDogTWRlUG9wb3ZlclBvc2l0aW9uWCA9IGNoYW5nZS5jb25uZWN0aW9uUGFpci5vdmVybGF5WCA9PT0gJ3N0YXJ0JyA/ICdhZnRlcicgOiAnYmVmb3JlJztcclxuICAgICAgICAgICAgbGV0IHBvc2lzaW9uWTogTWRlUG9wb3ZlclBvc2l0aW9uWSA9IGNoYW5nZS5jb25uZWN0aW9uUGFpci5vdmVybGF5WSA9PT0gJ3RvcCcgPyAnYmVsb3cnIDogJ2Fib3ZlJztcclxuXHJcbiAgICAgICAgICAgIGlmICghdGhpcy5wb3BvdmVyLm92ZXJsYXBUcmlnZ2VyKSB7XHJcbiAgICAgICAgICAgICAgICBwb3Npc2lvblkgPSBwb3Npc2lvblkgPT09ICdiZWxvdycgPyAnYWJvdmUnIDogJ2JlbG93JztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5wb3BvdmVyLnBvc2l0aW9uWCA9IHBvc2lzaW9uWDtcclxuICAgICAgICAgICAgdGhpcy5wb3BvdmVyLnBvc2l0aW9uWSA9IHBvc2lzaW9uWTtcclxuICAgICAgICAgICAgdGhpcy5wb3BvdmVyLnNldEN1cnJlbnRTdHlsZXMoKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMucG9wb3Zlci5zZXRQb3NpdGlvbkNsYXNzZXMocG9zaXNpb25YLCBwb3Npc2lvblkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBUaGlzIG1ldGhvZCBidWlsZHMgdGhlIHBvc2l0aW9uIHN0cmF0ZWd5IGZvciB0aGUgb3ZlcmxheSwgc28gdGhlIHBvcG92ZXIgaXMgcHJvcGVybHkgY29ubmVjdGVkXHJcbiAgICAqIHRvIHRoZSB0cmlnZ2VyLlxyXG4gICAgKiBAcmV0dXJucyBDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5XHJcbiAgICAqL1xyXG4gICAgcHJpdmF0ZSBfZ2V0UG9zaXRpb24oKTogRmxleGlibGVDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5IHtcclxuICAgICAgICBjb25zdCBbb3JpZ2luWCwgb3JpZ2luRmFsbGJhY2tYXTogSG9yaXpvbnRhbENvbm5lY3Rpb25Qb3NbXSA9XHJcbiAgICAgICAgICB0aGlzLnBvcG92ZXIucG9zaXRpb25YID09PSAnYmVmb3JlJyA/IFsnZW5kJywgJ3N0YXJ0J10gOiBbJ3N0YXJ0JywgJ2VuZCddO1xyXG5cclxuICAgICAgICBjb25zdCBbb3ZlcmxheVksIG92ZXJsYXlGYWxsYmFja1ldOiBWZXJ0aWNhbENvbm5lY3Rpb25Qb3NbXSA9XHJcbiAgICAgICAgICB0aGlzLnBvcG92ZXIucG9zaXRpb25ZID09PSAnYWJvdmUnID8gWydib3R0b20nLCAndG9wJ10gOiBbJ3RvcCcsICdib3R0b20nXTtcclxuXHJcbiAgICAgICAgLy8gbGV0IG9yaWdpblkgPSBvdmVybGF5WTtcclxuICAgICAgICAvLyBsZXQgZmFsbGJhY2tPcmlnaW5ZID0gb3ZlcmxheUZhbGxiYWNrWTtcclxuXHJcbiAgICAgICAgbGV0IG9yaWdpblkgPSBvdmVybGF5WTtcclxuICAgICAgICBsZXQgb3JpZ2luRmFsbGJhY2tZID0gb3ZlcmxheUZhbGxiYWNrWTtcclxuXHJcbiAgICAgICAgY29uc3Qgb3ZlcmxheVggPSBvcmlnaW5YO1xyXG4gICAgICAgIGNvbnN0IG92ZXJsYXlGYWxsYmFja1ggPSBvcmlnaW5GYWxsYmFja1g7XHJcblxyXG4gICAgICAgIC8vIGxldCBbb3JpZ2luWSwgb3JpZ2luRmFsbGJhY2tZXSA9IFtvdmVybGF5WSwgb3ZlcmxheUZhbGxiYWNrWV07XHJcbiAgICAgICAgLy8gbGV0IFtvdmVybGF5WCwgb3ZlcmxheUZhbGxiYWNrWF0gPSBbb3JpZ2luWCwgb3JpZ2luRmFsbGJhY2tYXTtcclxuXHJcbiAgICAgICAgLyoqIFJldmVyc2Ugb3ZlcmxheVkgYW5kIGZhbGxiYWNrT3ZlcmxheVkgd2hlbiBvdmVybGFwVHJpZ2dlciBpcyBmYWxzZSAqL1xyXG4gICAgICAgIGlmICghdGhpcy5wb3BvdmVyLm92ZXJsYXBUcmlnZ2VyKSB7XHJcbiAgICAgICAgICBvcmlnaW5ZID0gb3ZlcmxheVkgPT09ICd0b3AnID8gJ2JvdHRvbScgOiAndG9wJztcclxuICAgICAgICAgIG9yaWdpbkZhbGxiYWNrWSA9IG92ZXJsYXlGYWxsYmFja1kgPT09ICd0b3AnID8gJ2JvdHRvbScgOiAndG9wJztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBvZmZzZXRYID0gMDtcclxuICAgICAgICBsZXQgb2Zmc2V0WSA9IDA7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnBvcG92ZXIudGFyZ2V0T2Zmc2V0WCAmJiAhaXNOYU4oTnVtYmVyKHRoaXMucG9wb3Zlci50YXJnZXRPZmZzZXRYKSkpIHtcclxuICAgICAgICAgIG9mZnNldFggPSBOdW1iZXIodGhpcy5wb3BvdmVyLnRhcmdldE9mZnNldFgpO1xyXG4gICAgICAgICAgLy8gb2Zmc2V0WCA9IC0xNjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnBvcG92ZXIudGFyZ2V0T2Zmc2V0WSAmJiAhaXNOYU4oTnVtYmVyKHRoaXMucG9wb3Zlci50YXJnZXRPZmZzZXRZKSkpIHtcclxuICAgICAgICAgIG9mZnNldFkgPSBOdW1iZXIodGhpcy5wb3BvdmVyLnRhcmdldE9mZnNldFkpO1xyXG4gICAgICAgICAgLy8gb2Zmc2V0WSA9IC0xMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZvciBvdmVycmlkaW5nIHBvc2l0aW9uIGVsZW1lbnQsIHdoZW4gbWRlUG9wb3ZlclRhcmdldEF0IGhhcyBhIHZhbGlkIGVsZW1lbnQgcmVmZXJlbmNlLlxyXG4gICAgICAgICAqIFVzZWZ1bCBmb3Igc3RpY2tpbmcgcG9wb3ZlciB0byBwYXJlbnQgZWxlbWVudCBhbmQgb2Zmc2V0dGluZyBhcnJvdyB0byB0cmlnZ2VyIGVsZW1lbnQuXHJcbiAgICAgICAgICogSWYgdW5kZWZpbmVkIGRlZmF1bHRzIHRvIHRoZSB0cmlnZ2VyIGVsZW1lbnQgcmVmZXJlbmNlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGxldCBlbGVtZW50ID0gdGhpcy5fZWxlbWVudFJlZjtcclxuICAgICAgICBpZiAodHlwZW9mIHRoaXMudGFyZ2V0RWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgdGhpcy5wb3BvdmVyLmNvbnRhaW5lclBvc2l0aW9uaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgZWxlbWVudCA9IHRoaXMudGFyZ2V0RWxlbWVudC5fZWxlbWVudFJlZjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLl9vdmVybGF5LnBvc2l0aW9uKClcclxuICAgICAgICAuZmxleGlibGVDb25uZWN0ZWRUbyhlbGVtZW50KVxyXG4gICAgICAgIC53aXRoUG9zaXRpb25zKFtcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgICBvcmlnaW5YLFxyXG4gICAgICAgICAgICAgIG9yaWdpblksXHJcbiAgICAgICAgICAgICAgb3ZlcmxheVgsXHJcbiAgICAgICAgICAgICAgb3ZlcmxheVksXHJcbiAgICAgICAgICAgICAgb2Zmc2V0WVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgICBvcmlnaW5YOiBvcmlnaW5GYWxsYmFja1gsXHJcbiAgICAgICAgICAgICAgb3JpZ2luWSxcclxuICAgICAgICAgICAgICBvdmVybGF5WDogb3ZlcmxheUZhbGxiYWNrWCxcclxuICAgICAgICAgICAgICBvdmVybGF5WSxcclxuICAgICAgICAgICAgICBvZmZzZXRZXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBvcmlnaW5YLFxyXG4gICAgICAgICAgICBvcmlnaW5ZOiBvcmlnaW5GYWxsYmFja1ksXHJcbiAgICAgICAgICAgIG92ZXJsYXlYLFxyXG4gICAgICAgICAgICBvdmVybGF5WTogb3ZlcmxheUZhbGxiYWNrWSxcclxuICAgICAgICAgICAgb2Zmc2V0WTogLW9mZnNldFlcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG9yaWdpblg6IG9yaWdpbkZhbGxiYWNrWCxcclxuICAgICAgICAgICAgb3JpZ2luWTogb3JpZ2luRmFsbGJhY2tZLFxyXG4gICAgICAgICAgICBvdmVybGF5WDogb3ZlcmxheUZhbGxiYWNrWCxcclxuICAgICAgICAgICAgb3ZlcmxheVk6IG92ZXJsYXlGYWxsYmFja1ksXHJcbiAgICAgICAgICAgIG9mZnNldFk6IC1vZmZzZXRZXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgXSlcclxuICAgICAgICAud2l0aERlZmF1bHRPZmZzZXRYKG9mZnNldFgpXHJcbiAgICAgICAgLndpdGhEZWZhdWx0T2Zmc2V0WShvZmZzZXRZKTtcclxuICAgICAgICAvKlxyXG4gICAgICAgIHJldHVybiB0aGlzLl9vdmVybGF5LnBvc2l0aW9uKClcclxuICAgICAgICAgIC5jb25uZWN0ZWRUbyhlbGVtZW50LFxyXG4gICAgICAgICAgICAgIHtvcmlnaW5YOiBwb3NYLCBvcmlnaW5ZOiBvcmlnaW5ZfSxcclxuICAgICAgICAgICAgICB7b3ZlcmxheVg6IHBvc1gsIG92ZXJsYXlZOiBvdmVybGF5WX0pXHJcbiAgICAgICAgICAud2l0aEZhbGxiYWNrUG9zaXRpb24oXHJcbiAgICAgICAgICAgICAge29yaWdpblg6IGZhbGxiYWNrWCwgb3JpZ2luWTogb3JpZ2luWX0sXHJcbiAgICAgICAgICAgICAge292ZXJsYXlYOiBmYWxsYmFja1gsIG92ZXJsYXlZOiBvdmVybGF5WX0pXHJcbiAgICAgICAgICAud2l0aEZhbGxiYWNrUG9zaXRpb24oXHJcbiAgICAgICAgICAgICAge29yaWdpblg6IHBvc1gsIG9yaWdpblk6IGZhbGxiYWNrT3JpZ2luWX0sXHJcbiAgICAgICAgICAgICAge292ZXJsYXlYOiBwb3NYLCBvdmVybGF5WTogZmFsbGJhY2tPdmVybGF5WX0pXHJcbiAgICAgICAgICAud2l0aEZhbGxiYWNrUG9zaXRpb24oXHJcbiAgICAgICAgICAgICAge29yaWdpblg6IGZhbGxiYWNrWCwgb3JpZ2luWTogZmFsbGJhY2tPcmlnaW5ZfSxcclxuICAgICAgICAgICAgICB7b3ZlcmxheVg6IGZhbGxiYWNrWCwgb3ZlcmxheVk6IGZhbGxiYWNrT3ZlcmxheVl9KVxyXG4gICAgICAgICAgLndpdGhPZmZzZXRYKG9mZnNldFgpXHJcbiAgICAgICAgICAud2l0aE9mZnNldFkob2Zmc2V0WSk7XHJcbiAgICAgICAgICAqL1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX2NsZWFuVXBTdWJzY3JpcHRpb25zKCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLl9iYWNrZHJvcFN1YnNjcmlwdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLl9iYWNrZHJvcFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fcG9zaXRpb25TdWJzY3JpcHRpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5fcG9zaXRpb25TdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgQEhvc3RMaXN0ZW5lcignbW91c2Vkb3duJykgX2hhbmRsZU1vdXNlZG93bihldmVudDogTW91c2VFdmVudCk6IHZvaWQge1xyXG4gICAgICAgIGlmIChldmVudCAmJiAhaXNGYWtlTW91c2Vkb3duRnJvbVNjcmVlblJlYWRlcihldmVudCkpIHtcclxuICAgICAgICAgICAgdGhpcy5fb3BlbmVkQnlNb3VzZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuXHJcbkBEaXJlY3RpdmUoe1xyXG4gIHNlbGVjdG9yOiAnbWRlLXBvcG92ZXItdGFyZ2V0LCBbbWRlUG9wb3ZlclRhcmdldF0nLFxyXG4gIGV4cG9ydEFzOiAnbWRlUG9wb3ZlclRhcmdldCdcclxufSlcclxuZXhwb3J0IGNsYXNzIE1kZVBvcG92ZXJUYXJnZXQgeyAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOmRpcmVjdGl2ZS1jbGFzcy1zdWZmaXhcclxuXHJcbiAgY29uc3RydWN0b3IocHVibGljIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmKSB7IH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcclxuXHJcbmltcG9ydCB7IE92ZXJsYXlNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jZGsvb3ZlcmxheSc7XHJcblxyXG5pbXBvcnQgeyBNZGVQb3BvdmVyIH0gZnJvbSAnLi9wb3BvdmVyJztcclxuaW1wb3J0IHsgTWRlUG9wb3ZlclRyaWdnZXIgfSBmcm9tICcuL3BvcG92ZXItdHJpZ2dlcic7XHJcbmltcG9ydCB7IE1kZVBvcG92ZXJUYXJnZXQgfSBmcm9tICcuL3BvcG92ZXItdGFyZ2V0JztcclxuXHJcbkBOZ01vZHVsZSh7XHJcbiAgaW1wb3J0czogW1xyXG4gICAgT3ZlcmxheU1vZHVsZSxcclxuICAgIENvbW1vbk1vZHVsZVxyXG4gIF0sXHJcbiAgZXhwb3J0czogW01kZVBvcG92ZXIsIE1kZVBvcG92ZXJUcmlnZ2VyLCBNZGVQb3BvdmVyVGFyZ2V0XSxcclxuICBkZWNsYXJhdGlvbnM6IFtNZGVQb3BvdmVyLCBNZGVQb3BvdmVyVHJpZ2dlciwgTWRlUG9wb3ZlclRhcmdldF0sXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBNZGVQb3BvdmVyTW9kdWxlIHt9XHJcbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUdBO0lBQ0UsTUFBTSxLQUFLLENBQUM7Ozs7eURBSTJDLENBQUMsQ0FBQztDQUMxRDs7Ozs7O0FBTUQ7SUFDRSxNQUFNLEtBQUssQ0FBQzs4RkFDZ0YsQ0FBQyxDQUFDO0NBQy9GOzs7Ozs7QUFNRDtJQUNFLE1BQU0sS0FBSyxDQUFDOzZGQUMrRSxDQUFDLENBQUM7Q0FDOUY7Ozs7OztBQzNCRDs7Ozs7Ozs7QUF1QkEsdUJBQWEsZ0JBQWdCLEdBQTZCLE9BQU8sQ0FBQyxrQkFBa0IsRUFBRTtJQUNwRixLQUFLLENBQUMsT0FBTyxFQUFFLEtBQUssQ0FBQztRQUNuQixPQUFPLEVBQUUsQ0FBQztRQUNWLFNBQVMsRUFBRSxVQUFVO0tBQ3RCLENBQUMsQ0FBQztJQUNILFVBQVUsQ0FBQyxXQUFXLEVBQUU7UUFDdEIsS0FBSyxDQUFDO1lBQ0osT0FBTyxFQUFFLENBQUM7WUFDVixTQUFTLEVBQUUsVUFBVTtTQUN0QixDQUFDO1FBQ0YsT0FBTyxDQUFDLHdDQUF3QyxDQUFDO0tBQ2xELENBQUM7SUFDRixVQUFVLENBQUMsV0FBVyxFQUFFO1FBQ3RCLE9BQU8sQ0FBQyxtQkFBbUIsRUFBRSxLQUFLLENBQUMsRUFBQyxPQUFPLEVBQUUsQ0FBQyxFQUFDLENBQUMsQ0FBQztLQUNsRCxDQUFDO0NBQ0gsQ0FBQzs7Ozs7O0FDdENGOzs7O0lBZ05FLFlBQW9CLFdBQXVCO1FBQXZCLGdCQUFXLEdBQVgsV0FBVyxDQUFZOztvQkEvSlYsUUFBUTs7OzswQkFHQyxPQUFPOzBCQUNQLE9BQU87NkJBQ0QsT0FBTzsyQkFDakMsR0FBRzsyQkFDSCxHQUFHOytCQUNDLElBQUk7OEJBQ0wsQ0FBQzs4QkFDRCxDQUFDOzZCQUNGLEVBQUU7MkJBQ0osQ0FBQzsyQkFDRCxxQkFBcUI7NkJBQ25CLElBQUk7aUNBQ0EsSUFBSTs7OzswQkFHTyxFQUFFOzs7O29DQUlYLEtBQUs7Ozs7NkJBR1osS0FBSzs7Ozt1Q0FZRixJQUFJLFlBQVksRUFBa0I7Ozs7cUJBc0gxQyxJQUFJLFlBQVksRUFBUTtRQUt4QyxJQUFJLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztLQUMzQjs7Ozs7UUF2SEcsU0FBUyxLQUFLLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQzs7Ozs7SUFDekMsSUFBSSxTQUFTLENBQUMsS0FBMEI7UUFDdEMsSUFBSSxLQUFLLEtBQUssUUFBUSxJQUFJLEtBQUssS0FBSyxPQUFPLEVBQUU7WUFDM0MsK0JBQStCLEVBQUUsQ0FBQztTQUNuQztRQUNELElBQUksQ0FBQyxVQUFVLEdBQUcsS0FBSyxDQUFDO1FBQ3hCLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO0tBQzNCOzs7OztRQUlHLFNBQVMsS0FBSyxPQUFPLElBQUksQ0FBQyxVQUFVLENBQUM7Ozs7O0lBQ3pDLElBQUksU0FBUyxDQUFDLEtBQTBCO1FBQ3RDLElBQUksS0FBSyxLQUFLLE9BQU8sSUFBSSxLQUFLLEtBQUssT0FBTyxFQUFFO1lBQzFDLCtCQUErQixFQUFFLENBQUM7U0FDbkM7UUFDRCxJQUFJLENBQUMsVUFBVSxHQUFHLEtBQUssQ0FBQztRQUN4QixJQUFJLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztLQUMzQjs7Ozs7UUFJRyxZQUFZLEtBQTZCLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQzs7Ozs7SUFDdkUsSUFBSSxZQUFZLENBQUMsQ0FBeUIsSUFBSSxJQUFJLENBQUMsYUFBYSxHQUFHLENBQUMsQ0FBQyxFQUFFOzs7OztRQUluRSxVQUFVLEtBQWEsT0FBTyxJQUFJLENBQUMsV0FBVyxDQUFDOzs7OztJQUNuRCxJQUFJLFVBQVUsQ0FBQyxDQUFTLElBQUksSUFBSSxDQUFDLFdBQVcsR0FBRyxDQUFDLENBQUMsRUFBRTs7Ozs7UUFJL0MsVUFBVSxLQUFhLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQzs7Ozs7SUFDbkQsSUFBSSxVQUFVLENBQUMsQ0FBUyxJQUFJLElBQUksQ0FBQyxXQUFXLEdBQUcsQ0FBQyxDQUFDLEVBQUU7Ozs7O1FBSS9DLGNBQWMsS0FBYyxPQUFPLElBQUksQ0FBQyxlQUFlLENBQUM7Ozs7O0lBQzVELElBQUksY0FBYyxDQUFDLENBQVUsSUFBSSxJQUFJLENBQUMsZUFBZSxHQUFHLENBQUMsQ0FBQyxFQUFFOzs7OztRQUl4RCxhQUFhLEtBQWEsT0FBTyxJQUFJLENBQUMsY0FBYyxDQUFDOzs7OztJQUN6RCxJQUFJLGFBQWEsQ0FBQyxDQUFTLElBQUksSUFBSSxDQUFDLGNBQWMsR0FBRyxDQUFDLENBQUMsRUFBRTs7Ozs7UUFJckQsYUFBYSxLQUFhLE9BQU8sSUFBSSxDQUFDLGNBQWMsQ0FBQzs7Ozs7SUFDekQsSUFBSSxhQUFhLENBQUMsQ0FBUyxJQUFJLElBQUksQ0FBQyxjQUFjLEdBQUcsQ0FBQyxDQUFDLEVBQUU7Ozs7O1FBSXJELFlBQVksS0FBYSxPQUFPLElBQUksQ0FBQyxhQUFhLENBQUM7Ozs7O0lBQ3ZELElBQUksWUFBWSxDQUFDLENBQVMsSUFBSSxJQUFJLENBQUMsYUFBYSxHQUFHLENBQUMsQ0FBQyxFQUFFOzs7OztRQUluRCxVQUFVLEtBQWEsT0FBTyxJQUFJLENBQUMsV0FBVyxDQUFDOzs7OztJQUNuRCxJQUFJLFVBQVUsQ0FBQyxDQUFTLElBQUksSUFBSSxDQUFDLFdBQVcsR0FBRyxDQUFDLENBQUMsRUFBRTs7Ozs7UUFJL0MsVUFBVSxLQUFhLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQzs7Ozs7SUFDbkQsSUFBSSxVQUFVLENBQUMsQ0FBUyxJQUFJLElBQUksQ0FBQyxXQUFXLEdBQUcsQ0FBQyxDQUFDLEVBQUU7Ozs7OztRQU8vQyxZQUFZLEtBQWMsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDOzs7OztJQUN4RCxJQUFJLFlBQVksQ0FBQyxDQUFVLElBQUksSUFBSSxDQUFDLGFBQWEsR0FBRyxDQUFDLENBQUMsRUFBRTs7Ozs7O1FBUXBELGdCQUFnQixLQUFjLE9BQU8sSUFBSSxDQUFDLGlCQUFpQixDQUFDOzs7OztJQUNoRSxJQUFJLGdCQUFnQixDQUFDLENBQVUsSUFBSSxJQUFJLENBQUMsaUJBQWlCLEdBQUcsQ0FBQyxDQUFDLEVBQUU7Ozs7Ozs7O1FBVTVELFVBQVUsQ0FBQyxPQUFlO1FBQzVCLElBQUksT0FBTyxJQUFJLE9BQU8sQ0FBQyxNQUFNLEVBQUU7WUFDN0IsSUFBSSxDQUFDLFVBQVUsR0FBRyxPQUFPLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQVEsRUFBRSxTQUFpQjtnQkFDdEUsR0FBRyxDQUFDLFNBQVMsQ0FBQyxHQUFHLElBQUksQ0FBQztnQkFDdEIsT0FBTyxHQUFHLENBQUM7YUFDWixFQUFFLEVBQUUsQ0FBQyxDQUFDO1lBRVAsSUFBSSxDQUFDLFdBQVcsQ0FBQyxhQUFhLENBQUMsU0FBUyxHQUFHLEVBQUUsQ0FBQztZQUM5QyxJQUFJLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztTQUMzQjs7Ozs7Ozs7O1FBVUMsU0FBUyxLQUFhLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQzs7Ozs7SUFDakQsSUFBSSxTQUFTLENBQUMsT0FBZSxJQUFJLElBQUksQ0FBQyxVQUFVLEdBQUcsT0FBTyxDQUFDLEVBQUU7Ozs7SUFXN0QsV0FBVztRQUNULElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztRQUN2QixJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFDO0tBQ3ZCOzs7Ozs7SUFJRCxjQUFjLENBQUMsS0FBb0I7UUFDakMsUUFBUSxLQUFLLENBQUMsT0FBTztZQUNuQixLQUFLLE1BQU07Z0JBQ1QsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO2dCQUN2QixPQUFPO1NBQ1Y7S0FDRjs7Ozs7O0lBTUQsZUFBZTtRQUNiLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLENBQUM7S0FDbkI7Ozs7O0lBR0QsT0FBTztRQUNMLElBQUksSUFBSSxDQUFDLFlBQVksRUFBRTtZQUNyQixJQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7U0FDeEI7S0FDRjs7Ozs7SUFPRCxXQUFXO1FBQ1QsSUFBSSxJQUFJLENBQUMsWUFBWSxLQUFLLE9BQU8sRUFBRTtZQUNqQyxJQUFJLENBQUMsYUFBYSxHQUFHLElBQUksQ0FBQztTQUMzQjtLQUNGOzs7OztJQUVELFlBQVk7UUFDVixJQUFJLElBQUksQ0FBQyxZQUFZLEtBQUssT0FBTyxFQUFFO1lBQ2pDLElBQUksQ0FBQyxhQUFhLEdBQUcsS0FBSyxDQUFDO1lBQzNCLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztTQUN4QjtLQUNGOzs7OztJQUtELGdCQUFnQjs7O1FBSWQsSUFBSSxDQUFDLGtCQUFrQixHQUFHO1lBQ3hCLE9BQU8sRUFBRSxJQUFJLENBQUMsU0FBUyxLQUFLLFFBQVEsR0FBRyxDQUFDLElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDLFVBQVUsSUFBSSxJQUFJLEdBQUcsRUFBRTtZQUN4RixNQUFNLEVBQUUsSUFBSSxDQUFDLFNBQVMsS0FBSyxPQUFPLEdBQUcsQ0FBQyxJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQyxVQUFVLElBQUksSUFBSSxHQUFHLEVBQUU7WUFDdEYsWUFBWSxFQUFFLElBQUksQ0FBQyxTQUFTLEtBQUssT0FBTztnQkFDdEMsSUFBSSxDQUFDLFVBQVUsR0FBRyxXQUFXLEdBQUcsSUFBSSxDQUFDLFVBQVUsR0FBRyx1QkFBdUI7WUFDM0UsY0FBYyxFQUFFLFdBQVcsS0FBSyxTQUFTO2dCQUN2QyxJQUFJLENBQUMsVUFBVSxHQUFHLFdBQVcsR0FBRyxJQUFJLENBQUMsVUFBVTtnQkFDL0MsSUFBSSxDQUFDLFVBQVUsR0FBRyxzQkFBc0I7WUFDMUMsZUFBZSxFQUFFLElBQUksQ0FBQyxTQUFTLEtBQUssT0FBTztnQkFDekMsSUFBSSxDQUFDLFVBQVUsR0FBRyxXQUFXLEdBQUcsSUFBSSxDQUFDLFVBQVU7Z0JBQy9DLElBQUksQ0FBQyxVQUFVLEdBQUcsc0JBQXNCO1lBQzFDLGFBQWEsRUFBRSxXQUFXLEtBQUssU0FBUztnQkFDdEMsSUFBSSxDQUFDLFVBQVUsR0FBRyxXQUFXLEdBQUcsSUFBSSxDQUFDLFVBQVU7Z0JBQy9DLElBQUksQ0FBQyxVQUFVLEdBQUcsc0JBQXNCO1NBQzNDLENBQUM7O1FBR0YsSUFBSSxDQUFDLG9CQUFvQixHQUFHO1lBQzFCLGFBQWEsRUFBRSxJQUFJLENBQUMsY0FBYyxLQUFLLElBQUksR0FBRyxLQUFLLEdBQUcsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJO1lBQzVFLGdCQUFnQixFQUFFLElBQUksQ0FBQyxjQUFjLEtBQUssSUFBSSxHQUFHLEtBQUssR0FBRyxDQUFDLElBQUksQ0FBQyxVQUFVLElBQUksSUFBSTtZQUNqRixZQUFZLEVBQUUsSUFBSSxDQUFDLGNBQWMsS0FBSyxLQUFLLElBQUksSUFBSSxDQUFDLFNBQVMsS0FBSyxPQUFPLElBQUksSUFBSSxDQUFDLG9CQUFvQixLQUFLLEtBQUs7Z0JBQzlHLEVBQUUsSUFBSSxDQUFDLFVBQVUsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLEdBQUcsS0FBSztTQUN4QyxDQUFDO0tBQ0g7Ozs7Ozs7O0lBTUQsa0JBQWtCLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxTQUFTLEVBQUUsSUFBSSxHQUFHLElBQUksQ0FBQyxTQUFTO1FBQzdELElBQUksQ0FBQyxVQUFVLENBQUMsb0JBQW9CLENBQUMsR0FBRyxJQUFJLEtBQUssUUFBUSxDQUFDO1FBQzFELElBQUksQ0FBQyxVQUFVLENBQUMsbUJBQW1CLENBQUMsR0FBRyxJQUFJLEtBQUssT0FBTyxDQUFDO1FBQ3hELElBQUksQ0FBQyxVQUFVLENBQUMsbUJBQW1CLENBQUMsR0FBRyxJQUFJLEtBQUssT0FBTyxDQUFDO1FBQ3hELElBQUksQ0FBQyxVQUFVLENBQUMsbUJBQW1CLENBQUMsR0FBRyxJQUFJLEtBQUssT0FBTyxDQUFDO0tBQ3pEOzs7WUFwUkYsU0FBUyxTQUFDO2dCQUNULFFBQVEsRUFBRSxhQUFhO2dCQUN2QixRQUFRLEVBQUU7Ozs7Ozs7Ozs7O0NBV1g7Z0JBQ0MsTUFBTSxFQUFFLENBQUMsOGhCQUE4aEIsQ0FBQztnQkFDeGlCLGVBQWUsRUFBRSx1QkFBdUIsQ0FBQyxNQUFNO2dCQUMvQyxhQUFhLEVBQUUsaUJBQWlCLENBQUMsSUFBSTtnQkFDckMsVUFBVSxFQUFFO29CQUNWLGdCQUFnQjtpQkFDakI7Z0JBQ0QsUUFBUSxFQUFFLFlBQVk7YUFDdkI7Ozs7WUFyQ0MsVUFBVTs7O3FCQXdDVCxXQUFXLFNBQUMsV0FBVzswQkF5Q3ZCLEtBQUssU0FBQyxxQkFBcUI7MEJBVzNCLEtBQUssU0FBQyxxQkFBcUI7NkJBVzNCLEtBQUssU0FBQyxxQkFBcUI7MkJBSzNCLEtBQUssU0FBQyxzQkFBc0I7MkJBSzVCLEtBQUssU0FBQyxzQkFBc0I7K0JBSzVCLEtBQUssU0FBQywwQkFBMEI7OEJBS2hDLEtBQUssU0FBQyxtQkFBbUI7OEJBS3pCLEtBQUssU0FBQyxtQkFBbUI7NkJBS3pCLEtBQUssU0FBQyx3QkFBd0I7MkJBSzlCLEtBQUssU0FBQyxzQkFBc0I7MkJBSzVCLEtBQUssU0FBQyxzQkFBc0I7NkJBUTVCLEtBQUssU0FBQyx3QkFBd0I7aUNBUzlCLEtBQUssU0FBQyxxQkFBcUI7MkJBVzNCLEtBQUssU0FBQyxPQUFPOzBCQW1CYixLQUFLO3NCQUtMLE1BQU07NEJBRU4sU0FBUyxTQUFDLFdBQVc7Ozs7Ozs7QUM5TXhCOzs7O0FBK0NBOzs7Ozs7O0lBc0VJLFlBQW9CLFFBQWlCLEVBQVMsV0FBdUIsRUFDbkQsbUJBQ1k7UUFGVixhQUFRLEdBQVIsUUFBUSxDQUFTO1FBQVMsZ0JBQVcsR0FBWCxXQUFXLENBQVk7UUFDbkQsc0JBQWlCLEdBQWpCLGlCQUFpQjtRQUNMLFNBQUksR0FBSixJQUFJOzs0QkF0RWdCLElBQUk7MkJBR2IsSUFBSTs0QkFDdEIsS0FBSztxQkFDWixLQUFLOzhCQVFJLEtBQUs7Ozs7c0JBaURYLElBQUksWUFBWSxFQUFROzs7O3NCQUd4QixJQUFJLFlBQVksRUFBUTtLQUtZOzs7O0lBRXZELGVBQWU7UUFDWCxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUM7UUFDckIsSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUM7UUFDekIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLE1BQU0sSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDLENBQUM7S0FDM0Q7Ozs7SUFFRCxXQUFXLEtBQUssSUFBSSxDQUFDLGNBQWMsRUFBRSxDQUFDLEVBQUU7Ozs7SUFHaEMsaUJBQWlCO1FBRXJCLElBQUksSUFBSSxDQUFDLFNBQVMsS0FBSyxRQUFRLElBQUksSUFBSSxDQUFDLFNBQVMsS0FBSyxPQUFPLEVBQUU7WUFDN0QsSUFBSSxDQUFDLE9BQU8sQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQztTQUN6QztRQUVELElBQUksSUFBSSxDQUFDLFNBQVMsS0FBSyxPQUFPLElBQUksSUFBSSxDQUFDLFNBQVMsS0FBSyxPQUFPLEVBQUU7WUFDNUQsSUFBSSxDQUFDLE9BQU8sQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQztTQUN6QztRQUVELElBQUksSUFBSSxDQUFDLFlBQVksRUFBRTtZQUNuQixJQUFJLENBQUMsT0FBTyxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDO1NBQ2pEO1FBRUQsSUFBSSxJQUFJLENBQUMsVUFBVSxFQUFFO1lBQ25CLElBQUksQ0FBQyxPQUFPLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUM7U0FDM0M7UUFFRCxJQUFJLElBQUksQ0FBQyxVQUFVLEVBQUU7WUFDbkIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQztTQUMzQztRQUVELElBQUksSUFBSSxDQUFDLGNBQWMsS0FBSyxJQUFJLElBQUksSUFBSSxDQUFDLGNBQWMsS0FBSyxLQUFLLEVBQUU7WUFDL0QsSUFBSSxDQUFDLE9BQU8sQ0FBQyxjQUFjLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQztTQUNyRDtRQUVELElBQUksSUFBSSxDQUFDLGFBQWEsRUFBRTtZQUNwQixJQUFJLENBQUMsT0FBTyxDQUFDLGFBQWEsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDO1NBQ25EO1FBRUQsSUFBSSxJQUFJLENBQUMsYUFBYSxFQUFFO1lBQ3BCLElBQUksQ0FBQyxPQUFPLENBQUMsYUFBYSxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUM7U0FDbkQ7UUFFRCxJQUFJLElBQUksQ0FBQyxZQUFZLEVBQUU7WUFDbkIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQztTQUNqRDtRQUVELElBQUksSUFBSSxDQUFDLFVBQVUsRUFBRTtZQUNqQixJQUFJLENBQUMsT0FBTyxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDO1NBQzdDO1FBRUQsSUFBSSxJQUFJLENBQUMsVUFBVSxFQUFFO1lBQ2pCLElBQUksQ0FBQyxPQUFPLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUM7U0FDN0M7UUFFRCxJQUFJLElBQUksQ0FBQyxZQUFZLEtBQUssSUFBSSxJQUFJLElBQUksQ0FBQyxZQUFZLEtBQUssS0FBSyxFQUFFO1lBQzNELElBQUksQ0FBQyxPQUFPLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUM7U0FDakQ7UUFFRCxJQUFJLENBQUMsT0FBTyxDQUFDLGdCQUFnQixFQUFFLENBQUM7Ozs7OztJQUtwQyxJQUFJLFdBQVcsS0FBYyxPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsRUFBRTs7OztJQUVqQyxPQUFPO1FBQzVCLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxZQUFZLEtBQUssT0FBTyxFQUFFOzs7WUFHdkMsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO1NBQ3hCOzs7OztJQUd5QixZQUFZO1FBQ3RDLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO1FBQ25CLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxZQUFZLEtBQUssT0FBTyxFQUFFO1lBQ3ZDLElBQUksQ0FBQyxlQUFlLEdBQUcsVUFBVSxDQUFDO2dCQUM5QixJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7YUFDdEIsRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1NBQy9COzs7OztJQUd5QixZQUFZO1FBQ3RDLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxZQUFZLEtBQUssT0FBTyxFQUFFO1lBQ3pDLElBQUksSUFBSSxDQUFDLGVBQWUsRUFBRTtnQkFDdEIsWUFBWSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQztnQkFDbkMsSUFBSSxDQUFDLGVBQWUsR0FBRyxJQUFJLENBQUM7YUFDL0I7WUFDRCxJQUFJLElBQUksQ0FBQyxZQUFZLEVBQUU7Z0JBQ25CLFVBQVUsQ0FBQztvQkFDUCxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxhQUFhLEVBQUU7d0JBQzdCLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQztxQkFDdkI7aUJBQ0osRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFDO2FBQy9CO2lCQUFNO2dCQUNMLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDO2FBQ25CO1NBQ0Y7Ozs7OztJQUlILGFBQWE7UUFDVCxPQUFPLElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDLFlBQVksRUFBRSxHQUFHLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztLQUN2RTs7Ozs7SUFHRCxXQUFXO1FBQ1AsSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFO1lBQ25DLElBQUksQ0FBQyxjQUFjLEVBQUUsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDOztZQUczQyxJQUFJLElBQUksQ0FBQyxZQUFZLEtBQUssT0FBTyxFQUFFO2dCQUNqQyxJQUFJLENBQUMsb0JBQW9CLEVBQUUsQ0FBQzthQUM3QjtZQUVELElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQztTQUN2QjtLQUNKOzs7OztJQUdELFlBQVk7UUFDUixJQUFJLElBQUksQ0FBQyxXQUFXLEVBQUU7WUFDcEIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLEVBQUUsQ0FBQzs7WUFHMUIsSUFBSSxJQUFJLENBQUMsWUFBWSxLQUFLLE9BQU8sRUFBRTtnQkFDakMsSUFBSSxDQUFDLHFCQUFxQixDQUFDLFdBQVcsRUFBRSxDQUFDO2FBQzFDO1lBRUQsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO1NBQ3RCO0tBQ0o7Ozs7O0lBR0QsY0FBYztRQUNWLElBQUksSUFBSSxDQUFDLFdBQVcsRUFBRTtZQUNwQixJQUFJLENBQUMsV0FBVyxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBQzNCLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDO1lBQ3hCLElBQUksQ0FBQyxxQkFBcUIsRUFBRSxDQUFDO1NBQzlCO0tBQ0o7Ozs7O0lBR0QsS0FBSztRQUNELElBQUksQ0FBQyxXQUFXLENBQUMsYUFBYSxDQUFDLEtBQUssRUFBRSxDQUFDO0tBQzFDOzs7OztJQUdELElBQUksR0FBRztRQUNILE9BQU8sSUFBSSxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssS0FBSyxLQUFLLEdBQUcsS0FBSyxHQUFHLEtBQUssQ0FBQztLQUNqRTs7Ozs7Ozs7SUFRTyxvQkFBb0I7UUFDeEIsSUFBSSxJQUFJLENBQUMsV0FBVyxFQUFFO1lBQ3BCLElBQUksQ0FBQyxxQkFBcUIsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLGFBQWEsRUFBRSxDQUFDLFNBQVMsQ0FBQztnQkFDdEUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxlQUFlLEVBQUUsQ0FBQzthQUNoQyxDQUFDLENBQUM7U0FDSjs7Ozs7OztJQU9HLFlBQVk7UUFDaEIsSUFBSSxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxDQUFDOzs7Ozs7O0lBT3pCLGFBQWE7UUFDakIsSUFBSSxDQUFDLGlCQUFpQixDQUFDLEtBQUssQ0FBQyxDQUFDOzs7UUFJOUIsSUFBSSxDQUFDLElBQUksQ0FBQyxjQUFjLEVBQUU7WUFDeEIsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDO1NBQ2Q7UUFDRCxJQUFJLENBQUMsY0FBYyxHQUFHLEtBQUssQ0FBQzs7Ozs7OztJQUl4QixpQkFBaUIsQ0FBQyxNQUFlO1FBQ3JDLElBQUksQ0FBQyxZQUFZLEdBQUcsTUFBTSxDQUFDO1FBQzNCLElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLEVBQUUsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxDQUFDOzs7Ozs7O0lBT3hELGFBQWE7UUFDakIsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUU7WUFDakIsMkJBQTJCLEVBQUUsQ0FBQztTQUMvQjs7Ozs7OztJQU9HLGNBQWM7UUFDbEIsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUU7WUFDckIsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLGNBQWMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLFdBQVcsRUFBRSxJQUFJLENBQUMsaUJBQWlCLENBQUMsQ0FBQztZQUNwRix1QkFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUM7WUFDeEMsSUFBSSxDQUFDLHFCQUFxQixtQkFBQyxNQUFNLENBQUMsZ0JBQXFELEVBQUMsQ0FBQztZQUN6RixJQUFJLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1NBQ2pEO1FBRUQsT0FBTyxJQUFJLENBQUMsV0FBVyxDQUFDOzs7Ozs7SUFPcEIsaUJBQWlCO1FBQ3JCLHVCQUFNLFlBQVksR0FBRyxJQUFJLGFBQWEsRUFBRSxDQUFDO1FBQ3pDLFlBQVksQ0FBQyxnQkFBZ0IsR0FBRyxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7O1FBR3BELElBQUksSUFBSSxDQUFDLFlBQVksS0FBSyxPQUFPLEVBQUU7WUFDakMsWUFBWSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUM7WUFDaEMsWUFBWSxDQUFDLGFBQWEsR0FBRyxrQ0FBa0MsQ0FBQztTQUNqRTtRQUVELFlBQVksQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQztRQUNsQyxZQUFZLENBQUMsY0FBYyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsZ0JBQWdCLENBQUMsVUFBVSxFQUFFLENBQUM7UUFDMUUsT0FBTyxZQUFZLENBQUM7Ozs7Ozs7OztJQVFoQixxQkFBcUIsQ0FBQyxRQUEyQztRQUNyRSxJQUFJLENBQUMscUJBQXFCLEdBQUcsUUFBUSxDQUFDLGVBQWUsQ0FBQyxTQUFTLENBQUMsTUFBTTtZQUNsRSx1QkFBTSxTQUFTLEdBQXdCLE1BQU0sQ0FBQyxjQUFjLENBQUMsUUFBUSxLQUFLLE9BQU8sR0FBRyxPQUFPLEdBQUcsUUFBUSxDQUFDO1lBQ3ZHLHFCQUFJLFNBQVMsR0FBd0IsTUFBTSxDQUFDLGNBQWMsQ0FBQyxRQUFRLEtBQUssS0FBSyxHQUFHLE9BQU8sR0FBRyxPQUFPLENBQUM7WUFFbEcsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsY0FBYyxFQUFFO2dCQUM5QixTQUFTLEdBQUcsU0FBUyxLQUFLLE9BQU8sR0FBRyxPQUFPLEdBQUcsT0FBTyxDQUFDO2FBQ3pEO1lBRUQsSUFBSSxDQUFDLE9BQU8sQ0FBQyxTQUFTLEdBQUcsU0FBUyxDQUFDO1lBQ25DLElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxHQUFHLFNBQVMsQ0FBQztZQUNuQyxJQUFJLENBQUMsT0FBTyxDQUFDLGdCQUFnQixFQUFFLENBQUM7WUFFaEMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQyxTQUFTLEVBQUUsU0FBUyxDQUFDLENBQUM7U0FDekQsQ0FBQyxDQUFDOzs7Ozs7O0lBUUMsWUFBWTtRQUNoQixNQUFNLENBQUMsT0FBTyxFQUFFLGVBQWUsQ0FBQyxHQUM5QixJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsS0FBSyxRQUFRLEdBQUcsQ0FBQyxLQUFLLEVBQUUsT0FBTyxDQUFDLEdBQUcsQ0FBQyxPQUFPLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFFNUUsTUFBTSxDQUFDLFFBQVEsRUFBRSxnQkFBZ0IsQ0FBQyxHQUNoQyxJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsS0FBSyxPQUFPLEdBQUcsQ0FBQyxRQUFRLEVBQUUsS0FBSyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsUUFBUSxDQUFDLENBQUM7OztRQUs3RSxxQkFBSSxPQUFPLEdBQUcsUUFBUSxDQUFDO1FBQ3ZCLHFCQUFJLGVBQWUsR0FBRyxnQkFBZ0IsQ0FBQztRQUV2Qyx1QkFBTSxRQUFRLEdBQUcsT0FBTyxDQUFDO1FBQ3pCLHVCQUFNLGdCQUFnQixHQUFHLGVBQWUsQ0FBQzs7OztRQU16QyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxjQUFjLEVBQUU7WUFDaEMsT0FBTyxHQUFHLFFBQVEsS0FBSyxLQUFLLEdBQUcsUUFBUSxHQUFHLEtBQUssQ0FBQztZQUNoRCxlQUFlLEdBQUcsZ0JBQWdCLEtBQUssS0FBSyxHQUFHLFFBQVEsR0FBRyxLQUFLLENBQUM7U0FDakU7UUFFRCxxQkFBSSxPQUFPLEdBQUcsQ0FBQyxDQUFDO1FBQ2hCLHFCQUFJLE9BQU8sR0FBRyxDQUFDLENBQUM7UUFFaEIsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLGFBQWEsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUMsQ0FBQyxFQUFFO1lBQzVFLE9BQU8sR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUMsQ0FBQzs7U0FFOUM7UUFFRCxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsYUFBYSxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFDLEVBQUU7WUFDNUUsT0FBTyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFDOztTQUU5Qzs7Ozs7O1FBT0QscUJBQUksT0FBTyxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUM7UUFDL0IsSUFBSSxPQUFPLElBQUksQ0FBQyxhQUFhLEtBQUssV0FBVyxFQUFFO1lBQzNDLElBQUksQ0FBQyxPQUFPLENBQUMsb0JBQW9CLEdBQUcsSUFBSSxDQUFDO1lBQ3pDLE9BQU8sR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLFdBQVcsQ0FBQztTQUM1QztRQUVELE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLEVBQUU7YUFDOUIsbUJBQW1CLENBQUMsT0FBTyxDQUFDO2FBQzVCLGFBQWEsQ0FBQztZQUNiO2dCQUNJLE9BQU87Z0JBQ1AsT0FBTztnQkFDUCxRQUFRO2dCQUNSLFFBQVE7Z0JBQ1IsT0FBTzthQUNWO1lBQ0Q7Z0JBQ0ksT0FBTyxFQUFFLGVBQWU7Z0JBQ3hCLE9BQU87Z0JBQ1AsUUFBUSxFQUFFLGdCQUFnQjtnQkFDMUIsUUFBUTtnQkFDUixPQUFPO2FBQ1Y7WUFDRDtnQkFDRSxPQUFPO2dCQUNQLE9BQU8sRUFBRSxlQUFlO2dCQUN4QixRQUFRO2dCQUNSLFFBQVEsRUFBRSxnQkFBZ0I7Z0JBQzFCLE9BQU8sRUFBRSxDQUFDLE9BQU87YUFDbEI7WUFDRDtnQkFDRSxPQUFPLEVBQUUsZUFBZTtnQkFDeEIsT0FBTyxFQUFFLGVBQWU7Z0JBQ3hCLFFBQVEsRUFBRSxnQkFBZ0I7Z0JBQzFCLFFBQVEsRUFBRSxnQkFBZ0I7Z0JBQzFCLE9BQU8sRUFBRSxDQUFDLE9BQU87YUFDbEI7U0FDRixDQUFDO2FBQ0Qsa0JBQWtCLENBQUMsT0FBTyxDQUFDO2FBQzNCLGtCQUFrQixDQUFDLE9BQU8sQ0FBQyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBb0J6QixxQkFBcUI7UUFDekIsSUFBSSxJQUFJLENBQUMscUJBQXFCLEVBQUU7WUFDNUIsSUFBSSxDQUFDLHFCQUFxQixDQUFDLFdBQVcsRUFBRSxDQUFDO1NBQzVDO1FBQ0QsSUFBSSxJQUFJLENBQUMscUJBQXFCLEVBQUU7WUFDNUIsSUFBSSxDQUFDLHFCQUFxQixDQUFDLFdBQVcsRUFBRSxDQUFDO1NBQzVDOzs7Ozs7SUFHc0IsZ0JBQWdCLENBQUMsS0FBaUI7UUFDekQsSUFBSSxLQUFLLElBQUksQ0FBQywrQkFBK0IsQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUNsRCxJQUFJLENBQUMsY0FBYyxHQUFHLElBQUksQ0FBQztTQUM5Qjs7OztZQTNjUixTQUFTLFNBQUM7Z0JBQ1QsUUFBUSxFQUFFLHdCQUF3QjtnQkFDbEMsUUFBUSxFQUFFLG1CQUFtQjthQUM5Qjs7OztZQTNCQyxPQUFPO1lBaEJQLFVBQVU7WUFNVixnQkFBZ0I7WUFPRSxjQUFjLHVCQXVHbkIsUUFBUTs7OzZCQXRFbEIsV0FBVyxTQUFDLG9CQUFvQjt3QkFnQmhDLEtBQUssU0FBQyxzQkFBc0I7OEJBRzVCLEtBQUssU0FBQyxvQkFBb0I7MEJBRzFCLEtBQUssU0FBQyxxQkFBcUI7MEJBRzNCLEtBQUssU0FBQyxxQkFBcUI7NkJBRzNCLEtBQUssU0FBQyxxQkFBcUI7MkJBRzNCLEtBQUssU0FBQyxzQkFBc0I7MkJBRzVCLEtBQUssU0FBQyxzQkFBc0I7K0JBRzVCLEtBQUssU0FBQywwQkFBMEI7OEJBR2hDLEtBQUssU0FBQyxtQkFBbUI7OEJBR3pCLEtBQUssU0FBQyxtQkFBbUI7NkJBR3pCLEtBQUssU0FBQyx3QkFBd0I7MkJBSTlCLEtBQUssU0FBQyxzQkFBc0I7MkJBSTVCLEtBQUssU0FBQyxzQkFBc0I7NkJBSTVCLEtBQUssU0FBQyx3QkFBd0I7dUJBSTlCLE1BQU07dUJBR04sTUFBTTt3QkF5RU4sWUFBWSxTQUFDLE9BQU87NkJBUXBCLFlBQVksU0FBQyxZQUFZOzZCQVN6QixZQUFZLFNBQUMsWUFBWTtpQ0F1U3pCLFlBQVksU0FBQyxXQUFXOzs7Ozs7O0FDbmY3Qjs7OztJQVNFLFlBQW1CLFdBQXVCO1FBQXZCLGdCQUFXLEdBQVgsV0FBVyxDQUFZO0tBQUs7OztZQU5oRCxTQUFTLFNBQUM7Z0JBQ1QsUUFBUSxFQUFFLHdDQUF3QztnQkFDbEQsUUFBUSxFQUFFLGtCQUFrQjthQUM3Qjs7OztZQU5tQixVQUFVOzs7Ozs7O0FDQTlCOzs7WUFTQyxRQUFRLFNBQUM7Z0JBQ1IsT0FBTyxFQUFFO29CQUNQLGFBQWE7b0JBQ2IsWUFBWTtpQkFDYjtnQkFDRCxPQUFPLEVBQUUsQ0FBQyxVQUFVLEVBQUUsaUJBQWlCLEVBQUUsZ0JBQWdCLENBQUM7Z0JBQzFELFlBQVksRUFBRSxDQUFDLFVBQVUsRUFBRSxpQkFBaUIsRUFBRSxnQkFBZ0IsQ0FBQzthQUNoRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7In0=