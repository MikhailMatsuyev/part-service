import { trigger, state, style, animate, transition } from '@angular/animations';
import { Component, EventEmitter, Input, Output, TemplateRef, ViewChild, ViewEncapsulation, ElementRef, ChangeDetectionStrategy, HostBinding, Directive, Optional, ViewContainerRef, HostListener, NgModule } from '@angular/core';
import { ESCAPE } from '@angular/cdk/keycodes';
import { __read } from 'tslib';
import { isFakeMousedownFromScreenReader } from '@angular/cdk/a11y';
import { Directionality } from '@angular/cdk/bidi';
import { Overlay, OverlayConfig, OverlayModule } from '@angular/cdk/overlay';
import { TemplatePortal } from '@angular/cdk/portal';
import { CommonModule } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Throws an exception for the case when popover trigger doesn't have a valid mde-popover instance
 * @return {?}
 */
function throwMdePopoverMissingError() {
    throw Error("mde-popover-trigger: must pass in an mde-popover instance.\n\n    Example:\n      <mde-popover #popover=\"mdePopover\"></mde-popover>\n      <button [mdePopoverTriggerFor]=\"popover\"></button>");
}
/**
 * Throws an exception for the case when popover's mdePopoverPositionX value isn't valid.
 * In other words, it doesn't match 'before' or 'after'.
 * @return {?}
 */
function throwMdePopoverInvalidPositionX() {
    throw Error("mdePopoverPositionX value must be either 'before' or after'.\n      Example: <mde-popover mdePopoverPositionX=\"before\" #popover=\"mdePopover\"></mde-popover>");
}
/**
 * Throws an exception for the case when popover's mdePopoverPositionY value isn't valid.
 * In other words, it doesn't match 'above' or 'below'.
 * @return {?}
 */
function throwMdePopoverInvalidPositionY() {
    throw Error("mdePopoverPositionY value must be either 'above' or below'.\n      Example: <mde-popover mdePopoverPositionY=\"above\" #popover=\"mdePopover\"></mde-popover>");
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * This animation controls the popover panel's entry and exit from the page.
 *
 * When the popover panel is added to the DOM, it scales in and fades in its border.
 *
 * When the popover panel is removed from the DOM, it simply fades out after a brief
 * delay to display the ripple.
 */
var /** @type {?} */ transformPopover = trigger('transformPopover', [
    state('enter', style({
        opacity: 1,
        transform: "scale(1)"
    })),
    transition('void => *', [
        style({
            opacity: 0,
            transform: "scale(0)"
        }),
        animate("200ms cubic-bezier(0.25, 0.8, 0.25, 1)")
    ]),
    transition('* => void', [
        animate('50ms 100ms linear', style({ opacity: 0 }))
    ])
]);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var MdePopover = /** @class */ (function () {
    function MdePopover(_elementRef) {
        this._elementRef = _elementRef;
        // tslint:disable-line:component-class-suffix
        this.role = 'dialog';
        /**
         * Settings for popover, view setters and getters for more detail
         */
        this._positionX = 'after';
        this._positionY = 'below';
        this._triggerEvent = 'hover';
        this._enterDelay = 200;
        this._leaveDelay = 200;
        this._overlapTrigger = true;
        this._targetOffsetX = 0;
        this._targetOffsetY = 0;
        this._arrowOffsetX = 20;
        this._arrowWidth = 8;
        this._arrowColor = 'rgba(0, 0, 0, 0.12)';
        this._closeOnClick = true;
        this._focusTrapEnabled = true;
        /**
         * Config object to be passed into the popover's ngClass
         */
        this._classList = {};
        /**
         *
         */
        this.containerPositioning = false;
        /**
         * Closing disabled on popover
         */
        this.closeDisabled = false;
        /**
         * Emits the current animation state whenever it changes.
         */
        this._onAnimationStateChange = new EventEmitter();
        /**
         * Event emitted when the popover is closed.
         */
        this.close = new EventEmitter();
        this.setPositionClasses();
    }
    Object.defineProperty(MdePopover.prototype, "positionX", {
        get: /**
         * Position of the popover in the X axis.
         * @return {?}
         */
        function () { return this._positionX; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value !== 'before' && value !== 'after') {
                throwMdePopoverInvalidPositionX();
            }
            this._positionX = value;
            this.setPositionClasses();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdePopover.prototype, "positionY", {
        get: /**
         * Position of the popover in the Y axis.
         * @return {?}
         */
        function () { return this._positionY; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value !== 'above' && value !== 'below') {
                throwMdePopoverInvalidPositionY();
            }
            this._positionY = value;
            this.setPositionClasses();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdePopover.prototype, "triggerEvent", {
        get: /**
         * Popover trigger event
         * @return {?}
         */
        function () { return this._triggerEvent; },
        set: /**
         * @param {?} v
         * @return {?}
         */
        function (v) { this._triggerEvent = v; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdePopover.prototype, "enterDelay", {
        get: /**
         * Popover enter delay
         * @return {?}
         */
        function () { return this._enterDelay; },
        set: /**
         * @param {?} v
         * @return {?}
         */
        function (v) { this._enterDelay = v; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdePopover.prototype, "leaveDelay", {
        get: /**
         * Popover leave delay
         * @return {?}
         */
        function () { return this._leaveDelay; },
        set: /**
         * @param {?} v
         * @return {?}
         */
        function (v) { this._leaveDelay = v; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdePopover.prototype, "overlapTrigger", {
        get: /**
         * Popover overlap trigger
         * @return {?}
         */
        function () { return this._overlapTrigger; },
        set: /**
         * @param {?} v
         * @return {?}
         */
        function (v) { this._overlapTrigger = v; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdePopover.prototype, "targetOffsetX", {
        get: /**
         * Popover target offset x
         * @return {?}
         */
        function () { return this._targetOffsetX; },
        set: /**
         * @param {?} v
         * @return {?}
         */
        function (v) { this._targetOffsetX = v; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdePopover.prototype, "targetOffsetY", {
        get: /**
         * Popover target offset y
         * @return {?}
         */
        function () { return this._targetOffsetY; },
        set: /**
         * @param {?} v
         * @return {?}
         */
        function (v) { this._targetOffsetY = v; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdePopover.prototype, "arrowOffsetX", {
        get: /**
         * Popover arrow offset x
         * @return {?}
         */
        function () { return this._arrowOffsetX; },
        set: /**
         * @param {?} v
         * @return {?}
         */
        function (v) { this._arrowOffsetX = v; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdePopover.prototype, "arrowWidth", {
        get: /**
         * Popover arrow width
         * @return {?}
         */
        function () { return this._arrowWidth; },
        set: /**
         * @param {?} v
         * @return {?}
         */
        function (v) { this._arrowWidth = v; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdePopover.prototype, "arrowColor", {
        get: /**
         * Popover arrow color
         * @return {?}
         */
        function () { return this._arrowColor; },
        set: /**
         * @param {?} v
         * @return {?}
         */
        function (v) { this._arrowColor = v; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdePopover.prototype, "closeOnClick", {
        get: /**
         * Popover container close on click
         * default: true
         * @return {?}
         */
        function () { return this._closeOnClick; },
        set: /**
         * @param {?} v
         * @return {?}
         */
        function (v) { this._closeOnClick = v; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdePopover.prototype, "focusTrapEnabled", {
        get: /**
         * Popover focus trap using cdkTrapFocus
         * default: true
         * @return {?}
         */
        function () { return this._focusTrapEnabled; },
        set: /**
         * @param {?} v
         * @return {?}
         */
        function (v) { this._focusTrapEnabled = v; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdePopover.prototype, "panelClass", {
        set: /**
         * This method takes classes set on the host md-popover element and applies them on the
         * popover template that displays in the overlay container.  Otherwise, it's difficult
         * to style the containing popover from outside the component.
         * @param {?} classes list of class names
         * @return {?}
         */
        function (classes) {
            if (classes && classes.length) {
                this._classList = classes.split(' ').reduce(function (obj, className) {
                    obj[className] = true;
                    return obj;
                }, {});
                this._elementRef.nativeElement.className = '';
                this.setPositionClasses();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdePopover.prototype, "classList", {
        get: /**
         * This method takes classes set on the host md-popover element and applies them on the
         * popover template that displays in the overlay container.  Otherwise, it's difficult
         * to style the containing popover from outside the component.
         * @deprecated Use `panelClass` instead.
         * @return {?}
         */
        function () { return this.panelClass; },
        set: /**
         * @param {?} classes
         * @return {?}
         */
        function (classes) { this.panelClass = classes; },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    MdePopover.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._emitCloseEvent();
        this.close.complete();
    };
    /** Handle a keyboard event from the popover, delegating to the appropriate action. */
    /**
     * Handle a keyboard event from the popover, delegating to the appropriate action.
     * @param {?} event
     * @return {?}
     */
    MdePopover.prototype._handleKeydown = /**
     * Handle a keyboard event from the popover, delegating to the appropriate action.
     * @param {?} event
     * @return {?}
     */
    function (event) {
        switch (event.keyCode) {
            case ESCAPE:
                this._emitCloseEvent();
                return;
        }
    };
    /**
     * This emits a close event to which the trigger is subscribed. When emitted, the
     * trigger will close the popover.
     */
    /**
     * This emits a close event to which the trigger is subscribed. When emitted, the
     * trigger will close the popover.
     * @return {?}
     */
    MdePopover.prototype._emitCloseEvent = /**
     * This emits a close event to which the trigger is subscribed. When emitted, the
     * trigger will close the popover.
     * @return {?}
     */
    function () {
        this.close.emit();
    };
    /** Close popover on click if closeOnClick is true */
    /**
     * Close popover on click if closeOnClick is true
     * @return {?}
     */
    MdePopover.prototype.onClick = /**
     * Close popover on click if closeOnClick is true
     * @return {?}
     */
    function () {
        if (this.closeOnClick) {
            this._emitCloseEvent();
        }
    };
    /**
     * TODO: Refactor when @angular/cdk includes feature I mentioned on github see link below.
     * https://github.com/angular/material2/pull/5493#issuecomment-313085323
     */
    /** Disables close of popover when leaving trigger element and mouse over the popover */
    /**
     * Disables close of popover when leaving trigger element and mouse over the popover
     * @return {?}
     */
    MdePopover.prototype.onMouseOver = /**
     * Disables close of popover when leaving trigger element and mouse over the popover
     * @return {?}
     */
    function () {
        if (this.triggerEvent === 'hover') {
            this.closeDisabled = true;
        }
    };
    /** Enables close of popover when mouse leaving popover element */
    /**
     * Enables close of popover when mouse leaving popover element
     * @return {?}
     */
    MdePopover.prototype.onMouseLeave = /**
     * Enables close of popover when mouse leaving popover element
     * @return {?}
     */
    function () {
        if (this.triggerEvent === 'hover') {
            this.closeDisabled = false;
            this._emitCloseEvent();
        }
    };
    // TODO: Refactor how styles are set and updated on the component, use best practices.
    // TODO: If arrow left and right positioning is requested, see if flex direction can be used to work with order.
    /** Sets the current styles for the popover to allow for dynamically changing settings */
    /**
     * Sets the current styles for the popover to allow for dynamically changing settings
     * @return {?}
     */
    MdePopover.prototype.setCurrentStyles = /**
     * Sets the current styles for the popover to allow for dynamically changing settings
     * @return {?}
     */
    function () {
        // TODO: See if arrow position can be calculated automatically and allow override.
        // TODO: See if flex order is a better alternative to position arrow top or bottom.
        this.popoverArrowStyles = {
            'right': this.positionX === 'before' ? (this.arrowOffsetX - this.arrowWidth) + 'px' : '',
            'left': this.positionX === 'after' ? (this.arrowOffsetX - this.arrowWidth) + 'px' : '',
            'border-top': this.positionY === 'below' ?
                this.arrowWidth + 'px solid ' + this.arrowColor : '0px solid transparent',
            'border-right': 'undefined' === undefined ?
                this.arrowWidth + 'px solid ' + this.arrowColor :
                this.arrowWidth + 'px solid transparent',
            'border-bottom': this.positionY === 'above' ?
                this.arrowWidth + 'px solid ' + this.arrowColor :
                this.arrowWidth + 'px solid transparent',
            'border-left': 'undefined' === undefined ?
                this.arrowWidth + 'px solid ' + this.arrowColor :
                this.arrowWidth + 'px solid transparent',
        };
        // TODO: Remove if flex order is added.
        this.popoverContentStyles = {
            'padding-top': this.overlapTrigger === true ? '0px' : this.arrowWidth + 'px',
            'padding-bottom': this.overlapTrigger === true ? '0px' : (this.arrowWidth) + 'px',
            'margin-top': this.overlapTrigger === false && this.positionY === 'below' && this.containerPositioning === false ?
                -(this.arrowWidth * 2) + 'px' : '0px'
        };
    };
    /**
     * It's necessary to set position-based classes to ensure the popover panel animation
     * folds out from the correct direction.
     */
    /**
     * It's necessary to set position-based classes to ensure the popover panel animation
     * folds out from the correct direction.
     * @param {?=} posX
     * @param {?=} posY
     * @return {?}
     */
    MdePopover.prototype.setPositionClasses = /**
     * It's necessary to set position-based classes to ensure the popover panel animation
     * folds out from the correct direction.
     * @param {?=} posX
     * @param {?=} posY
     * @return {?}
     */
    function (posX, posY) {
        if (posX === void 0) { posX = this.positionX; }
        if (posY === void 0) { posY = this.positionY; }
        this._classList['mde-popover-before'] = posX === 'before';
        this._classList['mde-popover-after'] = posX === 'after';
        this._classList['mde-popover-above'] = posY === 'above';
        this._classList['mde-popover-below'] = posY === 'below';
    };
    MdePopover.decorators = [
        { type: Component, args: [{
                    selector: 'mde-popover',
                    template: "<ng-template>\n  <div class=\"mde-popover-panel\" role=\"dialog\" [class.mde-popover-overlap]=\"overlapTrigger\"\n       [ngClass]=\"_classList\" [ngStyle]=\"popoverPanelStyles\" (keydown)=\"_handleKeydown($event)\"\n       (click)=\"onClick()\" (mouseover)=\"onMouseOver()\" (mouseleave)=\"onMouseLeave()\"\n       [@transformPopover]=\"'enter'\">\n    <div class=\"mde-popover-direction-arrow\" [ngStyle]=\"popoverArrowStyles\" *ngIf=\"!overlapTrigger\"></div>\n    <div class=\"mde-popover-content\" [ngStyle]=\"popoverContentStyles\" cdkTrapFocus=\"focusTrapEnabled\">\n      <ng-content></ng-content>\n    </div>\n  </div>\n</ng-template>\n",
                    styles: [".mde-popover-panel{display:flex;flex-direction:column;max-height:calc(100vh + 48px)}.mde-popover-ripple{position:absolute;top:0;left:0;bottom:0;right:0}.mde-popover-below .mde-popover-direction-arrow{position:absolute;bottom:0;width:0;height:0;border-bottom-width:0!important;z-index:99999}.mde-popover-above .mde-popover-direction-arrow{position:absolute;top:0;width:0;height:0;border-top-width:0!important;z-index:99999}.mde-popover-after .mde-popover-direction-arrow{left:20px}.mde-popover-before .mde-popover-direction-arrow{right:20px}"],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    encapsulation: ViewEncapsulation.None,
                    animations: [
                        transformPopover
                    ],
                    exportAs: 'mdePopover'
                },] },
    ];
    /** @nocollapse */
    MdePopover.ctorParameters = function () { return [
        { type: ElementRef, },
    ]; };
    MdePopover.propDecorators = {
        "role": [{ type: HostBinding, args: ['attr.role',] },],
        "positionX": [{ type: Input, args: ['mdePopoverPositionX',] },],
        "positionY": [{ type: Input, args: ['mdePopoverPositionY',] },],
        "triggerEvent": [{ type: Input, args: ['mdePopoverTriggerOn',] },],
        "enterDelay": [{ type: Input, args: ['mdePopoverEnterDelay',] },],
        "leaveDelay": [{ type: Input, args: ['mdePopoverLeaveDelay',] },],
        "overlapTrigger": [{ type: Input, args: ['mdePopoverOverlapTrigger',] },],
        "targetOffsetX": [{ type: Input, args: ['mdePopoverOffsetX',] },],
        "targetOffsetY": [{ type: Input, args: ['mdePopoverOffsetY',] },],
        "arrowOffsetX": [{ type: Input, args: ['mdePopoverArrowOffsetX',] },],
        "arrowWidth": [{ type: Input, args: ['mdePopoverArrowWidth',] },],
        "arrowColor": [{ type: Input, args: ['mdePopoverArrowColor',] },],
        "closeOnClick": [{ type: Input, args: ['mdePopoverCloseOnClick',] },],
        "focusTrapEnabled": [{ type: Input, args: ['mdeFocusTrapEnabled',] },],
        "panelClass": [{ type: Input, args: ['class',] },],
        "classList": [{ type: Input },],
        "close": [{ type: Output },],
        "templateRef": [{ type: ViewChild, args: [TemplateRef,] },],
    };
    return MdePopover;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * This directive is intended to be used in conjunction with an mde-popover tag. It is
 * responsible for toggling the display of the provided popover instance.
 */
var MdePopoverTrigger = /** @class */ (function () {
    function MdePopoverTrigger(_overlay, _elementRef, _viewContainerRef, _dir) {
        this._overlay = _overlay;
        this._elementRef = _elementRef;
        this._viewContainerRef = _viewContainerRef;
        this._dir = _dir;
        // tslint:disable-line:directive-class-suffix
        this.ariaHaspopup = true;
        this._overlayRef = null;
        this._popoverOpen = false;
        this._halt = false;
        this._openedByMouse = false;
        /**
         * Event emitted when the associated popover is opened.
         */
        this.opened = new EventEmitter();
        /**
         * Event emitted when the associated popover is closed.
         */
        this.closed = new EventEmitter();
    }
    /**
     * @return {?}
     */
    MdePopoverTrigger.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this._checkPopover();
        this._setCurrentConfig();
        this.popover.close.subscribe(function () { return _this.closePopover(); });
    };
    /**
     * @return {?}
     */
    MdePopoverTrigger.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () { this.destroyPopover(); };
    /**
     * @return {?}
     */
    MdePopoverTrigger.prototype._setCurrentConfig = /**
     * @return {?}
     */
    function () {
        if (this.positionX === 'before' || this.positionX === 'after') {
            this.popover.positionX = this.positionX;
        }
        if (this.positionY === 'above' || this.positionY === 'below') {
            this.popover.positionY = this.positionY;
        }
        if (this.triggerEvent) {
            this.popover.triggerEvent = this.triggerEvent;
        }
        if (this.enterDelay) {
            this.popover.enterDelay = this.enterDelay;
        }
        if (this.leaveDelay) {
            this.popover.leaveDelay = this.leaveDelay;
        }
        if (this.overlapTrigger === true || this.overlapTrigger === false) {
            this.popover.overlapTrigger = this.overlapTrigger;
        }
        if (this.targetOffsetX) {
            this.popover.targetOffsetX = this.targetOffsetX;
        }
        if (this.targetOffsetY) {
            this.popover.targetOffsetY = this.targetOffsetY;
        }
        if (this.arrowOffsetX) {
            this.popover.arrowOffsetX = this.arrowOffsetX;
        }
        if (this.arrowWidth) {
            this.popover.arrowWidth = this.arrowWidth;
        }
        if (this.arrowColor) {
            this.popover.arrowColor = this.arrowColor;
        }
        if (this.closeOnClick === true || this.closeOnClick === false) {
            this.popover.closeOnClick = this.closeOnClick;
        }
        this.popover.setCurrentStyles();
    };
    Object.defineProperty(MdePopoverTrigger.prototype, "popoverOpen", {
        /** Whether the popover is open. */
        get: /**
         * Whether the popover is open.
         * @return {?}
         */
        function () { return this._popoverOpen; },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    MdePopoverTrigger.prototype.onClick = /**
     * @return {?}
     */
    function () {
        if (this.popover.triggerEvent === 'click') {
            // this.popover.setCurrentStyles();
            // this._setCurrentConfig();
            this.togglePopover();
        }
    };
    /**
     * @return {?}
     */
    MdePopoverTrigger.prototype.onMouseEnter = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this._halt = false;
        if (this.popover.triggerEvent === 'hover') {
            this._mouseoverTimer = setTimeout(function () {
                _this.openPopover();
            }, this.popover.enterDelay);
        }
    };
    /**
     * @return {?}
     */
    MdePopoverTrigger.prototype.onMouseLeave = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.popover.triggerEvent === 'hover') {
            if (this._mouseoverTimer) {
                clearTimeout(this._mouseoverTimer);
                this._mouseoverTimer = null;
            }
            if (this._popoverOpen) {
                setTimeout(function () {
                    if (!_this.popover.closeDisabled) {
                        _this.closePopover();
                    }
                }, this.popover.leaveDelay);
            }
            else {
                this._halt = true;
            }
        }
    };
    /** Toggles the popover between the open and closed states. */
    /**
     * Toggles the popover between the open and closed states.
     * @return {?}
     */
    MdePopoverTrigger.prototype.togglePopover = /**
     * Toggles the popover between the open and closed states.
     * @return {?}
     */
    function () {
        return this._popoverOpen ? this.closePopover() : this.openPopover();
    };
    /** Opens the popover. */
    /**
     * Opens the popover.
     * @return {?}
     */
    MdePopoverTrigger.prototype.openPopover = /**
     * Opens the popover.
     * @return {?}
     */
    function () {
        if (!this._popoverOpen && !this._halt) {
            this._createOverlay().attach(this._portal);
            /** Only subscribe to backdrop if trigger event is click */
            if (this.triggerEvent === 'click') {
                this._subscribeToBackdrop();
            }
            this._initPopover();
        }
    };
    /** Closes the popover. */
    /**
     * Closes the popover.
     * @return {?}
     */
    MdePopoverTrigger.prototype.closePopover = /**
     * Closes the popover.
     * @return {?}
     */
    function () {
        if (this._overlayRef) {
            this._overlayRef.detach();
            /** Only unsubscribe to backdrop if trigger event is click */
            if (this.triggerEvent === 'click') {
                this._backdropSubscription.unsubscribe();
            }
            this._resetPopover();
        }
    };
    /** Removes the popover from the DOM. */
    /**
     * Removes the popover from the DOM.
     * @return {?}
     */
    MdePopoverTrigger.prototype.destroyPopover = /**
     * Removes the popover from the DOM.
     * @return {?}
     */
    function () {
        if (this._overlayRef) {
            this._overlayRef.dispose();
            this._overlayRef = null;
            this._cleanUpSubscriptions();
        }
    };
    /** Focuses the popover trigger. */
    /**
     * Focuses the popover trigger.
     * @return {?}
     */
    MdePopoverTrigger.prototype.focus = /**
     * Focuses the popover trigger.
     * @return {?}
     */
    function () {
        this._elementRef.nativeElement.focus();
    };
    Object.defineProperty(MdePopoverTrigger.prototype, "dir", {
        /** The text direction of the containing app. */
        get: /**
         * The text direction of the containing app.
         * @return {?}
         */
        function () {
            return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';
        },
        enumerable: true,
        configurable: true
    });
    /**
     * This method ensures that the popover closes when the overlay backdrop is clicked.
     * We do not use first() here because doing so would not catch clicks from within
     * the popover, and it would fail to unsubscribe properly. Instead, we unsubscribe
     * explicitly when the popover is closed or destroyed.
     * @return {?}
     */
    MdePopoverTrigger.prototype._subscribeToBackdrop = /**
     * This method ensures that the popover closes when the overlay backdrop is clicked.
     * We do not use first() here because doing so would not catch clicks from within
     * the popover, and it would fail to unsubscribe properly. Instead, we unsubscribe
     * explicitly when the popover is closed or destroyed.
     * @return {?}
     */
    function () {
        var _this = this;
        if (this._overlayRef) {
            this._backdropSubscription = this._overlayRef.backdropClick().subscribe(function () {
                _this.popover._emitCloseEvent();
            });
        }
    };
    /**
     * This method sets the popover state to open and focuses the first item if
     * the popover was opened via the keyboard.
     * @return {?}
     */
    MdePopoverTrigger.prototype._initPopover = /**
     * This method sets the popover state to open and focuses the first item if
     * the popover was opened via the keyboard.
     * @return {?}
     */
    function () {
        this._setIsPopoverOpen(true);
    };
    /**
     * This method resets the popover when it's closed, most importantly restoring
     * focus to the popover trigger if the popover was opened via the keyboard.
     * @return {?}
     */
    MdePopoverTrigger.prototype._resetPopover = /**
     * This method resets the popover when it's closed, most importantly restoring
     * focus to the popover trigger if the popover was opened via the keyboard.
     * @return {?}
     */
    function () {
        this._setIsPopoverOpen(false);
        // Focus only needs to be reset to the host element if the popover was opened
        // by the keyboard and manually shifted to the first popover item.
        if (!this._openedByMouse) {
            this.focus();
        }
        this._openedByMouse = false;
    };
    /**
     * set state rather than toggle to support triggers sharing a popover
     * @param {?} isOpen
     * @return {?}
     */
    MdePopoverTrigger.prototype._setIsPopoverOpen = /**
     * set state rather than toggle to support triggers sharing a popover
     * @param {?} isOpen
     * @return {?}
     */
    function (isOpen) {
        this._popoverOpen = isOpen;
        this._popoverOpen ? this.opened.emit() : this.closed.emit();
    };
    /**
     *  This method checks that a valid instance of MdPopover has been passed into
     *  mdPopoverTriggerFor. If not, an exception is thrown.
     * @return {?}
     */
    MdePopoverTrigger.prototype._checkPopover = /**
     *  This method checks that a valid instance of MdPopover has been passed into
     *  mdPopoverTriggerFor. If not, an exception is thrown.
     * @return {?}
     */
    function () {
        if (!this.popover) {
            throwMdePopoverMissingError();
        }
    };
    /**
     *  This method creates the overlay from the provided popover's template and saves its
     *  OverlayRef so that it can be attached to the DOM when openPopover is called.
     * @return {?}
     */
    MdePopoverTrigger.prototype._createOverlay = /**
     *  This method creates the overlay from the provided popover's template and saves its
     *  OverlayRef so that it can be attached to the DOM when openPopover is called.
     * @return {?}
     */
    function () {
        if (!this._overlayRef) {
            this._portal = new TemplatePortal(this.popover.templateRef, this._viewContainerRef);
            var /** @type {?} */ config = this._getOverlayConfig();
            this._subscribeToPositions(/** @type {?} */ (config.positionStrategy));
            this._overlayRef = this._overlay.create(config);
        }
        return this._overlayRef;
    };
    /**
     * This method builds the configuration object needed to create the overlay, the OverlayConfig.
     * @return {?} OverlayConfig
     */
    MdePopoverTrigger.prototype._getOverlayConfig = /**
     * This method builds the configuration object needed to create the overlay, the OverlayConfig.
     * @return {?} OverlayConfig
     */
    function () {
        var /** @type {?} */ overlayState = new OverlayConfig();
        overlayState.positionStrategy = this._getPosition();
        /** Display overlay backdrop if trigger event is click */
        if (this.triggerEvent === 'click') {
            overlayState.hasBackdrop = true;
            overlayState.backdropClass = 'cdk-overlay-transparent-backdrop';
        }
        overlayState.direction = this.dir;
        overlayState.scrollStrategy = this._overlay.scrollStrategies.reposition();
        return overlayState;
    };
    /**
     * Listens to changes in the position of the overlay and sets the correct classes
     * on the popover based on the new position. This ensures the animation origin is always
     * correct, even if a fallback position is used for the overlay.
     * @param {?} position
     * @return {?}
     */
    MdePopoverTrigger.prototype._subscribeToPositions = /**
     * Listens to changes in the position of the overlay and sets the correct classes
     * on the popover based on the new position. This ensures the animation origin is always
     * correct, even if a fallback position is used for the overlay.
     * @param {?} position
     * @return {?}
     */
    function (position) {
        var _this = this;
        this._positionSubscription = position.positionChanges.subscribe(function (change) {
            var /** @type {?} */ posisionX = change.connectionPair.overlayX === 'start' ? 'after' : 'before';
            var /** @type {?} */ posisionY = change.connectionPair.overlayY === 'top' ? 'below' : 'above';
            if (!_this.popover.overlapTrigger) {
                posisionY = posisionY === 'below' ? 'above' : 'below';
            }
            _this.popover.positionX = posisionX;
            _this.popover.positionY = posisionY;
            _this.popover.setCurrentStyles();
            _this.popover.setPositionClasses(posisionX, posisionY);
        });
    };
    /**
     * This method builds the position strategy for the overlay, so the popover is properly connected
     * to the trigger.
     * @return {?} ConnectedPositionStrategy
     */
    MdePopoverTrigger.prototype._getPosition = /**
     * This method builds the position strategy for the overlay, so the popover is properly connected
     * to the trigger.
     * @return {?} ConnectedPositionStrategy
     */
    function () {
        var _a = __read(this.popover.positionX === 'before' ? ['end', 'start'] : ['start', 'end'], 2), originX = _a[0], originFallbackX = _a[1];
        var _b = __read(this.popover.positionY === 'above' ? ['bottom', 'top'] : ['top', 'bottom'], 2), overlayY = _b[0], overlayFallbackY = _b[1];
        // let originY = overlayY;
        // let fallbackOriginY = overlayFallbackY;
        var /** @type {?} */ originY = overlayY;
        var /** @type {?} */ originFallbackY = overlayFallbackY;
        var /** @type {?} */ overlayX = originX;
        var /** @type {?} */ overlayFallbackX = originFallbackX;
        // let [originY, originFallbackY] = [overlayY, overlayFallbackY];
        // let [overlayX, overlayFallbackX] = [originX, originFallbackX];
        /** Reverse overlayY and fallbackOverlayY when overlapTrigger is false */
        if (!this.popover.overlapTrigger) {
            originY = overlayY === 'top' ? 'bottom' : 'top';
            originFallbackY = overlayFallbackY === 'top' ? 'bottom' : 'top';
        }
        var /** @type {?} */ offsetX = 0;
        var /** @type {?} */ offsetY = 0;
        if (this.popover.targetOffsetX && !isNaN(Number(this.popover.targetOffsetX))) {
            offsetX = Number(this.popover.targetOffsetX);
            // offsetX = -16;
        }
        if (this.popover.targetOffsetY && !isNaN(Number(this.popover.targetOffsetY))) {
            offsetY = Number(this.popover.targetOffsetY);
            // offsetY = -10;
        }
        /**
         * For overriding position element, when mdePopoverTargetAt has a valid element reference.
         * Useful for sticking popover to parent element and offsetting arrow to trigger element.
         * If undefined defaults to the trigger element reference.
         */
        var /** @type {?} */ element = this._elementRef;
        if (typeof this.targetElement !== 'undefined') {
            this.popover.containerPositioning = true;
            element = this.targetElement._elementRef;
        }
        return this._overlay.position()
            .flexibleConnectedTo(element)
            .withPositions([
            {
                originX: originX,
                originY: originY,
                overlayX: overlayX,
                overlayY: overlayY,
                offsetY: offsetY
            },
            {
                originX: originFallbackX,
                originY: originY,
                overlayX: overlayFallbackX,
                overlayY: overlayY,
                offsetY: offsetY
            },
            {
                originX: originX,
                originY: originFallbackY,
                overlayX: overlayX,
                overlayY: overlayFallbackY,
                offsetY: -offsetY
            },
            {
                originX: originFallbackX,
                originY: originFallbackY,
                overlayX: overlayFallbackX,
                overlayY: overlayFallbackY,
                offsetY: -offsetY
            }
        ])
            .withDefaultOffsetX(offsetX)
            .withDefaultOffsetY(offsetY);
        /*
                return this._overlay.position()
                  .connectedTo(element,
                      {originX: posX, originY: originY},
                      {overlayX: posX, overlayY: overlayY})
                  .withFallbackPosition(
                      {originX: fallbackX, originY: originY},
                      {overlayX: fallbackX, overlayY: overlayY})
                  .withFallbackPosition(
                      {originX: posX, originY: fallbackOriginY},
                      {overlayX: posX, overlayY: fallbackOverlayY})
                  .withFallbackPosition(
                      {originX: fallbackX, originY: fallbackOriginY},
                      {overlayX: fallbackX, overlayY: fallbackOverlayY})
                  .withOffsetX(offsetX)
                  .withOffsetY(offsetY);
                  */
    };
    /**
     * @return {?}
     */
    MdePopoverTrigger.prototype._cleanUpSubscriptions = /**
     * @return {?}
     */
    function () {
        if (this._backdropSubscription) {
            this._backdropSubscription.unsubscribe();
        }
        if (this._positionSubscription) {
            this._positionSubscription.unsubscribe();
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    MdePopoverTrigger.prototype._handleMousedown = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (event && !isFakeMousedownFromScreenReader(event)) {
            this._openedByMouse = true;
        }
    };
    MdePopoverTrigger.decorators = [
        { type: Directive, args: [{
                    selector: '[mdePopoverTriggerFor]',
                    exportAs: 'mdePopoverTrigger'
                },] },
    ];
    /** @nocollapse */
    MdePopoverTrigger.ctorParameters = function () { return [
        { type: Overlay, },
        { type: ElementRef, },
        { type: ViewContainerRef, },
        { type: Directionality, decorators: [{ type: Optional },] },
    ]; };
    MdePopoverTrigger.propDecorators = {
        "ariaHaspopup": [{ type: HostBinding, args: ['attr.aria-haspopup',] },],
        "popover": [{ type: Input, args: ['mdePopoverTriggerFor',] },],
        "targetElement": [{ type: Input, args: ['mdePopoverTargetAt',] },],
        "positionX": [{ type: Input, args: ['mdePopoverPositionX',] },],
        "positionY": [{ type: Input, args: ['mdePopoverPositionY',] },],
        "triggerEvent": [{ type: Input, args: ['mdePopoverTriggerOn',] },],
        "enterDelay": [{ type: Input, args: ['mdePopoverEnterDelay',] },],
        "leaveDelay": [{ type: Input, args: ['mdePopoverLeaveDelay',] },],
        "overlapTrigger": [{ type: Input, args: ['mdePopoverOverlapTrigger',] },],
        "targetOffsetX": [{ type: Input, args: ['mdePopoverOffsetX',] },],
        "targetOffsetY": [{ type: Input, args: ['mdePopoverOffsetY',] },],
        "arrowOffsetX": [{ type: Input, args: ['mdePopoverArrowOffsetX',] },],
        "arrowWidth": [{ type: Input, args: ['mdePopoverArrowWidth',] },],
        "arrowColor": [{ type: Input, args: ['mdePopoverArrowColor',] },],
        "closeOnClick": [{ type: Input, args: ['mdePopoverCloseOnClick',] },],
        "opened": [{ type: Output },],
        "closed": [{ type: Output },],
        "onClick": [{ type: HostListener, args: ['click',] },],
        "onMouseEnter": [{ type: HostListener, args: ['mouseenter',] },],
        "onMouseLeave": [{ type: HostListener, args: ['mouseleave',] },],
        "_handleMousedown": [{ type: HostListener, args: ['mousedown',] },],
    };
    return MdePopoverTrigger;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var MdePopoverTarget = /** @class */ (function () {
    function MdePopoverTarget(_elementRef) {
        this._elementRef = _elementRef;
    }
    MdePopoverTarget.decorators = [
        { type: Directive, args: [{
                    selector: 'mde-popover-target, [mdePopoverTarget]',
                    exportAs: 'mdePopoverTarget'
                },] },
    ];
    /** @nocollapse */
    MdePopoverTarget.ctorParameters = function () { return [
        { type: ElementRef, },
    ]; };
    return MdePopoverTarget;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var MdePopoverModule = /** @class */ (function () {
    function MdePopoverModule() {
    }
    MdePopoverModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        OverlayModule,
                        CommonModule
                    ],
                    exports: [MdePopover, MdePopoverTrigger, MdePopoverTarget],
                    declarations: [MdePopover, MdePopoverTrigger, MdePopoverTarget],
                },] },
    ];
    return MdePopoverModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
// export { MdePopoverPositionX, MdePopoverPositionY, MdePopoverTriggerEvent } from './popover-types';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

export { MdePopoverModule, MdePopover, transformPopover, MdePopoverTrigger, MdePopoverTarget };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWF0ZXJpYWwtZXh0ZW5kZWQtbWRlLmpzLm1hcCIsInNvdXJjZXMiOlsibmc6Ly9AbWF0ZXJpYWwtZXh0ZW5kZWQvbWRlL2xpYi9wb3BvdmVyL3BvcG92ZXItZXJyb3JzLnRzIiwibmc6Ly9AbWF0ZXJpYWwtZXh0ZW5kZWQvbWRlL2xpYi9wb3BvdmVyL3BvcG92ZXItYW5pbWF0aW9ucy50cyIsIm5nOi8vQG1hdGVyaWFsLWV4dGVuZGVkL21kZS9saWIvcG9wb3Zlci9wb3BvdmVyLnRzIiwibmc6Ly9AbWF0ZXJpYWwtZXh0ZW5kZWQvbWRlL2xpYi9wb3BvdmVyL3BvcG92ZXItdHJpZ2dlci50cyIsIm5nOi8vQG1hdGVyaWFsLWV4dGVuZGVkL21kZS9saWIvcG9wb3Zlci9wb3BvdmVyLXRhcmdldC50cyIsIm5nOi8vQG1hdGVyaWFsLWV4dGVuZGVkL21kZS9saWIvcG9wb3Zlci9wb3BvdmVyLW1vZHVsZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogVGhyb3dzIGFuIGV4Y2VwdGlvbiBmb3IgdGhlIGNhc2Ugd2hlbiBwb3BvdmVyIHRyaWdnZXIgZG9lc24ndCBoYXZlIGEgdmFsaWQgbWRlLXBvcG92ZXIgaW5zdGFuY2VcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB0aHJvd01kZVBvcG92ZXJNaXNzaW5nRXJyb3IoKSB7XHJcbiAgdGhyb3cgRXJyb3IoYG1kZS1wb3BvdmVyLXRyaWdnZXI6IG11c3QgcGFzcyBpbiBhbiBtZGUtcG9wb3ZlciBpbnN0YW5jZS5cclxuXHJcbiAgICBFeGFtcGxlOlxyXG4gICAgICA8bWRlLXBvcG92ZXIgI3BvcG92ZXI9XCJtZGVQb3BvdmVyXCI+PC9tZGUtcG9wb3Zlcj5cclxuICAgICAgPGJ1dHRvbiBbbWRlUG9wb3ZlclRyaWdnZXJGb3JdPVwicG9wb3ZlclwiPjwvYnV0dG9uPmApO1xyXG59XHJcblxyXG4vKipcclxuICogVGhyb3dzIGFuIGV4Y2VwdGlvbiBmb3IgdGhlIGNhc2Ugd2hlbiBwb3BvdmVyJ3MgbWRlUG9wb3ZlclBvc2l0aW9uWCB2YWx1ZSBpc24ndCB2YWxpZC5cclxuICogSW4gb3RoZXIgd29yZHMsIGl0IGRvZXNuJ3QgbWF0Y2ggJ2JlZm9yZScgb3IgJ2FmdGVyJy5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB0aHJvd01kZVBvcG92ZXJJbnZhbGlkUG9zaXRpb25YKCkge1xyXG4gIHRocm93IEVycm9yKGBtZGVQb3BvdmVyUG9zaXRpb25YIHZhbHVlIG11c3QgYmUgZWl0aGVyICdiZWZvcmUnIG9yIGFmdGVyJy5cclxuICAgICAgRXhhbXBsZTogPG1kZS1wb3BvdmVyIG1kZVBvcG92ZXJQb3NpdGlvblg9XCJiZWZvcmVcIiAjcG9wb3Zlcj1cIm1kZVBvcG92ZXJcIj48L21kZS1wb3BvdmVyPmApO1xyXG59XHJcblxyXG4vKipcclxuICogVGhyb3dzIGFuIGV4Y2VwdGlvbiBmb3IgdGhlIGNhc2Ugd2hlbiBwb3BvdmVyJ3MgbWRlUG9wb3ZlclBvc2l0aW9uWSB2YWx1ZSBpc24ndCB2YWxpZC5cclxuICogSW4gb3RoZXIgd29yZHMsIGl0IGRvZXNuJ3QgbWF0Y2ggJ2Fib3ZlJyBvciAnYmVsb3cnLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHRocm93TWRlUG9wb3ZlckludmFsaWRQb3NpdGlvblkoKSB7XHJcbiAgdGhyb3cgRXJyb3IoYG1kZVBvcG92ZXJQb3NpdGlvblkgdmFsdWUgbXVzdCBiZSBlaXRoZXIgJ2Fib3ZlJyBvciBiZWxvdycuXHJcbiAgICAgIEV4YW1wbGU6IDxtZGUtcG9wb3ZlciBtZGVQb3BvdmVyUG9zaXRpb25ZPVwiYWJvdmVcIiAjcG9wb3Zlcj1cIm1kZVBvcG92ZXJcIj48L21kZS1wb3BvdmVyPmApO1xyXG59XHJcbiIsImltcG9ydCB7XHJcbiAgdHJpZ2dlcixcclxuICBzdGF0ZSxcclxuICBzdHlsZSxcclxuICBhbmltYXRlLFxyXG4gIHRyYW5zaXRpb24sXHJcbiAgQW5pbWF0aW9uVHJpZ2dlck1ldGFkYXRhLFxyXG59IGZyb20gJ0Bhbmd1bGFyL2FuaW1hdGlvbnMnO1xyXG5cclxuLyoqXHJcbiAqIEJlbG93IGFyZSBhbGwgdGhlIGFuaW1hdGlvbnMgZm9yIHRoZSBtZC1wb3BvdmVyIGNvbXBvbmVudC5cclxuICogQW5pbWF0aW9uIGR1cmF0aW9uIGFuZCB0aW1pbmcgdmFsdWVzIGFyZSBiYXNlZCBvbiBBbmd1bGFySlMgTWF0ZXJpYWwuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgYW5pbWF0aW9uIGNvbnRyb2xzIHRoZSBwb3BvdmVyIHBhbmVsJ3MgZW50cnkgYW5kIGV4aXQgZnJvbSB0aGUgcGFnZS5cclxuICpcclxuICogV2hlbiB0aGUgcG9wb3ZlciBwYW5lbCBpcyBhZGRlZCB0byB0aGUgRE9NLCBpdCBzY2FsZXMgaW4gYW5kIGZhZGVzIGluIGl0cyBib3JkZXIuXHJcbiAqXHJcbiAqIFdoZW4gdGhlIHBvcG92ZXIgcGFuZWwgaXMgcmVtb3ZlZCBmcm9tIHRoZSBET00sIGl0IHNpbXBseSBmYWRlcyBvdXQgYWZ0ZXIgYSBicmllZlxyXG4gKiBkZWxheSB0byBkaXNwbGF5IHRoZSByaXBwbGUuXHJcbiAqL1xyXG5cclxuZXhwb3J0IGNvbnN0IHRyYW5zZm9ybVBvcG92ZXI6IEFuaW1hdGlvblRyaWdnZXJNZXRhZGF0YSA9IHRyaWdnZXIoJ3RyYW5zZm9ybVBvcG92ZXInLCBbXHJcbiAgc3RhdGUoJ2VudGVyJywgc3R5bGUoe1xyXG4gICAgb3BhY2l0eTogMSxcclxuICAgIHRyYW5zZm9ybTogYHNjYWxlKDEpYFxyXG4gIH0pKSxcclxuICB0cmFuc2l0aW9uKCd2b2lkID0+IConLCBbXHJcbiAgICBzdHlsZSh7XHJcbiAgICAgIG9wYWNpdHk6IDAsXHJcbiAgICAgIHRyYW5zZm9ybTogYHNjYWxlKDApYFxyXG4gICAgfSksXHJcbiAgICBhbmltYXRlKGAyMDBtcyBjdWJpYy1iZXppZXIoMC4yNSwgMC44LCAwLjI1LCAxKWApXHJcbiAgXSksXHJcbiAgdHJhbnNpdGlvbignKiA9PiB2b2lkJywgW1xyXG4gICAgYW5pbWF0ZSgnNTBtcyAxMDBtcyBsaW5lYXInLCBzdHlsZSh7b3BhY2l0eTogMH0pKVxyXG4gIF0pXHJcbl0pO1xyXG4iLCJpbXBvcnQge1xyXG4gIENvbXBvbmVudCxcclxuICBFdmVudEVtaXR0ZXIsXHJcbiAgSW5wdXQsXHJcbiAgT25EZXN0cm95LFxyXG4gIE91dHB1dCxcclxuICBUZW1wbGF0ZVJlZixcclxuICBWaWV3Q2hpbGQsXHJcbiAgVmlld0VuY2Fwc3VsYXRpb24sXHJcbiAgRWxlbWVudFJlZixcclxuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcclxuICBIb3N0QmluZGluZyxcclxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuXHJcbmltcG9ydCB7IEVTQ0FQRSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9rZXljb2Rlcyc7XHJcblxyXG5pbXBvcnQgeyBNZGVQb3BvdmVyUG9zaXRpb25YLCBNZGVQb3BvdmVyUG9zaXRpb25ZLCBNZGVQb3BvdmVyVHJpZ2dlckV2ZW50IH0gZnJvbSAnLi9wb3BvdmVyLXR5cGVzJztcclxuaW1wb3J0IHsgdGhyb3dNZGVQb3BvdmVySW52YWxpZFBvc2l0aW9uWCwgdGhyb3dNZGVQb3BvdmVySW52YWxpZFBvc2l0aW9uWSB9IGZyb20gJy4vcG9wb3Zlci1lcnJvcnMnO1xyXG5pbXBvcnQgeyBNZGVQb3BvdmVyUGFuZWwgfSBmcm9tICcuL3BvcG92ZXItaW50ZXJmYWNlcyc7XHJcbmltcG9ydCB7IHRyYW5zZm9ybVBvcG92ZXIgfSBmcm9tICcuL3BvcG92ZXItYW5pbWF0aW9ucyc7XHJcblxyXG5pbXBvcnQgeyBBbmltYXRpb25FdmVudCB9IGZyb20gJ0Bhbmd1bGFyL2FuaW1hdGlvbnMnO1xyXG5cclxuXHJcblxyXG5AQ29tcG9uZW50KHtcclxuICBzZWxlY3RvcjogJ21kZS1wb3BvdmVyJyxcclxuICB0ZW1wbGF0ZTogYDxuZy10ZW1wbGF0ZT5cclxuICA8ZGl2IGNsYXNzPVwibWRlLXBvcG92ZXItcGFuZWxcIiByb2xlPVwiZGlhbG9nXCIgW2NsYXNzLm1kZS1wb3BvdmVyLW92ZXJsYXBdPVwib3ZlcmxhcFRyaWdnZXJcIlxyXG4gICAgICAgW25nQ2xhc3NdPVwiX2NsYXNzTGlzdFwiIFtuZ1N0eWxlXT1cInBvcG92ZXJQYW5lbFN0eWxlc1wiIChrZXlkb3duKT1cIl9oYW5kbGVLZXlkb3duKCRldmVudClcIlxyXG4gICAgICAgKGNsaWNrKT1cIm9uQ2xpY2soKVwiIChtb3VzZW92ZXIpPVwib25Nb3VzZU92ZXIoKVwiIChtb3VzZWxlYXZlKT1cIm9uTW91c2VMZWF2ZSgpXCJcclxuICAgICAgIFtAdHJhbnNmb3JtUG9wb3Zlcl09XCInZW50ZXInXCI+XHJcbiAgICA8ZGl2IGNsYXNzPVwibWRlLXBvcG92ZXItZGlyZWN0aW9uLWFycm93XCIgW25nU3R5bGVdPVwicG9wb3ZlckFycm93U3R5bGVzXCIgKm5nSWY9XCIhb3ZlcmxhcFRyaWdnZXJcIj48L2Rpdj5cclxuICAgIDxkaXYgY2xhc3M9XCJtZGUtcG9wb3Zlci1jb250ZW50XCIgW25nU3R5bGVdPVwicG9wb3ZlckNvbnRlbnRTdHlsZXNcIiBjZGtUcmFwRm9jdXM9XCJmb2N1c1RyYXBFbmFibGVkXCI+XHJcbiAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cclxuICAgIDwvZGl2PlxyXG4gIDwvZGl2PlxyXG48L25nLXRlbXBsYXRlPlxyXG5gLFxyXG4gIHN0eWxlczogW2AubWRlLXBvcG92ZXItcGFuZWx7ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjttYXgtaGVpZ2h0OmNhbGMoMTAwdmggKyA0OHB4KX0ubWRlLXBvcG92ZXItcmlwcGxle3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2xlZnQ6MDtib3R0b206MDtyaWdodDowfS5tZGUtcG9wb3Zlci1iZWxvdyAubWRlLXBvcG92ZXItZGlyZWN0aW9uLWFycm93e3Bvc2l0aW9uOmFic29sdXRlO2JvdHRvbTowO3dpZHRoOjA7aGVpZ2h0OjA7Ym9yZGVyLWJvdHRvbS13aWR0aDowIWltcG9ydGFudDt6LWluZGV4Ojk5OTk5fS5tZGUtcG9wb3Zlci1hYm92ZSAubWRlLXBvcG92ZXItZGlyZWN0aW9uLWFycm93e3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO3dpZHRoOjA7aGVpZ2h0OjA7Ym9yZGVyLXRvcC13aWR0aDowIWltcG9ydGFudDt6LWluZGV4Ojk5OTk5fS5tZGUtcG9wb3Zlci1hZnRlciAubWRlLXBvcG92ZXItZGlyZWN0aW9uLWFycm93e2xlZnQ6MjBweH0ubWRlLXBvcG92ZXItYmVmb3JlIC5tZGUtcG9wb3Zlci1kaXJlY3Rpb24tYXJyb3d7cmlnaHQ6MjBweH1gXSxcclxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcclxuICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxyXG4gIGFuaW1hdGlvbnM6IFtcclxuICAgIHRyYW5zZm9ybVBvcG92ZXJcclxuICBdLFxyXG4gIGV4cG9ydEFzOiAnbWRlUG9wb3ZlcidcclxufSlcclxuZXhwb3J0IGNsYXNzIE1kZVBvcG92ZXIgaW1wbGVtZW50cyBNZGVQb3BvdmVyUGFuZWwsIE9uRGVzdHJveSB7IC8vIHRzbGludDpkaXNhYmxlLWxpbmU6Y29tcG9uZW50LWNsYXNzLXN1ZmZpeFxyXG5cclxuICBASG9zdEJpbmRpbmcoJ2F0dHIucm9sZScpIHJvbGUgPSAnZGlhbG9nJztcclxuXHJcbiAgLyoqIFNldHRpbmdzIGZvciBwb3BvdmVyLCB2aWV3IHNldHRlcnMgYW5kIGdldHRlcnMgZm9yIG1vcmUgZGV0YWlsICovXHJcbiAgcHJpdmF0ZSBfcG9zaXRpb25YOiBNZGVQb3BvdmVyUG9zaXRpb25YID0gJ2FmdGVyJztcclxuICBwcml2YXRlIF9wb3NpdGlvblk6IE1kZVBvcG92ZXJQb3NpdGlvblkgPSAnYmVsb3cnO1xyXG4gIHByaXZhdGUgX3RyaWdnZXJFdmVudDogTWRlUG9wb3ZlclRyaWdnZXJFdmVudCA9ICdob3Zlcic7XHJcbiAgcHJpdmF0ZSBfZW50ZXJEZWxheSA9IDIwMDtcclxuICBwcml2YXRlIF9sZWF2ZURlbGF5ID0gMjAwO1xyXG4gIHByaXZhdGUgX292ZXJsYXBUcmlnZ2VyID0gdHJ1ZTtcclxuICBwcml2YXRlIF90YXJnZXRPZmZzZXRYID0gMDtcclxuICBwcml2YXRlIF90YXJnZXRPZmZzZXRZID0gMDtcclxuICBwcml2YXRlIF9hcnJvd09mZnNldFggPSAyMDtcclxuICBwcml2YXRlIF9hcnJvd1dpZHRoID0gODtcclxuICBwcml2YXRlIF9hcnJvd0NvbG9yID0gJ3JnYmEoMCwgMCwgMCwgMC4xMiknO1xyXG4gIHByaXZhdGUgX2Nsb3NlT25DbGljayA9IHRydWU7XHJcbiAgcHJpdmF0ZSBfZm9jdXNUcmFwRW5hYmxlZCA9IHRydWU7XHJcblxyXG4gIC8qKiBDb25maWcgb2JqZWN0IHRvIGJlIHBhc3NlZCBpbnRvIHRoZSBwb3BvdmVyJ3MgbmdDbGFzcyAqL1xyXG4gIF9jbGFzc0xpc3Q6IHtba2V5OiBzdHJpbmddOiBib29sZWFufSA9IHt9O1xyXG5cclxuICAvLyBUT0RPOiBXcml0ZSBjb21tZW50IGRlc2NyaXB0aW9uXHJcbiAgLyoqICovXHJcbiAgcHVibGljIGNvbnRhaW5lclBvc2l0aW9uaW5nID0gZmFsc2U7XHJcblxyXG4gIC8qKiBDbG9zaW5nIGRpc2FibGVkIG9uIHBvcG92ZXIgKi9cclxuICBwdWJsaWMgY2xvc2VEaXNhYmxlZCA9IGZhbHNlO1xyXG5cclxuICAvKiogQ29uZmlnIG9iamVjdCB0byBiZSBwYXNzZWQgaW50byB0aGUgcG9wb3ZlcidzIGFycm93IG5nU3R5bGUgKi9cclxuICBwdWJsaWMgcG9wb3ZlclBhbmVsU3R5bGVzOiB7fTtcclxuXHJcbiAgLyoqIENvbmZpZyBvYmplY3QgdG8gYmUgcGFzc2VkIGludG8gdGhlIHBvcG92ZXIncyBhcnJvdyBuZ1N0eWxlICovXHJcbiAgcHVibGljIHBvcG92ZXJBcnJvd1N0eWxlczoge307XHJcblxyXG4gIC8qKiBDb25maWcgb2JqZWN0IHRvIGJlIHBhc3NlZCBpbnRvIHRoZSBwb3BvdmVyJ3MgY29udGVudCBuZ1N0eWxlICovXHJcbiAgcHVibGljIHBvcG92ZXJDb250ZW50U3R5bGVzOiB7fTtcclxuXHJcbiAgLyoqIEVtaXRzIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBzdGF0ZSB3aGVuZXZlciBpdCBjaGFuZ2VzLiAqL1xyXG4gIF9vbkFuaW1hdGlvblN0YXRlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxBbmltYXRpb25FdmVudD4oKTtcclxuXHJcblxyXG4gIC8qKiBQb3NpdGlvbiBvZiB0aGUgcG9wb3ZlciBpbiB0aGUgWCBheGlzLiAqL1xyXG4gIEBJbnB1dCgnbWRlUG9wb3ZlclBvc2l0aW9uWCcpXHJcbiAgZ2V0IHBvc2l0aW9uWCgpIHsgcmV0dXJuIHRoaXMuX3Bvc2l0aW9uWDsgfVxyXG4gIHNldCBwb3NpdGlvblgodmFsdWU6IE1kZVBvcG92ZXJQb3NpdGlvblgpIHtcclxuICAgIGlmICh2YWx1ZSAhPT0gJ2JlZm9yZScgJiYgdmFsdWUgIT09ICdhZnRlcicpIHtcclxuICAgICAgdGhyb3dNZGVQb3BvdmVySW52YWxpZFBvc2l0aW9uWCgpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fcG9zaXRpb25YID0gdmFsdWU7XHJcbiAgICB0aGlzLnNldFBvc2l0aW9uQ2xhc3NlcygpO1xyXG4gIH1cclxuXHJcbiAgLyoqIFBvc2l0aW9uIG9mIHRoZSBwb3BvdmVyIGluIHRoZSBZIGF4aXMuICovXHJcbiAgQElucHV0KCdtZGVQb3BvdmVyUG9zaXRpb25ZJylcclxuICBnZXQgcG9zaXRpb25ZKCkgeyByZXR1cm4gdGhpcy5fcG9zaXRpb25ZOyB9XHJcbiAgc2V0IHBvc2l0aW9uWSh2YWx1ZTogTWRlUG9wb3ZlclBvc2l0aW9uWSkge1xyXG4gICAgaWYgKHZhbHVlICE9PSAnYWJvdmUnICYmIHZhbHVlICE9PSAnYmVsb3cnKSB7XHJcbiAgICAgIHRocm93TWRlUG9wb3ZlckludmFsaWRQb3NpdGlvblkoKTtcclxuICAgIH1cclxuICAgIHRoaXMuX3Bvc2l0aW9uWSA9IHZhbHVlO1xyXG4gICAgdGhpcy5zZXRQb3NpdGlvbkNsYXNzZXMoKTtcclxuICB9XHJcblxyXG4gIC8qKiBQb3BvdmVyIHRyaWdnZXIgZXZlbnQgKi9cclxuICBASW5wdXQoJ21kZVBvcG92ZXJUcmlnZ2VyT24nKVxyXG4gIGdldCB0cmlnZ2VyRXZlbnQoKTogTWRlUG9wb3ZlclRyaWdnZXJFdmVudCB7IHJldHVybiB0aGlzLl90cmlnZ2VyRXZlbnQ7IH1cclxuICBzZXQgdHJpZ2dlckV2ZW50KHY6IE1kZVBvcG92ZXJUcmlnZ2VyRXZlbnQpIHsgdGhpcy5fdHJpZ2dlckV2ZW50ID0gdjsgfVxyXG5cclxuICAvKiogUG9wb3ZlciBlbnRlciBkZWxheSAqL1xyXG4gIEBJbnB1dCgnbWRlUG9wb3ZlckVudGVyRGVsYXknKVxyXG4gIGdldCBlbnRlckRlbGF5KCk6IG51bWJlciB7IHJldHVybiB0aGlzLl9lbnRlckRlbGF5OyB9XHJcbiAgc2V0IGVudGVyRGVsYXkodjogbnVtYmVyKSB7IHRoaXMuX2VudGVyRGVsYXkgPSB2OyB9XHJcblxyXG4gIC8qKiBQb3BvdmVyIGxlYXZlIGRlbGF5ICovXHJcbiAgQElucHV0KCdtZGVQb3BvdmVyTGVhdmVEZWxheScpXHJcbiAgZ2V0IGxlYXZlRGVsYXkoKTogbnVtYmVyIHsgcmV0dXJuIHRoaXMuX2xlYXZlRGVsYXk7IH1cclxuICBzZXQgbGVhdmVEZWxheSh2OiBudW1iZXIpIHsgdGhpcy5fbGVhdmVEZWxheSA9IHY7IH1cclxuXHJcbiAgLyoqIFBvcG92ZXIgb3ZlcmxhcCB0cmlnZ2VyICovXHJcbiAgQElucHV0KCdtZGVQb3BvdmVyT3ZlcmxhcFRyaWdnZXInKVxyXG4gIGdldCBvdmVybGFwVHJpZ2dlcigpOiBib29sZWFuIHsgcmV0dXJuIHRoaXMuX292ZXJsYXBUcmlnZ2VyOyB9XHJcbiAgc2V0IG92ZXJsYXBUcmlnZ2VyKHY6IGJvb2xlYW4pIHsgdGhpcy5fb3ZlcmxhcFRyaWdnZXIgPSB2OyB9XHJcblxyXG4gIC8qKiBQb3BvdmVyIHRhcmdldCBvZmZzZXQgeCAqL1xyXG4gIEBJbnB1dCgnbWRlUG9wb3Zlck9mZnNldFgnKVxyXG4gIGdldCB0YXJnZXRPZmZzZXRYKCk6IG51bWJlciB7IHJldHVybiB0aGlzLl90YXJnZXRPZmZzZXRYOyB9XHJcbiAgc2V0IHRhcmdldE9mZnNldFgodjogbnVtYmVyKSB7IHRoaXMuX3RhcmdldE9mZnNldFggPSB2OyB9XHJcblxyXG4gIC8qKiBQb3BvdmVyIHRhcmdldCBvZmZzZXQgeSAqL1xyXG4gIEBJbnB1dCgnbWRlUG9wb3Zlck9mZnNldFknKVxyXG4gIGdldCB0YXJnZXRPZmZzZXRZKCk6IG51bWJlciB7IHJldHVybiB0aGlzLl90YXJnZXRPZmZzZXRZOyB9XHJcbiAgc2V0IHRhcmdldE9mZnNldFkodjogbnVtYmVyKSB7IHRoaXMuX3RhcmdldE9mZnNldFkgPSB2OyB9XHJcblxyXG4gIC8qKiBQb3BvdmVyIGFycm93IG9mZnNldCB4ICovXHJcbiAgQElucHV0KCdtZGVQb3BvdmVyQXJyb3dPZmZzZXRYJylcclxuICBnZXQgYXJyb3dPZmZzZXRYKCk6IG51bWJlciB7IHJldHVybiB0aGlzLl9hcnJvd09mZnNldFg7IH1cclxuICBzZXQgYXJyb3dPZmZzZXRYKHY6IG51bWJlcikgeyB0aGlzLl9hcnJvd09mZnNldFggPSB2OyB9XHJcblxyXG4gIC8qKiBQb3BvdmVyIGFycm93IHdpZHRoICovXHJcbiAgQElucHV0KCdtZGVQb3BvdmVyQXJyb3dXaWR0aCcpXHJcbiAgZ2V0IGFycm93V2lkdGgoKTogbnVtYmVyIHsgcmV0dXJuIHRoaXMuX2Fycm93V2lkdGg7IH1cclxuICBzZXQgYXJyb3dXaWR0aCh2OiBudW1iZXIpIHsgdGhpcy5fYXJyb3dXaWR0aCA9IHY7IH1cclxuXHJcbiAgLyoqIFBvcG92ZXIgYXJyb3cgY29sb3IgKi9cclxuICBASW5wdXQoJ21kZVBvcG92ZXJBcnJvd0NvbG9yJylcclxuICBnZXQgYXJyb3dDb2xvcigpOiBzdHJpbmcgeyByZXR1cm4gdGhpcy5fYXJyb3dDb2xvcjsgfVxyXG4gIHNldCBhcnJvd0NvbG9yKHY6IHN0cmluZykgeyB0aGlzLl9hcnJvd0NvbG9yID0gdjsgfVxyXG5cclxuICAvKipcclxuICAgKiBQb3BvdmVyIGNvbnRhaW5lciBjbG9zZSBvbiBjbGlja1xyXG4gICAqIGRlZmF1bHQ6IHRydWVcclxuICAgKi9cclxuICBASW5wdXQoJ21kZVBvcG92ZXJDbG9zZU9uQ2xpY2snKVxyXG4gIGdldCBjbG9zZU9uQ2xpY2soKTogYm9vbGVhbiB7IHJldHVybiB0aGlzLl9jbG9zZU9uQ2xpY2s7IH1cclxuICBzZXQgY2xvc2VPbkNsaWNrKHY6IGJvb2xlYW4pIHsgdGhpcy5fY2xvc2VPbkNsaWNrID0gdjsgfVxyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogUG9wb3ZlciBmb2N1cyB0cmFwIHVzaW5nIGNka1RyYXBGb2N1c1xyXG4gICAqIGRlZmF1bHQ6IHRydWVcclxuICAgKi9cclxuICBASW5wdXQoJ21kZUZvY3VzVHJhcEVuYWJsZWQnKVxyXG4gIGdldCBmb2N1c1RyYXBFbmFibGVkKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5fZm9jdXNUcmFwRW5hYmxlZDsgfVxyXG4gIHNldCBmb2N1c1RyYXBFbmFibGVkKHY6IGJvb2xlYW4pIHsgdGhpcy5fZm9jdXNUcmFwRW5hYmxlZCA9IHY7IH1cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgbWV0aG9kIHRha2VzIGNsYXNzZXMgc2V0IG9uIHRoZSBob3N0IG1kLXBvcG92ZXIgZWxlbWVudCBhbmQgYXBwbGllcyB0aGVtIG9uIHRoZVxyXG4gICAqIHBvcG92ZXIgdGVtcGxhdGUgdGhhdCBkaXNwbGF5cyBpbiB0aGUgb3ZlcmxheSBjb250YWluZXIuICBPdGhlcndpc2UsIGl0J3MgZGlmZmljdWx0XHJcbiAgICogdG8gc3R5bGUgdGhlIGNvbnRhaW5pbmcgcG9wb3ZlciBmcm9tIG91dHNpZGUgdGhlIGNvbXBvbmVudC5cclxuICAgKiBAcGFyYW0gY2xhc3NlcyBsaXN0IG9mIGNsYXNzIG5hbWVzXHJcbiAgICovXHJcbiAgQElucHV0KCdjbGFzcycpXHJcbiAgc2V0IHBhbmVsQ2xhc3MoY2xhc3Nlczogc3RyaW5nKSB7XHJcbiAgICBpZiAoY2xhc3NlcyAmJiBjbGFzc2VzLmxlbmd0aCkge1xyXG4gICAgICB0aGlzLl9jbGFzc0xpc3QgPSBjbGFzc2VzLnNwbGl0KCcgJykucmVkdWNlKChvYmo6IGFueSwgY2xhc3NOYW1lOiBzdHJpbmcpID0+IHtcclxuICAgICAgICBvYmpbY2xhc3NOYW1lXSA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuIG9iajtcclxuICAgICAgfSwge30pO1xyXG5cclxuICAgICAgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmNsYXNzTmFtZSA9ICcnO1xyXG4gICAgICB0aGlzLnNldFBvc2l0aW9uQ2xhc3NlcygpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBtZXRob2QgdGFrZXMgY2xhc3NlcyBzZXQgb24gdGhlIGhvc3QgbWQtcG9wb3ZlciBlbGVtZW50IGFuZCBhcHBsaWVzIHRoZW0gb24gdGhlXHJcbiAgICogcG9wb3ZlciB0ZW1wbGF0ZSB0aGF0IGRpc3BsYXlzIGluIHRoZSBvdmVybGF5IGNvbnRhaW5lci4gIE90aGVyd2lzZSwgaXQncyBkaWZmaWN1bHRcclxuICAgKiB0byBzdHlsZSB0aGUgY29udGFpbmluZyBwb3BvdmVyIGZyb20gb3V0c2lkZSB0aGUgY29tcG9uZW50LlxyXG4gICAqIEBkZXByZWNhdGVkIFVzZSBgcGFuZWxDbGFzc2AgaW5zdGVhZC5cclxuICAgKi9cclxuICBASW5wdXQoKVxyXG4gIGdldCBjbGFzc0xpc3QoKTogc3RyaW5nIHsgcmV0dXJuIHRoaXMucGFuZWxDbGFzczsgfVxyXG4gIHNldCBjbGFzc0xpc3QoY2xhc3Nlczogc3RyaW5nKSB7IHRoaXMucGFuZWxDbGFzcyA9IGNsYXNzZXM7IH1cclxuXHJcbiAgLyoqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgcG9wb3ZlciBpcyBjbG9zZWQuICovXHJcbiAgQE91dHB1dCgpIGNsb3NlID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xyXG5cclxuICBAVmlld0NoaWxkKFRlbXBsYXRlUmVmKSB0ZW1wbGF0ZVJlZjogVGVtcGxhdGVSZWY8YW55PjtcclxuXHJcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZikge1xyXG4gICAgdGhpcy5zZXRQb3NpdGlvbkNsYXNzZXMoKTtcclxuICB9XHJcblxyXG4gIG5nT25EZXN0cm95KCkge1xyXG4gICAgdGhpcy5fZW1pdENsb3NlRXZlbnQoKTtcclxuICAgIHRoaXMuY2xvc2UuY29tcGxldGUoKTtcclxuICB9XHJcblxyXG5cclxuICAvKiogSGFuZGxlIGEga2V5Ym9hcmQgZXZlbnQgZnJvbSB0aGUgcG9wb3ZlciwgZGVsZWdhdGluZyB0byB0aGUgYXBwcm9wcmlhdGUgYWN0aW9uLiAqL1xyXG4gIF9oYW5kbGVLZXlkb3duKGV2ZW50OiBLZXlib2FyZEV2ZW50KSB7XHJcbiAgICBzd2l0Y2ggKGV2ZW50LmtleUNvZGUpIHtcclxuICAgICAgY2FzZSBFU0NBUEU6XHJcbiAgICAgICAgdGhpcy5fZW1pdENsb3NlRXZlbnQoKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGlzIGVtaXRzIGEgY2xvc2UgZXZlbnQgdG8gd2hpY2ggdGhlIHRyaWdnZXIgaXMgc3Vic2NyaWJlZC4gV2hlbiBlbWl0dGVkLCB0aGVcclxuICAgKiB0cmlnZ2VyIHdpbGwgY2xvc2UgdGhlIHBvcG92ZXIuXHJcbiAgICovXHJcbiAgX2VtaXRDbG9zZUV2ZW50KCk6IHZvaWQge1xyXG4gICAgdGhpcy5jbG9zZS5lbWl0KCk7XHJcbiAgfVxyXG5cclxuICAvKiogQ2xvc2UgcG9wb3ZlciBvbiBjbGljayBpZiBjbG9zZU9uQ2xpY2sgaXMgdHJ1ZSAqL1xyXG4gIG9uQ2xpY2soKSB7XHJcbiAgICBpZiAodGhpcy5jbG9zZU9uQ2xpY2spIHtcclxuICAgICAgdGhpcy5fZW1pdENsb3NlRXZlbnQoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRPRE86IFJlZmFjdG9yIHdoZW4gQGFuZ3VsYXIvY2RrIGluY2x1ZGVzIGZlYXR1cmUgSSBtZW50aW9uZWQgb24gZ2l0aHViIHNlZSBsaW5rIGJlbG93LlxyXG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL21hdGVyaWFsMi9wdWxsLzU0OTMjaXNzdWVjb21tZW50LTMxMzA4NTMyM1xyXG4gICAqL1xyXG4gIC8qKiBEaXNhYmxlcyBjbG9zZSBvZiBwb3BvdmVyIHdoZW4gbGVhdmluZyB0cmlnZ2VyIGVsZW1lbnQgYW5kIG1vdXNlIG92ZXIgdGhlIHBvcG92ZXIgKi9cclxuICBvbk1vdXNlT3ZlcigpIHtcclxuICAgIGlmICh0aGlzLnRyaWdnZXJFdmVudCA9PT0gJ2hvdmVyJykge1xyXG4gICAgICB0aGlzLmNsb3NlRGlzYWJsZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxuICAvKiogRW5hYmxlcyBjbG9zZSBvZiBwb3BvdmVyIHdoZW4gbW91c2UgbGVhdmluZyBwb3BvdmVyIGVsZW1lbnQgKi9cclxuICBvbk1vdXNlTGVhdmUoKSB7XHJcbiAgICBpZiAodGhpcy50cmlnZ2VyRXZlbnQgPT09ICdob3ZlcicpIHtcclxuICAgICAgdGhpcy5jbG9zZURpc2FibGVkID0gZmFsc2U7XHJcbiAgICAgIHRoaXMuX2VtaXRDbG9zZUV2ZW50KCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBUT0RPOiBSZWZhY3RvciBob3cgc3R5bGVzIGFyZSBzZXQgYW5kIHVwZGF0ZWQgb24gdGhlIGNvbXBvbmVudCwgdXNlIGJlc3QgcHJhY3RpY2VzLlxyXG4gIC8vIFRPRE86IElmIGFycm93IGxlZnQgYW5kIHJpZ2h0IHBvc2l0aW9uaW5nIGlzIHJlcXVlc3RlZCwgc2VlIGlmIGZsZXggZGlyZWN0aW9uIGNhbiBiZSB1c2VkIHRvIHdvcmsgd2l0aCBvcmRlci5cclxuICAvKiogU2V0cyB0aGUgY3VycmVudCBzdHlsZXMgZm9yIHRoZSBwb3BvdmVyIHRvIGFsbG93IGZvciBkeW5hbWljYWxseSBjaGFuZ2luZyBzZXR0aW5ncyAqL1xyXG4gIHNldEN1cnJlbnRTdHlsZXMoKSB7XHJcblxyXG4gICAgLy8gVE9ETzogU2VlIGlmIGFycm93IHBvc2l0aW9uIGNhbiBiZSBjYWxjdWxhdGVkIGF1dG9tYXRpY2FsbHkgYW5kIGFsbG93IG92ZXJyaWRlLlxyXG4gICAgLy8gVE9ETzogU2VlIGlmIGZsZXggb3JkZXIgaXMgYSBiZXR0ZXIgYWx0ZXJuYXRpdmUgdG8gcG9zaXRpb24gYXJyb3cgdG9wIG9yIGJvdHRvbS5cclxuICAgIHRoaXMucG9wb3ZlckFycm93U3R5bGVzID0ge1xyXG4gICAgICAncmlnaHQnOiB0aGlzLnBvc2l0aW9uWCA9PT0gJ2JlZm9yZScgPyAodGhpcy5hcnJvd09mZnNldFggLSB0aGlzLmFycm93V2lkdGgpICsgJ3B4JyA6ICcnLFxyXG4gICAgICAnbGVmdCc6IHRoaXMucG9zaXRpb25YID09PSAnYWZ0ZXInID8gKHRoaXMuYXJyb3dPZmZzZXRYIC0gdGhpcy5hcnJvd1dpZHRoKSArICdweCcgOiAnJyxcclxuICAgICAgJ2JvcmRlci10b3AnOiB0aGlzLnBvc2l0aW9uWSA9PT0gJ2JlbG93JyA/XHJcbiAgICAgICAgdGhpcy5hcnJvd1dpZHRoICsgJ3B4IHNvbGlkICcgKyB0aGlzLmFycm93Q29sb3IgOiAnMHB4IHNvbGlkIHRyYW5zcGFyZW50JyxcclxuICAgICAgJ2JvcmRlci1yaWdodCc6ICd1bmRlZmluZWQnID09PSB1bmRlZmluZWQgP1xyXG4gICAgICAgIHRoaXMuYXJyb3dXaWR0aCArICdweCBzb2xpZCAnICsgdGhpcy5hcnJvd0NvbG9yIDpcclxuICAgICAgICB0aGlzLmFycm93V2lkdGggKyAncHggc29saWQgdHJhbnNwYXJlbnQnLFxyXG4gICAgICAnYm9yZGVyLWJvdHRvbSc6IHRoaXMucG9zaXRpb25ZID09PSAnYWJvdmUnID9cclxuICAgICAgICB0aGlzLmFycm93V2lkdGggKyAncHggc29saWQgJyArIHRoaXMuYXJyb3dDb2xvciA6XHJcbiAgICAgICAgdGhpcy5hcnJvd1dpZHRoICsgJ3B4IHNvbGlkIHRyYW5zcGFyZW50JyxcclxuICAgICAgJ2JvcmRlci1sZWZ0JzogJ3VuZGVmaW5lZCcgPT09IHVuZGVmaW5lZCA/XHJcbiAgICAgICAgdGhpcy5hcnJvd1dpZHRoICsgJ3B4IHNvbGlkICcgKyB0aGlzLmFycm93Q29sb3IgOlxyXG4gICAgICAgIHRoaXMuYXJyb3dXaWR0aCArICdweCBzb2xpZCB0cmFuc3BhcmVudCcsXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFRPRE86IFJlbW92ZSBpZiBmbGV4IG9yZGVyIGlzIGFkZGVkLlxyXG4gICAgdGhpcy5wb3BvdmVyQ29udGVudFN0eWxlcyA9IHtcclxuICAgICAgJ3BhZGRpbmctdG9wJzogdGhpcy5vdmVybGFwVHJpZ2dlciA9PT0gdHJ1ZSA/ICcwcHgnIDogdGhpcy5hcnJvd1dpZHRoICsgJ3B4JyxcclxuICAgICAgJ3BhZGRpbmctYm90dG9tJzogdGhpcy5vdmVybGFwVHJpZ2dlciA9PT0gdHJ1ZSA/ICcwcHgnIDogKHRoaXMuYXJyb3dXaWR0aCkgKyAncHgnLFxyXG4gICAgICAnbWFyZ2luLXRvcCc6IHRoaXMub3ZlcmxhcFRyaWdnZXIgPT09IGZhbHNlICYmIHRoaXMucG9zaXRpb25ZID09PSAnYmVsb3cnICYmIHRoaXMuY29udGFpbmVyUG9zaXRpb25pbmcgPT09IGZhbHNlID9cclxuICAgICAgICAtKHRoaXMuYXJyb3dXaWR0aCAqIDIpICsgJ3B4JyA6ICcwcHgnXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSXQncyBuZWNlc3NhcnkgdG8gc2V0IHBvc2l0aW9uLWJhc2VkIGNsYXNzZXMgdG8gZW5zdXJlIHRoZSBwb3BvdmVyIHBhbmVsIGFuaW1hdGlvblxyXG4gICAqIGZvbGRzIG91dCBmcm9tIHRoZSBjb3JyZWN0IGRpcmVjdGlvbi5cclxuICAgKi9cclxuICBzZXRQb3NpdGlvbkNsYXNzZXMocG9zWCA9IHRoaXMucG9zaXRpb25YLCBwb3NZID0gdGhpcy5wb3NpdGlvblkpOiB2b2lkIHtcclxuICAgIHRoaXMuX2NsYXNzTGlzdFsnbWRlLXBvcG92ZXItYmVmb3JlJ10gPSBwb3NYID09PSAnYmVmb3JlJztcclxuICAgIHRoaXMuX2NsYXNzTGlzdFsnbWRlLXBvcG92ZXItYWZ0ZXInXSA9IHBvc1ggPT09ICdhZnRlcic7XHJcbiAgICB0aGlzLl9jbGFzc0xpc3RbJ21kZS1wb3BvdmVyLWFib3ZlJ10gPSBwb3NZID09PSAnYWJvdmUnO1xyXG4gICAgdGhpcy5fY2xhc3NMaXN0WydtZGUtcG9wb3Zlci1iZWxvdyddID0gcG9zWSA9PT0gJ2JlbG93JztcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IHtcclxuICBBZnRlclZpZXdJbml0LFxyXG4gIERpcmVjdGl2ZSxcclxuICBFbGVtZW50UmVmLFxyXG4gIEV2ZW50RW1pdHRlcixcclxuICBJbnB1dCxcclxuICBPbkRlc3Ryb3ksXHJcbiAgT3B0aW9uYWwsXHJcbiAgT3V0cHV0LFxyXG4gIFZpZXdDb250YWluZXJSZWYsXHJcbiAgSG9zdExpc3RlbmVyLFxyXG4gIEhvc3RCaW5kaW5nLFxyXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuXHJcbmltcG9ydCB7IGlzRmFrZU1vdXNlZG93bkZyb21TY3JlZW5SZWFkZXIgfSBmcm9tICdAYW5ndWxhci9jZGsvYTExeSc7XHJcbmltcG9ydCB7IERpcmVjdGlvbiwgRGlyZWN0aW9uYWxpdHkgfSBmcm9tICdAYW5ndWxhci9jZGsvYmlkaSc7XHJcbmltcG9ydCB7XHJcbiAgQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneSxcclxuICBPdmVybGF5LFxyXG4gIE92ZXJsYXlSZWYsXHJcbiAgT3ZlcmxheUNvbmZpZyxcclxuICBIb3Jpem9udGFsQ29ubmVjdGlvblBvcyxcclxuICBWZXJ0aWNhbENvbm5lY3Rpb25Qb3MsXHJcbiAgRmxleGlibGVDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5XHJcbn0gZnJvbSAnQGFuZ3VsYXIvY2RrL292ZXJsYXknO1xyXG5pbXBvcnQgeyBUZW1wbGF0ZVBvcnRhbCB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9wb3J0YWwnO1xyXG5cclxuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XHJcblxyXG5pbXBvcnQgeyBmaXJzdCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuXHJcbmltcG9ydCB7IE1kZVBvcG92ZXJQYW5lbCwgTWRlVGFyZ2V0IH0gZnJvbSAnLi9wb3BvdmVyLWludGVyZmFjZXMnO1xyXG5pbXBvcnQgeyBNZGVQb3BvdmVyUG9zaXRpb25YLCBNZGVQb3BvdmVyUG9zaXRpb25ZLCBNZGVQb3BvdmVyVHJpZ2dlckV2ZW50IH0gZnJvbSAnLi9wb3BvdmVyLXR5cGVzJztcclxuaW1wb3J0IHsgdGhyb3dNZGVQb3BvdmVyTWlzc2luZ0Vycm9yIH0gZnJvbSAnLi9wb3BvdmVyLWVycm9ycyc7XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGlzIGRpcmVjdGl2ZSBpcyBpbnRlbmRlZCB0byBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggYW4gbWRlLXBvcG92ZXIgdGFnLiBJdCBpc1xyXG4gKiByZXNwb25zaWJsZSBmb3IgdG9nZ2xpbmcgdGhlIGRpc3BsYXkgb2YgdGhlIHByb3ZpZGVkIHBvcG92ZXIgaW5zdGFuY2UuXHJcbiAqL1xyXG5cclxuQERpcmVjdGl2ZSh7XHJcbiAgc2VsZWN0b3I6ICdbbWRlUG9wb3ZlclRyaWdnZXJGb3JdJyxcclxuICBleHBvcnRBczogJ21kZVBvcG92ZXJUcmlnZ2VyJ1xyXG59KVxyXG5leHBvcnQgY2xhc3MgTWRlUG9wb3ZlclRyaWdnZXIgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0LCBPbkRlc3Ryb3kgeyAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOmRpcmVjdGl2ZS1jbGFzcy1zdWZmaXhcclxuXHJcbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIuYXJpYS1oYXNwb3B1cCcpIGFyaWFIYXNwb3B1cCA9IHRydWU7XHJcblxyXG4gICAgcHJpdmF0ZSBfcG9ydGFsOiBUZW1wbGF0ZVBvcnRhbDxhbnk+O1xyXG4gICAgcHJpdmF0ZSBfb3ZlcmxheVJlZjogT3ZlcmxheVJlZiB8IG51bGwgPSBudWxsO1xyXG4gICAgcHJpdmF0ZSBfcG9wb3Zlck9wZW4gPSBmYWxzZTtcclxuICAgIHByaXZhdGUgX2hhbHQgPSBmYWxzZTtcclxuICAgIHByaXZhdGUgX2JhY2tkcm9wU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XHJcbiAgICBwcml2YXRlIF9wb3NpdGlvblN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xyXG5cclxuICAgIHByaXZhdGUgX21vdXNlb3ZlclRpbWVyOiBhbnk7XHJcblxyXG4gICAgLy8gdHJhY2tpbmcgaW5wdXQgdHlwZSBpcyBuZWNlc3Nhcnkgc28gaXQncyBwb3NzaWJsZSB0byBvbmx5IGF1dG8tZm9jdXNcclxuICAgIC8vIHRoZSBmaXJzdCBpdGVtIG9mIHRoZSBsaXN0IHdoZW4gdGhlIHBvcG92ZXIgaXMgb3BlbmVkIHZpYSB0aGUga2V5Ym9hcmRcclxuICAgIHByaXZhdGUgX29wZW5lZEJ5TW91c2UgPSBmYWxzZTtcclxuXHJcbiAgICAvKiogUmVmZXJlbmNlcyB0aGUgcG9wb3ZlciBpbnN0YW5jZSB0aGF0IHRoZSB0cmlnZ2VyIGlzIGFzc29jaWF0ZWQgd2l0aC4gKi9cclxuICAgIEBJbnB1dCgnbWRlUG9wb3ZlclRyaWdnZXJGb3InKSBwb3BvdmVyOiBNZGVQb3BvdmVyUGFuZWw7XHJcblxyXG4gICAgLyoqIFJlZmVyZW5jZXMgdGhlIHBvcG92ZXIgdGFyZ2V0IGluc3RhbmNlIHRoYXQgdGhlIHRyaWdnZXIgaXMgYXNzb2NpYXRlZCB3aXRoLiAqL1xyXG4gICAgQElucHV0KCdtZGVQb3BvdmVyVGFyZ2V0QXQnKSB0YXJnZXRFbGVtZW50OiBNZGVUYXJnZXQ7XHJcblxyXG4gICAgLyoqIFBvc2l0aW9uIG9mIHRoZSBwb3BvdmVyIGluIHRoZSBYIGF4aXMgKi9cclxuICAgIEBJbnB1dCgnbWRlUG9wb3ZlclBvc2l0aW9uWCcpIHBvc2l0aW9uWDogTWRlUG9wb3ZlclBvc2l0aW9uWDtcclxuXHJcbiAgICAvKiogUG9zaXRpb24gb2YgdGhlIHBvcG92ZXIgaW4gdGhlIFkgYXhpcyAqL1xyXG4gICAgQElucHV0KCdtZGVQb3BvdmVyUG9zaXRpb25ZJykgcG9zaXRpb25ZOiBNZGVQb3BvdmVyUG9zaXRpb25ZO1xyXG5cclxuICAgIC8qKiBQb3BvdmVyIHRyaWdnZXIgZXZlbnQgKi9cclxuICAgIEBJbnB1dCgnbWRlUG9wb3ZlclRyaWdnZXJPbicpIHRyaWdnZXJFdmVudDogTWRlUG9wb3ZlclRyaWdnZXJFdmVudDtcclxuXHJcbiAgICAvKiogUG9wb3ZlciBkZWxheSAqL1xyXG4gICAgQElucHV0KCdtZGVQb3BvdmVyRW50ZXJEZWxheScpIGVudGVyRGVsYXk6IG51bWJlcjtcclxuXHJcbiAgICAvKiogUG9wb3ZlciBkZWxheSAqL1xyXG4gICAgQElucHV0KCdtZGVQb3BvdmVyTGVhdmVEZWxheScpIGxlYXZlRGVsYXk6IG51bWJlcjtcclxuXHJcbiAgICAvKiogUG9wb3ZlciBvdmVybGFwIHRyaWdnZXIgKi9cclxuICAgIEBJbnB1dCgnbWRlUG9wb3Zlck92ZXJsYXBUcmlnZ2VyJykgb3ZlcmxhcFRyaWdnZXI6IGJvb2xlYW47XHJcblxyXG4gICAgLyoqIFBvcG92ZXIgdGFyZ2V0IG9mZnNldCB4ICovXHJcbiAgICBASW5wdXQoJ21kZVBvcG92ZXJPZmZzZXRYJykgdGFyZ2V0T2Zmc2V0WDogbnVtYmVyO1xyXG5cclxuICAgIC8qKiBQb3BvdmVyIHRhcmdldCBvZmZzZXQgeSAqL1xyXG4gICAgQElucHV0KCdtZGVQb3BvdmVyT2Zmc2V0WScpIHRhcmdldE9mZnNldFk6IG51bWJlcjtcclxuXHJcbiAgICAvKiogUG9wb3ZlciBhcnJvdyBvZmZzZXQgeCAqL1xyXG4gICAgQElucHV0KCdtZGVQb3BvdmVyQXJyb3dPZmZzZXRYJykgYXJyb3dPZmZzZXRYOiBudW1iZXI7XHJcblxyXG5cclxuICAgIC8qKiBQb3BvdmVyIGFycm93IHdpZHRoICovXHJcbiAgICBASW5wdXQoJ21kZVBvcG92ZXJBcnJvd1dpZHRoJykgYXJyb3dXaWR0aDogbnVtYmVyO1xyXG5cclxuXHJcbiAgICAvKiogUG9wb3ZlciBhcnJvdyBjb2xvciAqL1xyXG4gICAgQElucHV0KCdtZGVQb3BvdmVyQXJyb3dDb2xvcicpIGFycm93Q29sb3I6IHN0cmluZztcclxuXHJcblxyXG4gICAgLyoqIFBvcG92ZXIgY29udGFpbmVyIGNsb3NlIG9uIGNsaWNrICovXHJcbiAgICBASW5wdXQoJ21kZVBvcG92ZXJDbG9zZU9uQ2xpY2snKSBjbG9zZU9uQ2xpY2s6IGJvb2xlYW47XHJcblxyXG5cclxuICAgIC8qKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIGFzc29jaWF0ZWQgcG9wb3ZlciBpcyBvcGVuZWQuICovXHJcbiAgICBAT3V0cHV0KCkgb3BlbmVkID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xyXG5cclxuICAgIC8qKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIGFzc29jaWF0ZWQgcG9wb3ZlciBpcyBjbG9zZWQuICovXHJcbiAgICBAT3V0cHV0KCkgY2xvc2VkID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xyXG5cclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9vdmVybGF5OiBPdmVybGF5LCBwdWJsaWMgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYsXHJcbiAgICAgICAgICAgICAgcHJpdmF0ZSBfdmlld0NvbnRhaW5lclJlZjogVmlld0NvbnRhaW5lclJlZixcclxuICAgICAgICAgICAgICBAT3B0aW9uYWwoKSBwcml2YXRlIF9kaXI6IERpcmVjdGlvbmFsaXR5KSB7IH1cclxuXHJcbiAgICBuZ0FmdGVyVmlld0luaXQoKSB7XHJcbiAgICAgICAgdGhpcy5fY2hlY2tQb3BvdmVyKCk7XHJcbiAgICAgICAgdGhpcy5fc2V0Q3VycmVudENvbmZpZygpO1xyXG4gICAgICAgIHRoaXMucG9wb3Zlci5jbG9zZS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5jbG9zZVBvcG92ZXIoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgbmdPbkRlc3Ryb3koKSB7IHRoaXMuZGVzdHJveVBvcG92ZXIoKTsgfVxyXG5cclxuXHJcbiAgICBwcml2YXRlIF9zZXRDdXJyZW50Q29uZmlnKCkge1xyXG5cclxuICAgICAgICBpZiAodGhpcy5wb3NpdGlvblggPT09ICdiZWZvcmUnIHx8IHRoaXMucG9zaXRpb25YID09PSAnYWZ0ZXInKSB7XHJcbiAgICAgICAgICB0aGlzLnBvcG92ZXIucG9zaXRpb25YID0gdGhpcy5wb3NpdGlvblg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5wb3NpdGlvblkgPT09ICdhYm92ZScgfHwgdGhpcy5wb3NpdGlvblkgPT09ICdiZWxvdycpIHtcclxuICAgICAgICAgIHRoaXMucG9wb3Zlci5wb3NpdGlvblkgPSB0aGlzLnBvc2l0aW9uWTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnRyaWdnZXJFdmVudCkge1xyXG4gICAgICAgICAgICB0aGlzLnBvcG92ZXIudHJpZ2dlckV2ZW50ID0gdGhpcy50cmlnZ2VyRXZlbnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5lbnRlckRlbGF5KSB7XHJcbiAgICAgICAgICB0aGlzLnBvcG92ZXIuZW50ZXJEZWxheSA9IHRoaXMuZW50ZXJEZWxheTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmxlYXZlRGVsYXkpIHtcclxuICAgICAgICAgIHRoaXMucG9wb3Zlci5sZWF2ZURlbGF5ID0gdGhpcy5sZWF2ZURlbGF5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMub3ZlcmxhcFRyaWdnZXIgPT09IHRydWUgfHwgdGhpcy5vdmVybGFwVHJpZ2dlciA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgdGhpcy5wb3BvdmVyLm92ZXJsYXBUcmlnZ2VyID0gdGhpcy5vdmVybGFwVHJpZ2dlcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnRhcmdldE9mZnNldFgpIHtcclxuICAgICAgICAgICAgdGhpcy5wb3BvdmVyLnRhcmdldE9mZnNldFggPSB0aGlzLnRhcmdldE9mZnNldFg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy50YXJnZXRPZmZzZXRZKSB7XHJcbiAgICAgICAgICAgIHRoaXMucG9wb3Zlci50YXJnZXRPZmZzZXRZID0gdGhpcy50YXJnZXRPZmZzZXRZO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuYXJyb3dPZmZzZXRYKSB7XHJcbiAgICAgICAgICAgIHRoaXMucG9wb3Zlci5hcnJvd09mZnNldFggPSB0aGlzLmFycm93T2Zmc2V0WDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmFycm93V2lkdGgpIHtcclxuICAgICAgICAgICAgdGhpcy5wb3BvdmVyLmFycm93V2lkdGggPSB0aGlzLmFycm93V2lkdGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5hcnJvd0NvbG9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMucG9wb3Zlci5hcnJvd0NvbG9yID0gdGhpcy5hcnJvd0NvbG9yO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VPbkNsaWNrID09PSB0cnVlIHx8IHRoaXMuY2xvc2VPbkNsaWNrID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICB0aGlzLnBvcG92ZXIuY2xvc2VPbkNsaWNrID0gdGhpcy5jbG9zZU9uQ2xpY2s7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnBvcG92ZXIuc2V0Q3VycmVudFN0eWxlcygpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKiogV2hldGhlciB0aGUgcG9wb3ZlciBpcyBvcGVuLiAqL1xyXG4gICAgZ2V0IHBvcG92ZXJPcGVuKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5fcG9wb3Zlck9wZW47IH1cclxuXHJcbiAgICBASG9zdExpc3RlbmVyKCdjbGljaycpIG9uQ2xpY2soKSB7XHJcbiAgICAgIGlmICh0aGlzLnBvcG92ZXIudHJpZ2dlckV2ZW50ID09PSAnY2xpY2snKSB7XHJcbiAgICAgICAgICAvLyB0aGlzLnBvcG92ZXIuc2V0Q3VycmVudFN0eWxlcygpO1xyXG4gICAgICAgICAgLy8gdGhpcy5fc2V0Q3VycmVudENvbmZpZygpO1xyXG4gICAgICAgICAgdGhpcy50b2dnbGVQb3BvdmVyKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBASG9zdExpc3RlbmVyKCdtb3VzZWVudGVyJykgb25Nb3VzZUVudGVyKCkge1xyXG4gICAgICB0aGlzLl9oYWx0ID0gZmFsc2U7XHJcbiAgICAgIGlmICh0aGlzLnBvcG92ZXIudHJpZ2dlckV2ZW50ID09PSAnaG92ZXInKSB7XHJcbiAgICAgICAgICB0aGlzLl9tb3VzZW92ZXJUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgIHRoaXMub3BlblBvcG92ZXIoKTtcclxuICAgICAgICAgIH0sIHRoaXMucG9wb3Zlci5lbnRlckRlbGF5KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIEBIb3N0TGlzdGVuZXIoJ21vdXNlbGVhdmUnKSBvbk1vdXNlTGVhdmUoKSB7XHJcbiAgICAgIGlmICh0aGlzLnBvcG92ZXIudHJpZ2dlckV2ZW50ID09PSAnaG92ZXInKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX21vdXNlb3ZlclRpbWVyKSB7XHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9tb3VzZW92ZXJUaW1lcik7XHJcbiAgICAgICAgICAgIHRoaXMuX21vdXNlb3ZlclRpbWVyID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX3BvcG92ZXJPcGVuKSB7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnBvcG92ZXIuY2xvc2VEaXNhYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VQb3BvdmVyKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIHRoaXMucG9wb3Zlci5sZWF2ZURlbGF5KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy5faGFsdCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFRvZ2dsZXMgdGhlIHBvcG92ZXIgYmV0d2VlbiB0aGUgb3BlbiBhbmQgY2xvc2VkIHN0YXRlcy4gKi9cclxuICAgIHRvZ2dsZVBvcG92ZXIoKTogdm9pZCB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvcG92ZXJPcGVuID8gdGhpcy5jbG9zZVBvcG92ZXIoKSA6IHRoaXMub3BlblBvcG92ZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogT3BlbnMgdGhlIHBvcG92ZXIuICovXHJcbiAgICBvcGVuUG9wb3ZlcigpOiB2b2lkIHtcclxuICAgICAgICBpZiAoIXRoaXMuX3BvcG92ZXJPcGVuICYmICF0aGlzLl9oYWx0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZU92ZXJsYXkoKS5hdHRhY2godGhpcy5fcG9ydGFsKTtcclxuXHJcbiAgICAgICAgICAgIC8qKiBPbmx5IHN1YnNjcmliZSB0byBiYWNrZHJvcCBpZiB0cmlnZ2VyIGV2ZW50IGlzIGNsaWNrICovXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnRyaWdnZXJFdmVudCA9PT0gJ2NsaWNrJykge1xyXG4gICAgICAgICAgICAgIHRoaXMuX3N1YnNjcmliZVRvQmFja2Ryb3AoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5faW5pdFBvcG92ZXIoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIENsb3NlcyB0aGUgcG9wb3Zlci4gKi9cclxuICAgIGNsb3NlUG9wb3ZlcigpOiB2b2lkIHtcclxuICAgICAgICBpZiAodGhpcy5fb3ZlcmxheVJlZikge1xyXG4gICAgICAgICAgdGhpcy5fb3ZlcmxheVJlZi5kZXRhY2goKTtcclxuXHJcbiAgICAgICAgICAvKiogT25seSB1bnN1YnNjcmliZSB0byBiYWNrZHJvcCBpZiB0cmlnZ2VyIGV2ZW50IGlzIGNsaWNrICovXHJcbiAgICAgICAgICBpZiAodGhpcy50cmlnZ2VyRXZlbnQgPT09ICdjbGljaycpIHtcclxuICAgICAgICAgICAgdGhpcy5fYmFja2Ryb3BTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB0aGlzLl9yZXNldFBvcG92ZXIoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFJlbW92ZXMgdGhlIHBvcG92ZXIgZnJvbSB0aGUgRE9NLiAqL1xyXG4gICAgZGVzdHJveVBvcG92ZXIoKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKHRoaXMuX292ZXJsYXlSZWYpIHtcclxuICAgICAgICAgIHRoaXMuX292ZXJsYXlSZWYuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgdGhpcy5fb3ZlcmxheVJlZiA9IG51bGw7XHJcbiAgICAgICAgICB0aGlzLl9jbGVhblVwU3Vic2NyaXB0aW9ucygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKiogRm9jdXNlcyB0aGUgcG9wb3ZlciB0cmlnZ2VyLiAqL1xyXG4gICAgZm9jdXMoKSB7XHJcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFRoZSB0ZXh0IGRpcmVjdGlvbiBvZiB0aGUgY29udGFpbmluZyBhcHAuICovXHJcbiAgICBnZXQgZGlyKCk6IERpcmVjdGlvbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpciAmJiB0aGlzLl9kaXIudmFsdWUgPT09ICdydGwnID8gJ3J0bCcgOiAnbHRyJztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogVGhpcyBtZXRob2QgZW5zdXJlcyB0aGF0IHRoZSBwb3BvdmVyIGNsb3NlcyB3aGVuIHRoZSBvdmVybGF5IGJhY2tkcm9wIGlzIGNsaWNrZWQuXHJcbiAgICAqIFdlIGRvIG5vdCB1c2UgZmlyc3QoKSBoZXJlIGJlY2F1c2UgZG9pbmcgc28gd291bGQgbm90IGNhdGNoIGNsaWNrcyBmcm9tIHdpdGhpblxyXG4gICAgKiB0aGUgcG9wb3ZlciwgYW5kIGl0IHdvdWxkIGZhaWwgdG8gdW5zdWJzY3JpYmUgcHJvcGVybHkuIEluc3RlYWQsIHdlIHVuc3Vic2NyaWJlXHJcbiAgICAqIGV4cGxpY2l0bHkgd2hlbiB0aGUgcG9wb3ZlciBpcyBjbG9zZWQgb3IgZGVzdHJveWVkLlxyXG4gICAgKi9cclxuICAgIHByaXZhdGUgX3N1YnNjcmliZVRvQmFja2Ryb3AoKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKHRoaXMuX292ZXJsYXlSZWYpIHtcclxuICAgICAgICAgIHRoaXMuX2JhY2tkcm9wU3Vic2NyaXB0aW9uID0gdGhpcy5fb3ZlcmxheVJlZi5iYWNrZHJvcENsaWNrKCkuc3Vic2NyaWJlKCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5wb3BvdmVyLl9lbWl0Q2xvc2VFdmVudCgpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBUaGlzIG1ldGhvZCBzZXRzIHRoZSBwb3BvdmVyIHN0YXRlIHRvIG9wZW4gYW5kIGZvY3VzZXMgdGhlIGZpcnN0IGl0ZW0gaWZcclxuICAgICogdGhlIHBvcG92ZXIgd2FzIG9wZW5lZCB2aWEgdGhlIGtleWJvYXJkLlxyXG4gICAgKi9cclxuICAgIHByaXZhdGUgX2luaXRQb3BvdmVyKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX3NldElzUG9wb3Zlck9wZW4odHJ1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFRoaXMgbWV0aG9kIHJlc2V0cyB0aGUgcG9wb3ZlciB3aGVuIGl0J3MgY2xvc2VkLCBtb3N0IGltcG9ydGFudGx5IHJlc3RvcmluZ1xyXG4gICAgKiBmb2N1cyB0byB0aGUgcG9wb3ZlciB0cmlnZ2VyIGlmIHRoZSBwb3BvdmVyIHdhcyBvcGVuZWQgdmlhIHRoZSBrZXlib2FyZC5cclxuICAgICovXHJcbiAgICBwcml2YXRlIF9yZXNldFBvcG92ZXIoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fc2V0SXNQb3BvdmVyT3BlbihmYWxzZSk7XHJcblxyXG4gICAgICAgIC8vIEZvY3VzIG9ubHkgbmVlZHMgdG8gYmUgcmVzZXQgdG8gdGhlIGhvc3QgZWxlbWVudCBpZiB0aGUgcG9wb3ZlciB3YXMgb3BlbmVkXHJcbiAgICAgICAgLy8gYnkgdGhlIGtleWJvYXJkIGFuZCBtYW51YWxseSBzaGlmdGVkIHRvIHRoZSBmaXJzdCBwb3BvdmVyIGl0ZW0uXHJcbiAgICAgICAgaWYgKCF0aGlzLl9vcGVuZWRCeU1vdXNlKSB7XHJcbiAgICAgICAgICB0aGlzLmZvY3VzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX29wZW5lZEJ5TW91c2UgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogc2V0IHN0YXRlIHJhdGhlciB0aGFuIHRvZ2dsZSB0byBzdXBwb3J0IHRyaWdnZXJzIHNoYXJpbmcgYSBwb3BvdmVyICovXHJcbiAgICBwcml2YXRlIF9zZXRJc1BvcG92ZXJPcGVuKGlzT3BlbjogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX3BvcG92ZXJPcGVuID0gaXNPcGVuO1xyXG4gICAgICAgIHRoaXMuX3BvcG92ZXJPcGVuID8gdGhpcy5vcGVuZWQuZW1pdCgpIDogdGhpcy5jbG9zZWQuZW1pdCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiAgVGhpcyBtZXRob2QgY2hlY2tzIHRoYXQgYSB2YWxpZCBpbnN0YW5jZSBvZiBNZFBvcG92ZXIgaGFzIGJlZW4gcGFzc2VkIGludG9cclxuICAgICogIG1kUG9wb3ZlclRyaWdnZXJGb3IuIElmIG5vdCwgYW4gZXhjZXB0aW9uIGlzIHRocm93bi5cclxuICAgICovXHJcbiAgICBwcml2YXRlIF9jaGVja1BvcG92ZXIoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnBvcG92ZXIpIHtcclxuICAgICAgICAgIHRocm93TWRlUG9wb3Zlck1pc3NpbmdFcnJvcigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogIFRoaXMgbWV0aG9kIGNyZWF0ZXMgdGhlIG92ZXJsYXkgZnJvbSB0aGUgcHJvdmlkZWQgcG9wb3ZlcidzIHRlbXBsYXRlIGFuZCBzYXZlcyBpdHNcclxuICAgICogIE92ZXJsYXlSZWYgc28gdGhhdCBpdCBjYW4gYmUgYXR0YWNoZWQgdG8gdGhlIERPTSB3aGVuIG9wZW5Qb3BvdmVyIGlzIGNhbGxlZC5cclxuICAgICovXHJcbiAgICBwcml2YXRlIF9jcmVhdGVPdmVybGF5KCk6IE92ZXJsYXlSZWYge1xyXG4gICAgICAgIGlmICghdGhpcy5fb3ZlcmxheVJlZikge1xyXG4gICAgICAgICAgdGhpcy5fcG9ydGFsID0gbmV3IFRlbXBsYXRlUG9ydGFsKHRoaXMucG9wb3Zlci50ZW1wbGF0ZVJlZiwgdGhpcy5fdmlld0NvbnRhaW5lclJlZik7XHJcbiAgICAgICAgICBjb25zdCBjb25maWcgPSB0aGlzLl9nZXRPdmVybGF5Q29uZmlnKCk7XHJcbiAgICAgICAgICB0aGlzLl9zdWJzY3JpYmVUb1Bvc2l0aW9ucyhjb25maWcucG9zaXRpb25TdHJhdGVneSBhcyBGbGV4aWJsZUNvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kpO1xyXG4gICAgICAgICAgdGhpcy5fb3ZlcmxheVJlZiA9IHRoaXMuX292ZXJsYXkuY3JlYXRlKGNvbmZpZyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5fb3ZlcmxheVJlZjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogVGhpcyBtZXRob2QgYnVpbGRzIHRoZSBjb25maWd1cmF0aW9uIG9iamVjdCBuZWVkZWQgdG8gY3JlYXRlIHRoZSBvdmVybGF5LCB0aGUgT3ZlcmxheUNvbmZpZy5cclxuICAgICogQHJldHVybnMgT3ZlcmxheUNvbmZpZ1xyXG4gICAgKi9cclxuICAgIHByaXZhdGUgX2dldE92ZXJsYXlDb25maWcoKTogT3ZlcmxheUNvbmZpZyB7XHJcbiAgICAgICAgY29uc3Qgb3ZlcmxheVN0YXRlID0gbmV3IE92ZXJsYXlDb25maWcoKTtcclxuICAgICAgICBvdmVybGF5U3RhdGUucG9zaXRpb25TdHJhdGVneSA9IHRoaXMuX2dldFBvc2l0aW9uKCk7XHJcblxyXG4gICAgICAgIC8qKiBEaXNwbGF5IG92ZXJsYXkgYmFja2Ryb3AgaWYgdHJpZ2dlciBldmVudCBpcyBjbGljayAqL1xyXG4gICAgICAgIGlmICh0aGlzLnRyaWdnZXJFdmVudCA9PT0gJ2NsaWNrJykge1xyXG4gICAgICAgICAgb3ZlcmxheVN0YXRlLmhhc0JhY2tkcm9wID0gdHJ1ZTtcclxuICAgICAgICAgIG92ZXJsYXlTdGF0ZS5iYWNrZHJvcENsYXNzID0gJ2Nkay1vdmVybGF5LXRyYW5zcGFyZW50LWJhY2tkcm9wJztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG92ZXJsYXlTdGF0ZS5kaXJlY3Rpb24gPSB0aGlzLmRpcjtcclxuICAgICAgICBvdmVybGF5U3RhdGUuc2Nyb2xsU3RyYXRlZ3kgPSB0aGlzLl9vdmVybGF5LnNjcm9sbFN0cmF0ZWdpZXMucmVwb3NpdGlvbigpO1xyXG4gICAgICAgIHJldHVybiBvdmVybGF5U3RhdGU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIExpc3RlbnMgdG8gY2hhbmdlcyBpbiB0aGUgcG9zaXRpb24gb2YgdGhlIG92ZXJsYXkgYW5kIHNldHMgdGhlIGNvcnJlY3QgY2xhc3Nlc1xyXG4gICAgKiBvbiB0aGUgcG9wb3ZlciBiYXNlZCBvbiB0aGUgbmV3IHBvc2l0aW9uLiBUaGlzIGVuc3VyZXMgdGhlIGFuaW1hdGlvbiBvcmlnaW4gaXMgYWx3YXlzXHJcbiAgICAqIGNvcnJlY3QsIGV2ZW4gaWYgYSBmYWxsYmFjayBwb3NpdGlvbiBpcyB1c2VkIGZvciB0aGUgb3ZlcmxheS5cclxuICAgICovXHJcbiAgICBwcml2YXRlIF9zdWJzY3JpYmVUb1Bvc2l0aW9ucyhwb3NpdGlvbjogRmxleGlibGVDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5KTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fcG9zaXRpb25TdWJzY3JpcHRpb24gPSBwb3NpdGlvbi5wb3NpdGlvbkNoYW5nZXMuc3Vic2NyaWJlKGNoYW5nZSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBvc2lzaW9uWDogTWRlUG9wb3ZlclBvc2l0aW9uWCA9IGNoYW5nZS5jb25uZWN0aW9uUGFpci5vdmVybGF5WCA9PT0gJ3N0YXJ0JyA/ICdhZnRlcicgOiAnYmVmb3JlJztcclxuICAgICAgICAgICAgbGV0IHBvc2lzaW9uWTogTWRlUG9wb3ZlclBvc2l0aW9uWSA9IGNoYW5nZS5jb25uZWN0aW9uUGFpci5vdmVybGF5WSA9PT0gJ3RvcCcgPyAnYmVsb3cnIDogJ2Fib3ZlJztcclxuXHJcbiAgICAgICAgICAgIGlmICghdGhpcy5wb3BvdmVyLm92ZXJsYXBUcmlnZ2VyKSB7XHJcbiAgICAgICAgICAgICAgICBwb3Npc2lvblkgPSBwb3Npc2lvblkgPT09ICdiZWxvdycgPyAnYWJvdmUnIDogJ2JlbG93JztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5wb3BvdmVyLnBvc2l0aW9uWCA9IHBvc2lzaW9uWDtcclxuICAgICAgICAgICAgdGhpcy5wb3BvdmVyLnBvc2l0aW9uWSA9IHBvc2lzaW9uWTtcclxuICAgICAgICAgICAgdGhpcy5wb3BvdmVyLnNldEN1cnJlbnRTdHlsZXMoKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMucG9wb3Zlci5zZXRQb3NpdGlvbkNsYXNzZXMocG9zaXNpb25YLCBwb3Npc2lvblkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBUaGlzIG1ldGhvZCBidWlsZHMgdGhlIHBvc2l0aW9uIHN0cmF0ZWd5IGZvciB0aGUgb3ZlcmxheSwgc28gdGhlIHBvcG92ZXIgaXMgcHJvcGVybHkgY29ubmVjdGVkXHJcbiAgICAqIHRvIHRoZSB0cmlnZ2VyLlxyXG4gICAgKiBAcmV0dXJucyBDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5XHJcbiAgICAqL1xyXG4gICAgcHJpdmF0ZSBfZ2V0UG9zaXRpb24oKTogRmxleGlibGVDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5IHtcclxuICAgICAgICBjb25zdCBbb3JpZ2luWCwgb3JpZ2luRmFsbGJhY2tYXTogSG9yaXpvbnRhbENvbm5lY3Rpb25Qb3NbXSA9XHJcbiAgICAgICAgICB0aGlzLnBvcG92ZXIucG9zaXRpb25YID09PSAnYmVmb3JlJyA/IFsnZW5kJywgJ3N0YXJ0J10gOiBbJ3N0YXJ0JywgJ2VuZCddO1xyXG5cclxuICAgICAgICBjb25zdCBbb3ZlcmxheVksIG92ZXJsYXlGYWxsYmFja1ldOiBWZXJ0aWNhbENvbm5lY3Rpb25Qb3NbXSA9XHJcbiAgICAgICAgICB0aGlzLnBvcG92ZXIucG9zaXRpb25ZID09PSAnYWJvdmUnID8gWydib3R0b20nLCAndG9wJ10gOiBbJ3RvcCcsICdib3R0b20nXTtcclxuXHJcbiAgICAgICAgLy8gbGV0IG9yaWdpblkgPSBvdmVybGF5WTtcclxuICAgICAgICAvLyBsZXQgZmFsbGJhY2tPcmlnaW5ZID0gb3ZlcmxheUZhbGxiYWNrWTtcclxuXHJcbiAgICAgICAgbGV0IG9yaWdpblkgPSBvdmVybGF5WTtcclxuICAgICAgICBsZXQgb3JpZ2luRmFsbGJhY2tZID0gb3ZlcmxheUZhbGxiYWNrWTtcclxuXHJcbiAgICAgICAgY29uc3Qgb3ZlcmxheVggPSBvcmlnaW5YO1xyXG4gICAgICAgIGNvbnN0IG92ZXJsYXlGYWxsYmFja1ggPSBvcmlnaW5GYWxsYmFja1g7XHJcblxyXG4gICAgICAgIC8vIGxldCBbb3JpZ2luWSwgb3JpZ2luRmFsbGJhY2tZXSA9IFtvdmVybGF5WSwgb3ZlcmxheUZhbGxiYWNrWV07XHJcbiAgICAgICAgLy8gbGV0IFtvdmVybGF5WCwgb3ZlcmxheUZhbGxiYWNrWF0gPSBbb3JpZ2luWCwgb3JpZ2luRmFsbGJhY2tYXTtcclxuXHJcbiAgICAgICAgLyoqIFJldmVyc2Ugb3ZlcmxheVkgYW5kIGZhbGxiYWNrT3ZlcmxheVkgd2hlbiBvdmVybGFwVHJpZ2dlciBpcyBmYWxzZSAqL1xyXG4gICAgICAgIGlmICghdGhpcy5wb3BvdmVyLm92ZXJsYXBUcmlnZ2VyKSB7XHJcbiAgICAgICAgICBvcmlnaW5ZID0gb3ZlcmxheVkgPT09ICd0b3AnID8gJ2JvdHRvbScgOiAndG9wJztcclxuICAgICAgICAgIG9yaWdpbkZhbGxiYWNrWSA9IG92ZXJsYXlGYWxsYmFja1kgPT09ICd0b3AnID8gJ2JvdHRvbScgOiAndG9wJztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBvZmZzZXRYID0gMDtcclxuICAgICAgICBsZXQgb2Zmc2V0WSA9IDA7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnBvcG92ZXIudGFyZ2V0T2Zmc2V0WCAmJiAhaXNOYU4oTnVtYmVyKHRoaXMucG9wb3Zlci50YXJnZXRPZmZzZXRYKSkpIHtcclxuICAgICAgICAgIG9mZnNldFggPSBOdW1iZXIodGhpcy5wb3BvdmVyLnRhcmdldE9mZnNldFgpO1xyXG4gICAgICAgICAgLy8gb2Zmc2V0WCA9IC0xNjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnBvcG92ZXIudGFyZ2V0T2Zmc2V0WSAmJiAhaXNOYU4oTnVtYmVyKHRoaXMucG9wb3Zlci50YXJnZXRPZmZzZXRZKSkpIHtcclxuICAgICAgICAgIG9mZnNldFkgPSBOdW1iZXIodGhpcy5wb3BvdmVyLnRhcmdldE9mZnNldFkpO1xyXG4gICAgICAgICAgLy8gb2Zmc2V0WSA9IC0xMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZvciBvdmVycmlkaW5nIHBvc2l0aW9uIGVsZW1lbnQsIHdoZW4gbWRlUG9wb3ZlclRhcmdldEF0IGhhcyBhIHZhbGlkIGVsZW1lbnQgcmVmZXJlbmNlLlxyXG4gICAgICAgICAqIFVzZWZ1bCBmb3Igc3RpY2tpbmcgcG9wb3ZlciB0byBwYXJlbnQgZWxlbWVudCBhbmQgb2Zmc2V0dGluZyBhcnJvdyB0byB0cmlnZ2VyIGVsZW1lbnQuXHJcbiAgICAgICAgICogSWYgdW5kZWZpbmVkIGRlZmF1bHRzIHRvIHRoZSB0cmlnZ2VyIGVsZW1lbnQgcmVmZXJlbmNlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGxldCBlbGVtZW50ID0gdGhpcy5fZWxlbWVudFJlZjtcclxuICAgICAgICBpZiAodHlwZW9mIHRoaXMudGFyZ2V0RWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgdGhpcy5wb3BvdmVyLmNvbnRhaW5lclBvc2l0aW9uaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgZWxlbWVudCA9IHRoaXMudGFyZ2V0RWxlbWVudC5fZWxlbWVudFJlZjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLl9vdmVybGF5LnBvc2l0aW9uKClcclxuICAgICAgICAuZmxleGlibGVDb25uZWN0ZWRUbyhlbGVtZW50KVxyXG4gICAgICAgIC53aXRoUG9zaXRpb25zKFtcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgICBvcmlnaW5YLFxyXG4gICAgICAgICAgICAgIG9yaWdpblksXHJcbiAgICAgICAgICAgICAgb3ZlcmxheVgsXHJcbiAgICAgICAgICAgICAgb3ZlcmxheVksXHJcbiAgICAgICAgICAgICAgb2Zmc2V0WVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgICBvcmlnaW5YOiBvcmlnaW5GYWxsYmFja1gsXHJcbiAgICAgICAgICAgICAgb3JpZ2luWSxcclxuICAgICAgICAgICAgICBvdmVybGF5WDogb3ZlcmxheUZhbGxiYWNrWCxcclxuICAgICAgICAgICAgICBvdmVybGF5WSxcclxuICAgICAgICAgICAgICBvZmZzZXRZXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBvcmlnaW5YLFxyXG4gICAgICAgICAgICBvcmlnaW5ZOiBvcmlnaW5GYWxsYmFja1ksXHJcbiAgICAgICAgICAgIG92ZXJsYXlYLFxyXG4gICAgICAgICAgICBvdmVybGF5WTogb3ZlcmxheUZhbGxiYWNrWSxcclxuICAgICAgICAgICAgb2Zmc2V0WTogLW9mZnNldFlcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG9yaWdpblg6IG9yaWdpbkZhbGxiYWNrWCxcclxuICAgICAgICAgICAgb3JpZ2luWTogb3JpZ2luRmFsbGJhY2tZLFxyXG4gICAgICAgICAgICBvdmVybGF5WDogb3ZlcmxheUZhbGxiYWNrWCxcclxuICAgICAgICAgICAgb3ZlcmxheVk6IG92ZXJsYXlGYWxsYmFja1ksXHJcbiAgICAgICAgICAgIG9mZnNldFk6IC1vZmZzZXRZXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgXSlcclxuICAgICAgICAud2l0aERlZmF1bHRPZmZzZXRYKG9mZnNldFgpXHJcbiAgICAgICAgLndpdGhEZWZhdWx0T2Zmc2V0WShvZmZzZXRZKTtcclxuICAgICAgICAvKlxyXG4gICAgICAgIHJldHVybiB0aGlzLl9vdmVybGF5LnBvc2l0aW9uKClcclxuICAgICAgICAgIC5jb25uZWN0ZWRUbyhlbGVtZW50LFxyXG4gICAgICAgICAgICAgIHtvcmlnaW5YOiBwb3NYLCBvcmlnaW5ZOiBvcmlnaW5ZfSxcclxuICAgICAgICAgICAgICB7b3ZlcmxheVg6IHBvc1gsIG92ZXJsYXlZOiBvdmVybGF5WX0pXHJcbiAgICAgICAgICAud2l0aEZhbGxiYWNrUG9zaXRpb24oXHJcbiAgICAgICAgICAgICAge29yaWdpblg6IGZhbGxiYWNrWCwgb3JpZ2luWTogb3JpZ2luWX0sXHJcbiAgICAgICAgICAgICAge292ZXJsYXlYOiBmYWxsYmFja1gsIG92ZXJsYXlZOiBvdmVybGF5WX0pXHJcbiAgICAgICAgICAud2l0aEZhbGxiYWNrUG9zaXRpb24oXHJcbiAgICAgICAgICAgICAge29yaWdpblg6IHBvc1gsIG9yaWdpblk6IGZhbGxiYWNrT3JpZ2luWX0sXHJcbiAgICAgICAgICAgICAge292ZXJsYXlYOiBwb3NYLCBvdmVybGF5WTogZmFsbGJhY2tPdmVybGF5WX0pXHJcbiAgICAgICAgICAud2l0aEZhbGxiYWNrUG9zaXRpb24oXHJcbiAgICAgICAgICAgICAge29yaWdpblg6IGZhbGxiYWNrWCwgb3JpZ2luWTogZmFsbGJhY2tPcmlnaW5ZfSxcclxuICAgICAgICAgICAgICB7b3ZlcmxheVg6IGZhbGxiYWNrWCwgb3ZlcmxheVk6IGZhbGxiYWNrT3ZlcmxheVl9KVxyXG4gICAgICAgICAgLndpdGhPZmZzZXRYKG9mZnNldFgpXHJcbiAgICAgICAgICAud2l0aE9mZnNldFkob2Zmc2V0WSk7XHJcbiAgICAgICAgICAqL1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX2NsZWFuVXBTdWJzY3JpcHRpb25zKCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLl9iYWNrZHJvcFN1YnNjcmlwdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLl9iYWNrZHJvcFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fcG9zaXRpb25TdWJzY3JpcHRpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5fcG9zaXRpb25TdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgQEhvc3RMaXN0ZW5lcignbW91c2Vkb3duJykgX2hhbmRsZU1vdXNlZG93bihldmVudDogTW91c2VFdmVudCk6IHZvaWQge1xyXG4gICAgICAgIGlmIChldmVudCAmJiAhaXNGYWtlTW91c2Vkb3duRnJvbVNjcmVlblJlYWRlcihldmVudCkpIHtcclxuICAgICAgICAgICAgdGhpcy5fb3BlbmVkQnlNb3VzZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuXHJcbkBEaXJlY3RpdmUoe1xyXG4gIHNlbGVjdG9yOiAnbWRlLXBvcG92ZXItdGFyZ2V0LCBbbWRlUG9wb3ZlclRhcmdldF0nLFxyXG4gIGV4cG9ydEFzOiAnbWRlUG9wb3ZlclRhcmdldCdcclxufSlcclxuZXhwb3J0IGNsYXNzIE1kZVBvcG92ZXJUYXJnZXQgeyAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOmRpcmVjdGl2ZS1jbGFzcy1zdWZmaXhcclxuXHJcbiAgY29uc3RydWN0b3IocHVibGljIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmKSB7IH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcclxuXHJcbmltcG9ydCB7IE92ZXJsYXlNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jZGsvb3ZlcmxheSc7XHJcblxyXG5pbXBvcnQgeyBNZGVQb3BvdmVyIH0gZnJvbSAnLi9wb3BvdmVyJztcclxuaW1wb3J0IHsgTWRlUG9wb3ZlclRyaWdnZXIgfSBmcm9tICcuL3BvcG92ZXItdHJpZ2dlcic7XHJcbmltcG9ydCB7IE1kZVBvcG92ZXJUYXJnZXQgfSBmcm9tICcuL3BvcG92ZXItdGFyZ2V0JztcclxuXHJcbkBOZ01vZHVsZSh7XHJcbiAgaW1wb3J0czogW1xyXG4gICAgT3ZlcmxheU1vZHVsZSxcclxuICAgIENvbW1vbk1vZHVsZVxyXG4gIF0sXHJcbiAgZXhwb3J0czogW01kZVBvcG92ZXIsIE1kZVBvcG92ZXJUcmlnZ2VyLCBNZGVQb3BvdmVyVGFyZ2V0XSxcclxuICBkZWNsYXJhdGlvbnM6IFtNZGVQb3BvdmVyLCBNZGVQb3BvdmVyVHJpZ2dlciwgTWRlUG9wb3ZlclRhcmdldF0sXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBNZGVQb3BvdmVyTW9kdWxlIHt9XHJcbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFHQTtJQUNFLE1BQU0sS0FBSyxDQUFDLG1NQUkyQyxDQUFDLENBQUM7Q0FDMUQ7Ozs7OztBQU1EO0lBQ0UsTUFBTSxLQUFLLENBQUMsaUtBQ2dGLENBQUMsQ0FBQztDQUMvRjs7Ozs7O0FBTUQ7SUFDRSxNQUFNLEtBQUssQ0FBQywrSkFDK0UsQ0FBQyxDQUFDO0NBQzlGOzs7Ozs7QUMzQkQ7Ozs7Ozs7O0FBdUJBLHFCQUFhLGdCQUFnQixHQUE2QixPQUFPLENBQUMsa0JBQWtCLEVBQUU7SUFDcEYsS0FBSyxDQUFDLE9BQU8sRUFBRSxLQUFLLENBQUM7UUFDbkIsT0FBTyxFQUFFLENBQUM7UUFDVixTQUFTLEVBQUUsVUFBVTtLQUN0QixDQUFDLENBQUM7SUFDSCxVQUFVLENBQUMsV0FBVyxFQUFFO1FBQ3RCLEtBQUssQ0FBQztZQUNKLE9BQU8sRUFBRSxDQUFDO1lBQ1YsU0FBUyxFQUFFLFVBQVU7U0FDdEIsQ0FBQztRQUNGLE9BQU8sQ0FBQyx3Q0FBd0MsQ0FBQztLQUNsRCxDQUFDO0lBQ0YsVUFBVSxDQUFDLFdBQVcsRUFBRTtRQUN0QixPQUFPLENBQUMsbUJBQW1CLEVBQUUsS0FBSyxDQUFDLEVBQUMsT0FBTyxFQUFFLENBQUMsRUFBQyxDQUFDLENBQUM7S0FDbEQsQ0FBQztDQUNILENBQUM7Ozs7OztBQ3RDRjtJQWdORSxvQkFBb0IsV0FBdUI7UUFBdkIsZ0JBQVcsR0FBWCxXQUFXLENBQVk7O29CQS9KVixRQUFROzs7OzBCQUdDLE9BQU87MEJBQ1AsT0FBTzs2QkFDRCxPQUFPOzJCQUNqQyxHQUFHOzJCQUNILEdBQUc7K0JBQ0MsSUFBSTs4QkFDTCxDQUFDOzhCQUNELENBQUM7NkJBQ0YsRUFBRTsyQkFDSixDQUFDOzJCQUNELHFCQUFxQjs2QkFD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