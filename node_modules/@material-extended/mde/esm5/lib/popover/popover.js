/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import { Component, EventEmitter, Input, Output, TemplateRef, ViewChild, ViewEncapsulation, ElementRef, ChangeDetectionStrategy, HostBinding, } from '@angular/core';
import { ESCAPE } from '@angular/cdk/keycodes';
import { throwMdePopoverInvalidPositionX, throwMdePopoverInvalidPositionY } from './popover-errors';
import { transformPopover } from './popover-animations';
var MdePopover = /** @class */ (function () {
    function MdePopover(_elementRef) {
        this._elementRef = _elementRef;
        // tslint:disable-line:component-class-suffix
        this.role = 'dialog';
        /**
         * Settings for popover, view setters and getters for more detail
         */
        this._positionX = 'after';
        this._positionY = 'below';
        this._triggerEvent = 'hover';
        this._enterDelay = 200;
        this._leaveDelay = 200;
        this._overlapTrigger = true;
        this._targetOffsetX = 0;
        this._targetOffsetY = 0;
        this._arrowOffsetX = 20;
        this._arrowWidth = 8;
        this._arrowColor = 'rgba(0, 0, 0, 0.12)';
        this._closeOnClick = true;
        this._focusTrapEnabled = true;
        /**
         * Config object to be passed into the popover's ngClass
         */
        this._classList = {};
        /**
         *
         */
        this.containerPositioning = false;
        /**
         * Closing disabled on popover
         */
        this.closeDisabled = false;
        /**
         * Emits the current animation state whenever it changes.
         */
        this._onAnimationStateChange = new EventEmitter();
        /**
         * Event emitted when the popover is closed.
         */
        this.close = new EventEmitter();
        this.setPositionClasses();
    }
    Object.defineProperty(MdePopover.prototype, "positionX", {
        get: /**
         * Position of the popover in the X axis.
         * @return {?}
         */
        function () { return this._positionX; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value !== 'before' && value !== 'after') {
                throwMdePopoverInvalidPositionX();
            }
            this._positionX = value;
            this.setPositionClasses();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdePopover.prototype, "positionY", {
        get: /**
         * Position of the popover in the Y axis.
         * @return {?}
         */
        function () { return this._positionY; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value !== 'above' && value !== 'below') {
                throwMdePopoverInvalidPositionY();
            }
            this._positionY = value;
            this.setPositionClasses();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdePopover.prototype, "triggerEvent", {
        get: /**
         * Popover trigger event
         * @return {?}
         */
        function () { return this._triggerEvent; },
        set: /**
         * @param {?} v
         * @return {?}
         */
        function (v) { this._triggerEvent = v; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdePopover.prototype, "enterDelay", {
        get: /**
         * Popover enter delay
         * @return {?}
         */
        function () { return this._enterDelay; },
        set: /**
         * @param {?} v
         * @return {?}
         */
        function (v) { this._enterDelay = v; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdePopover.prototype, "leaveDelay", {
        get: /**
         * Popover leave delay
         * @return {?}
         */
        function () { return this._leaveDelay; },
        set: /**
         * @param {?} v
         * @return {?}
         */
        function (v) { this._leaveDelay = v; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdePopover.prototype, "overlapTrigger", {
        get: /**
         * Popover overlap trigger
         * @return {?}
         */
        function () { return this._overlapTrigger; },
        set: /**
         * @param {?} v
         * @return {?}
         */
        function (v) { this._overlapTrigger = v; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdePopover.prototype, "targetOffsetX", {
        get: /**
         * Popover target offset x
         * @return {?}
         */
        function () { return this._targetOffsetX; },
        set: /**
         * @param {?} v
         * @return {?}
         */
        function (v) { this._targetOffsetX = v; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdePopover.prototype, "targetOffsetY", {
        get: /**
         * Popover target offset y
         * @return {?}
         */
        function () { return this._targetOffsetY; },
        set: /**
         * @param {?} v
         * @return {?}
         */
        function (v) { this._targetOffsetY = v; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdePopover.prototype, "arrowOffsetX", {
        get: /**
         * Popover arrow offset x
         * @return {?}
         */
        function () { return this._arrowOffsetX; },
        set: /**
         * @param {?} v
         * @return {?}
         */
        function (v) { this._arrowOffsetX = v; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdePopover.prototype, "arrowWidth", {
        get: /**
         * Popover arrow width
         * @return {?}
         */
        function () { return this._arrowWidth; },
        set: /**
         * @param {?} v
         * @return {?}
         */
        function (v) { this._arrowWidth = v; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdePopover.prototype, "arrowColor", {
        get: /**
         * Popover arrow color
         * @return {?}
         */
        function () { return this._arrowColor; },
        set: /**
         * @param {?} v
         * @return {?}
         */
        function (v) { this._arrowColor = v; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdePopover.prototype, "closeOnClick", {
        get: /**
         * Popover container close on click
         * default: true
         * @return {?}
         */
        function () { return this._closeOnClick; },
        set: /**
         * @param {?} v
         * @return {?}
         */
        function (v) { this._closeOnClick = v; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdePopover.prototype, "focusTrapEnabled", {
        get: /**
         * Popover focus trap using cdkTrapFocus
         * default: true
         * @return {?}
         */
        function () { return this._focusTrapEnabled; },
        set: /**
         * @param {?} v
         * @return {?}
         */
        function (v) { this._focusTrapEnabled = v; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdePopover.prototype, "panelClass", {
        set: /**
         * This method takes classes set on the host md-popover element and applies them on the
         * popover template that displays in the overlay container.  Otherwise, it's difficult
         * to style the containing popover from outside the component.
         * @param {?} classes list of class names
         * @return {?}
         */
        function (classes) {
            if (classes && classes.length) {
                this._classList = classes.split(' ').reduce(function (obj, className) {
                    obj[className] = true;
                    return obj;
                }, {});
                this._elementRef.nativeElement.className = '';
                this.setPositionClasses();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdePopover.prototype, "classList", {
        get: /**
         * This method takes classes set on the host md-popover element and applies them on the
         * popover template that displays in the overlay container.  Otherwise, it's difficult
         * to style the containing popover from outside the component.
         * @deprecated Use `panelClass` instead.
         * @return {?}
         */
        function () { return this.panelClass; },
        set: /**
         * @param {?} classes
         * @return {?}
         */
        function (classes) { this.panelClass = classes; },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    MdePopover.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._emitCloseEvent();
        this.close.complete();
    };
    /** Handle a keyboard event from the popover, delegating to the appropriate action. */
    /**
     * Handle a keyboard event from the popover, delegating to the appropriate action.
     * @param {?} event
     * @return {?}
     */
    MdePopover.prototype._handleKeydown = /**
     * Handle a keyboard event from the popover, delegating to the appropriate action.
     * @param {?} event
     * @return {?}
     */
    function (event) {
        switch (event.keyCode) {
            case ESCAPE:
                this._emitCloseEvent();
                return;
        }
    };
    /**
     * This emits a close event to which the trigger is subscribed. When emitted, the
     * trigger will close the popover.
     */
    /**
     * This emits a close event to which the trigger is subscribed. When emitted, the
     * trigger will close the popover.
     * @return {?}
     */
    MdePopover.prototype._emitCloseEvent = /**
     * This emits a close event to which the trigger is subscribed. When emitted, the
     * trigger will close the popover.
     * @return {?}
     */
    function () {
        this.close.emit();
    };
    /** Close popover on click if closeOnClick is true */
    /**
     * Close popover on click if closeOnClick is true
     * @return {?}
     */
    MdePopover.prototype.onClick = /**
     * Close popover on click if closeOnClick is true
     * @return {?}
     */
    function () {
        if (this.closeOnClick) {
            this._emitCloseEvent();
        }
    };
    /**
     * TODO: Refactor when @angular/cdk includes feature I mentioned on github see link below.
     * https://github.com/angular/material2/pull/5493#issuecomment-313085323
     */
    /** Disables close of popover when leaving trigger element and mouse over the popover */
    /**
     * Disables close of popover when leaving trigger element and mouse over the popover
     * @return {?}
     */
    MdePopover.prototype.onMouseOver = /**
     * Disables close of popover when leaving trigger element and mouse over the popover
     * @return {?}
     */
    function () {
        if (this.triggerEvent === 'hover') {
            this.closeDisabled = true;
        }
    };
    /** Enables close of popover when mouse leaving popover element */
    /**
     * Enables close of popover when mouse leaving popover element
     * @return {?}
     */
    MdePopover.prototype.onMouseLeave = /**
     * Enables close of popover when mouse leaving popover element
     * @return {?}
     */
    function () {
        if (this.triggerEvent === 'hover') {
            this.closeDisabled = false;
            this._emitCloseEvent();
        }
    };
    // TODO: Refactor how styles are set and updated on the component, use best practices.
    // TODO: If arrow left and right positioning is requested, see if flex direction can be used to work with order.
    /** Sets the current styles for the popover to allow for dynamically changing settings */
    /**
     * Sets the current styles for the popover to allow for dynamically changing settings
     * @return {?}
     */
    MdePopover.prototype.setCurrentStyles = /**
     * Sets the current styles for the popover to allow for dynamically changing settings
     * @return {?}
     */
    function () {
        // TODO: See if arrow position can be calculated automatically and allow override.
        // TODO: See if flex order is a better alternative to position arrow top or bottom.
        this.popoverArrowStyles = {
            'right': this.positionX === 'before' ? (this.arrowOffsetX - this.arrowWidth) + 'px' : '',
            'left': this.positionX === 'after' ? (this.arrowOffsetX - this.arrowWidth) + 'px' : '',
            'border-top': this.positionY === 'below' ?
                this.arrowWidth + 'px solid ' + this.arrowColor : '0px solid transparent',
            'border-right': 'undefined' === undefined ?
                this.arrowWidth + 'px solid ' + this.arrowColor :
                this.arrowWidth + 'px solid transparent',
            'border-bottom': this.positionY === 'above' ?
                this.arrowWidth + 'px solid ' + this.arrowColor :
                this.arrowWidth + 'px solid transparent',
            'border-left': 'undefined' === undefined ?
                this.arrowWidth + 'px solid ' + this.arrowColor :
                this.arrowWidth + 'px solid transparent',
        };
        // TODO: Remove if flex order is added.
        this.popoverContentStyles = {
            'padding-top': this.overlapTrigger === true ? '0px' : this.arrowWidth + 'px',
            'padding-bottom': this.overlapTrigger === true ? '0px' : (this.arrowWidth) + 'px',
            'margin-top': this.overlapTrigger === false && this.positionY === 'below' && this.containerPositioning === false ?
                -(this.arrowWidth * 2) + 'px' : '0px'
        };
    };
    /**
     * It's necessary to set position-based classes to ensure the popover panel animation
     * folds out from the correct direction.
     */
    /**
     * It's necessary to set position-based classes to ensure the popover panel animation
     * folds out from the correct direction.
     * @param {?=} posX
     * @param {?=} posY
     * @return {?}
     */
    MdePopover.prototype.setPositionClasses = /**
     * It's necessary to set position-based classes to ensure the popover panel animation
     * folds out from the correct direction.
     * @param {?=} posX
     * @param {?=} posY
     * @return {?}
     */
    function (posX, posY) {
        if (posX === void 0) { posX = this.positionX; }
        if (posY === void 0) { posY = this.positionY; }
        this._classList['mde-popover-before'] = posX === 'before';
        this._classList['mde-popover-after'] = posX === 'after';
        this._classList['mde-popover-above'] = posY === 'above';
        this._classList['mde-popover-below'] = posY === 'below';
    };
    MdePopover.decorators = [
        { type: Component, args: [{
                    selector: 'mde-popover',
                    template: "<ng-template>\n  <div class=\"mde-popover-panel\" role=\"dialog\" [class.mde-popover-overlap]=\"overlapTrigger\"\n       [ngClass]=\"_classList\" [ngStyle]=\"popoverPanelStyles\" (keydown)=\"_handleKeydown($event)\"\n       (click)=\"onClick()\" (mouseover)=\"onMouseOver()\" (mouseleave)=\"onMouseLeave()\"\n       [@transformPopover]=\"'enter'\">\n    <div class=\"mde-popover-direction-arrow\" [ngStyle]=\"popoverArrowStyles\" *ngIf=\"!overlapTrigger\"></div>\n    <div class=\"mde-popover-content\" [ngStyle]=\"popoverContentStyles\" cdkTrapFocus=\"focusTrapEnabled\">\n      <ng-content></ng-content>\n    </div>\n  </div>\n</ng-template>\n",
                    styles: [".mde-popover-panel{display:flex;flex-direction:column;max-height:calc(100vh + 48px)}.mde-popover-ripple{position:absolute;top:0;left:0;bottom:0;right:0}.mde-popover-below .mde-popover-direction-arrow{position:absolute;bottom:0;width:0;height:0;border-bottom-width:0!important;z-index:99999}.mde-popover-above .mde-popover-direction-arrow{position:absolute;top:0;width:0;height:0;border-top-width:0!important;z-index:99999}.mde-popover-after .mde-popover-direction-arrow{left:20px}.mde-popover-before .mde-popover-direction-arrow{right:20px}"],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    encapsulation: ViewEncapsulation.None,
                    animations: [
                        transformPopover
                    ],
                    exportAs: 'mdePopover'
                },] },
    ];
    /** @nocollapse */
    MdePopover.ctorParameters = function () { return [
        { type: ElementRef, },
    ]; };
    MdePopover.propDecorators = {
        "role": [{ type: HostBinding, args: ['attr.role',] },],
        "positionX": [{ type: Input, args: ['mdePopoverPositionX',] },],
        "positionY": [{ type: Input, args: ['mdePopoverPositionY',] },],
        "triggerEvent": [{ type: Input, args: ['mdePopoverTriggerOn',] },],
        "enterDelay": [{ type: Input, args: ['mdePopoverEnterDelay',] },],
        "leaveDelay": [{ type: Input, args: ['mdePopoverLeaveDelay',] },],
        "overlapTrigger": [{ type: Input, args: ['mdePopoverOverlapTrigger',] },],
        "targetOffsetX": [{ type: Input, args: ['mdePopoverOffsetX',] },],
        "targetOffsetY": [{ type: Input, args: ['mdePopoverOffsetY',] },],
        "arrowOffsetX": [{ type: Input, args: ['mdePopoverArrowOffsetX',] },],
        "arrowWidth": [{ type: Input, args: ['mdePopoverArrowWidth',] },],
        "arrowColor": [{ type: Input, args: ['mdePopoverArrowColor',] },],
        "closeOnClick": [{ type: Input, args: ['mdePopoverCloseOnClick',] },],
        "focusTrapEnabled": [{ type: Input, args: ['mdeFocusTrapEnabled',] },],
        "panelClass": [{ type: Input, args: ['class',] },],
        "classList": [{ type: Input },],
        "close": [{ type: Output },],
        "templateRef": [{ type: ViewChild, args: [TemplateRef,] },],
    };
    return MdePopover;
}());
export { MdePopover };
function MdePopover_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    MdePopover.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    MdePopover.ctorParameters;
    /** @type {!Object<string,!Array<{type: !Function, args: (undefined|!Array<?>)}>>} */
    MdePopover.propDecorators;
    /** @type {?} */
    MdePopover.prototype.role;
    /**
     * Settings for popover, view setters and getters for more detail
     * @type {?}
     */
    MdePopover.prototype._positionX;
    /** @type {?} */
    MdePopover.prototype._positionY;
    /** @type {?} */
    MdePopover.prototype._triggerEvent;
    /** @type {?} */
    MdePopover.prototype._enterDelay;
    /** @type {?} */
    MdePopover.prototype._leaveDelay;
    /** @type {?} */
    MdePopover.prototype._overlapTrigger;
    /** @type {?} */
    MdePopover.prototype._targetOffsetX;
    /** @type {?} */
    MdePopover.prototype._targetOffsetY;
    /** @type {?} */
    MdePopover.prototype._arrowOffsetX;
    /** @type {?} */
    MdePopover.prototype._arrowWidth;
    /** @type {?} */
    MdePopover.prototype._arrowColor;
    /** @type {?} */
    MdePopover.prototype._closeOnClick;
    /** @type {?} */
    MdePopover.prototype._focusTrapEnabled;
    /**
     * Config object to be passed into the popover's ngClass
     * @type {?}
     */
    MdePopover.prototype._classList;
    /**
     *
     * @type {?}
     */
    MdePopover.prototype.containerPositioning;
    /**
     * Closing disabled on popover
     * @type {?}
     */
    MdePopover.prototype.closeDisabled;
    /**
     * Config object to be passed into the popover's arrow ngStyle
     * @type {?}
     */
    MdePopover.prototype.popoverPanelStyles;
    /**
     * Config object to be passed into the popover's arrow ngStyle
     * @type {?}
     */
    MdePopover.prototype.popoverArrowStyles;
    /**
     * Config object to be passed into the popover's content ngStyle
     * @type {?}
     */
    MdePopover.prototype.popoverContentStyles;
    /**
     * Emits the current animation state whenever it changes.
     * @type {?}
     */
    MdePopover.prototype._onAnimationStateChange;
    /**
     * Event emitted when the popover is closed.
     * @type {?}
     */
    MdePopover.prototype.close;
    /** @type {?} */
    MdePopover.prototype.templateRef;
    /** @type {?} */
    MdePopover.prototype._elementRef;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9wb3Zlci5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BtYXRlcmlhbC1leHRlbmRlZC9tZGUvIiwic291cmNlcyI6WyJsaWIvcG9wb3Zlci9wb3BvdmVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQ0wsU0FBUyxFQUNULFlBQVksRUFDWixLQUFLLEVBRUwsTUFBTSxFQUNOLFdBQVcsRUFDWCxTQUFTLEVBQ1QsaUJBQWlCLEVBQ2pCLFVBQVUsRUFDVix1QkFBdUIsRUFDdkIsV0FBVyxHQUNaLE1BQU0sZUFBZSxDQUFDO0FBRXZCLE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUcvQyxPQUFPLEVBQUUsK0JBQStCLEVBQUUsK0JBQStCLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUVwRyxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQzs7SUE2THRELG9CQUFvQixXQUF1QjtRQUF2QixnQkFBVyxHQUFYLFdBQVcsQ0FBWTs7b0JBL0pWLFFBQVE7Ozs7MEJBR0MsT0FBTzswQkFDUCxPQUFPOzZCQUNELE9BQU87MkJBQ2pDLEdBQUc7MkJBQ0gsR0FBRzsrQkFDQyxJQUFJOzhCQUNMLENBQUM7OEJBQ0QsQ0FBQzs2QkFDRixFQUFFOzJCQUNKLENBQUM7MkJBQ0QscUJBQXFCOzZCQUNuQixJQUFJO2lDQUNBLElBQUk7Ozs7MEJBR08sRUFBRTs7OztvQ0FJWCxLQUFLOzs7OzZCQUdaLEtBQUs7Ozs7dUNBWUYsSUFBSSxZQUFZLEVBQWtCOzs7O3FCQXNIMUMsSUFBSSxZQUFZLEVBQVE7UUFLeEMsSUFBSSxDQUFDLGtCQUFrQixFQUFFLENBQUM7S0FDM0I7MEJBdkhHLGlDQUFTOzs7OztzQkFBSyxNQUFNLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQzs7Ozs7UUFDekMsVUFBYyxLQUEwQjtZQUN0QyxFQUFFLENBQUMsQ0FBQyxLQUFLLEtBQUssUUFBUSxJQUFJLEtBQUssS0FBSyxPQUFPLENBQUMs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c291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcclxuICBDb21wb25lbnQsXHJcbiAgRXZlbnRFbWl0dGVyLFxyXG4gIElucHV0LFxyXG4gIE9uRGVzdHJveSxcclxuICBPdXRwdXQsXHJcbiAgVGVtcGxhdGVSZWYsXHJcbiAgVmlld0NoaWxkLFxyXG4gIFZpZXdFbmNhcHN1bGF0aW9uLFxyXG4gIEVsZW1lbnRSZWYsXHJcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXHJcbiAgSG9zdEJpbmRpbmcsXHJcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcblxyXG5pbXBvcnQgeyBFU0NBUEUgfSBmcm9tICdAYW5ndWxhci9jZGsva2V5Y29kZXMnO1xyXG5cclxuaW1wb3J0IHsgTWRlUG9wb3ZlclBvc2l0aW9uWCwgTWRlUG9wb3ZlclBvc2l0aW9uWSwgTWRlUG9wb3ZlclRyaWdnZXJFdmVudCB9IGZyb20gJy4vcG9wb3Zlci10eXBlcyc7XHJcbmltcG9ydCB7IHRocm93TWRlUG9wb3ZlckludmFsaWRQb3NpdGlvblgsIHRocm93TWRlUG9wb3ZlckludmFsaWRQb3NpdGlvblkgfSBmcm9tICcuL3BvcG92ZXItZXJyb3JzJztcclxuaW1wb3J0IHsgTWRlUG9wb3ZlclBhbmVsIH0gZnJvbSAnLi9wb3BvdmVyLWludGVyZmFjZXMnO1xyXG5pbXBvcnQgeyB0cmFuc2Zvcm1Qb3BvdmVyIH0gZnJvbSAnLi9wb3BvdmVyLWFuaW1hdGlvbnMnO1xyXG5cclxuaW1wb3J0IHsgQW5pbWF0aW9uRXZlbnQgfSBmcm9tICdAYW5ndWxhci9hbmltYXRpb25zJztcclxuXHJcblxyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgc2VsZWN0b3I6ICdtZGUtcG9wb3ZlcicsXHJcbiAgdGVtcGxhdGU6IGA8bmctdGVtcGxhdGU+XHJcbiAgPGRpdiBjbGFzcz1cIm1kZS1wb3BvdmVyLXBhbmVsXCIgcm9sZT1cImRpYWxvZ1wiIFtjbGFzcy5tZGUtcG9wb3Zlci1vdmVybGFwXT1cIm92ZXJsYXBUcmlnZ2VyXCJcclxuICAgICAgIFtuZ0NsYXNzXT1cIl9jbGFzc0xpc3RcIiBbbmdTdHlsZV09XCJwb3BvdmVyUGFuZWxTdHlsZXNcIiAoa2V5ZG93bik9XCJfaGFuZGxlS2V5ZG93bigkZXZlbnQpXCJcclxuICAgICAgIChjbGljayk9XCJvbkNsaWNrKClcIiAobW91c2VvdmVyKT1cIm9uTW91c2VPdmVyKClcIiAobW91c2VsZWF2ZSk9XCJvbk1vdXNlTGVhdmUoKVwiXHJcbiAgICAgICBbQHRyYW5zZm9ybVBvcG92ZXJdPVwiJ2VudGVyJ1wiPlxyXG4gICAgPGRpdiBjbGFzcz1cIm1kZS1wb3BvdmVyLWRpcmVjdGlvbi1hcnJvd1wiIFtuZ1N0eWxlXT1cInBvcG92ZXJBcnJvd1N0eWxlc1wiICpuZ0lmPVwiIW92ZXJsYXBUcmlnZ2VyXCI+PC9kaXY+XHJcbiAgICA8ZGl2IGNsYXNzPVwibWRlLXBvcG92ZXItY29udGVudFwiIFtuZ1N0eWxlXT1cInBvcG92ZXJDb250ZW50U3R5bGVzXCIgY2RrVHJhcEZvY3VzPVwiZm9jdXNUcmFwRW5hYmxlZFwiPlxyXG4gICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XHJcbiAgICA8L2Rpdj5cclxuICA8L2Rpdj5cclxuPC9uZy10ZW1wbGF0ZT5cclxuYCxcclxuICBzdHlsZXM6IFtgLm1kZS1wb3BvdmVyLXBhbmVse2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW47bWF4LWhlaWdodDpjYWxjKDEwMHZoICsgNDhweCl9Lm1kZS1wb3BvdmVyLXJpcHBsZXtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0OjA7Ym90dG9tOjA7cmlnaHQ6MH0ubWRlLXBvcG92ZXItYmVsb3cgLm1kZS1wb3BvdmVyLWRpcmVjdGlvbi1hcnJvd3twb3NpdGlvbjphYnNvbHV0ZTtib3R0b206MDt3aWR0aDowO2hlaWdodDowO2JvcmRlci1ib3R0b20td2lkdGg6MCFpbXBvcnRhbnQ7ei1pbmRleDo5OTk5OX0ubWRlLXBvcG92ZXItYWJvdmUgLm1kZS1wb3BvdmVyLWRpcmVjdGlvbi1hcnJvd3twb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDt3aWR0aDowO2hlaWdodDowO2JvcmRlci10b3Atd2lkdGg6MCFpbXBvcnRhbnQ7ei1pbmRleDo5OTk5OX0ubWRlLXBvcG92ZXItYWZ0ZXIgLm1kZS1wb3BvdmVyLWRpcmVjdGlvbi1hcnJvd3tsZWZ0OjIwcHh9Lm1kZS1wb3BvdmVyLWJlZm9yZSAubWRlLXBvcG92ZXItZGlyZWN0aW9uLWFycm93e3JpZ2h0OjIwcHh9YF0sXHJcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXHJcbiAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcclxuICBhbmltYXRpb25zOiBbXHJcbiAgICB0cmFuc2Zvcm1Qb3BvdmVyXHJcbiAgXSxcclxuICBleHBvcnRBczogJ21kZVBvcG92ZXInXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBNZGVQb3BvdmVyIGltcGxlbWVudHMgTWRlUG9wb3ZlclBhbmVsLCBPbkRlc3Ryb3kgeyAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOmNvbXBvbmVudC1jbGFzcy1zdWZmaXhcclxuXHJcbiAgQEhvc3RCaW5kaW5nKCdhdHRyLnJvbGUnKSByb2xlID0gJ2RpYWxvZyc7XHJcblxyXG4gIC8qKiBTZXR0aW5ncyBmb3IgcG9wb3ZlciwgdmlldyBzZXR0ZXJzIGFuZCBnZXR0ZXJzIGZvciBtb3JlIGRldGFpbCAqL1xyXG4gIHByaXZhdGUgX3Bvc2l0aW9uWDogTWRlUG9wb3ZlclBvc2l0aW9uWCA9ICdhZnRlcic7XHJcbiAgcHJpdmF0ZSBfcG9zaXRpb25ZOiBNZGVQb3BvdmVyUG9zaXRpb25ZID0gJ2JlbG93JztcclxuICBwcml2YXRlIF90cmlnZ2VyRXZlbnQ6IE1kZVBvcG92ZXJUcmlnZ2VyRXZlbnQgPSAnaG92ZXInO1xyXG4gIHByaXZhdGUgX2VudGVyRGVsYXkgPSAyMDA7XHJcbiAgcHJpdmF0ZSBfbGVhdmVEZWxheSA9IDIwMDtcclxuICBwcml2YXRlIF9vdmVybGFwVHJpZ2dlciA9IHRydWU7XHJcbiAgcHJpdmF0ZSBfdGFyZ2V0T2Zmc2V0WCA9IDA7XHJcbiAgcHJpdmF0ZSBfdGFyZ2V0T2Zmc2V0WSA9IDA7XHJcbiAgcHJpdmF0ZSBfYXJyb3dPZmZzZXRYID0gMjA7XHJcbiAgcHJpdmF0ZSBfYXJyb3dXaWR0aCA9IDg7XHJcbiAgcHJpdmF0ZSBfYXJyb3dDb2xvciA9ICdyZ2JhKDAsIDAsIDAsIDAuMTIpJztcclxuICBwcml2YXRlIF9jbG9zZU9uQ2xpY2sgPSB0cnVlO1xyXG4gIHByaXZhdGUgX2ZvY3VzVHJhcEVuYWJsZWQgPSB0cnVlO1xyXG5cclxuICAvKiogQ29uZmlnIG9iamVjdCB0byBiZSBwYXNzZWQgaW50byB0aGUgcG9wb3ZlcidzIG5nQ2xhc3MgKi9cclxuICBfY2xhc3NMaXN0OiB7W2tleTogc3RyaW5nXTogYm9vbGVhbn0gPSB7fTtcclxuXHJcbiAgLy8gVE9ETzogV3JpdGUgY29tbWVudCBkZXNjcmlwdGlvblxyXG4gIC8qKiAqL1xyXG4gIHB1YmxpYyBjb250YWluZXJQb3NpdGlvbmluZyA9IGZhbHNlO1xyXG5cclxuICAvKiogQ2xvc2luZyBkaXNhYmxlZCBvbiBwb3BvdmVyICovXHJcbiAgcHVibGljIGNsb3NlRGlzYWJsZWQgPSBmYWxzZTtcclxuXHJcbiAgLyoqIENvbmZpZyBvYmplY3QgdG8gYmUgcGFzc2VkIGludG8gdGhlIHBvcG92ZXIncyBhcnJvdyBuZ1N0eWxlICovXHJcbiAgcHVibGljIHBvcG92ZXJQYW5lbFN0eWxlczoge307XHJcblxyXG4gIC8qKiBDb25maWcgb2JqZWN0IHRvIGJlIHBhc3NlZCBpbnRvIHRoZSBwb3BvdmVyJ3MgYXJyb3cgbmdTdHlsZSAqL1xyXG4gIHB1YmxpYyBwb3BvdmVyQXJyb3dTdHlsZXM6IHt9O1xyXG5cclxuICAvKiogQ29uZmlnIG9iamVjdCB0byBiZSBwYXNzZWQgaW50byB0aGUgcG9wb3ZlcidzIGNvbnRlbnQgbmdTdHlsZSAqL1xyXG4gIHB1YmxpYyBwb3BvdmVyQ29udGVudFN0eWxlczoge307XHJcblxyXG4gIC8qKiBFbWl0cyB0aGUgY3VycmVudCBhbmltYXRpb24gc3RhdGUgd2hlbmV2ZXIgaXQgY2hhbmdlcy4gKi9cclxuICBfb25BbmltYXRpb25TdGF0ZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8QW5pbWF0aW9uRXZlbnQ+KCk7XHJcblxyXG5cclxuICAvKiogUG9zaXRpb24gb2YgdGhlIHBvcG92ZXIgaW4gdGhlIFggYXhpcy4gKi9cclxuICBASW5wdXQoJ21kZVBvcG92ZXJQb3NpdGlvblgnKVxyXG4gIGdldCBwb3NpdGlvblgoKSB7IHJldHVybiB0aGlzLl9wb3NpdGlvblg7IH1cclxuICBzZXQgcG9zaXRpb25YKHZhbHVlOiBNZGVQb3BvdmVyUG9zaXRpb25YKSB7XHJcbiAgICBpZiAodmFsdWUgIT09ICdiZWZvcmUnICYmIHZhbHVlICE9PSAnYWZ0ZXInKSB7XHJcbiAgICAgIHRocm93TWRlUG9wb3ZlckludmFsaWRQb3NpdGlvblgoKTtcclxuICAgIH1cclxuICAgIHRoaXMuX3Bvc2l0aW9uWCA9IHZhbHVlO1xyXG4gICAgdGhpcy5zZXRQb3NpdGlvbkNsYXNzZXMoKTtcclxuICB9XHJcblxyXG4gIC8qKiBQb3NpdGlvbiBvZiB0aGUgcG9wb3ZlciBpbiB0aGUgWSBheGlzLiAqL1xyXG4gIEBJbnB1dCgnbWRlUG9wb3ZlclBvc2l0aW9uWScpXHJcbiAgZ2V0IHBvc2l0aW9uWSgpIHsgcmV0dXJuIHRoaXMuX3Bvc2l0aW9uWTsgfVxyXG4gIHNldCBwb3NpdGlvblkodmFsdWU6IE1kZVBvcG92ZXJQb3NpdGlvblkpIHtcclxuICAgIGlmICh2YWx1ZSAhPT0gJ2Fib3ZlJyAmJiB2YWx1ZSAhPT0gJ2JlbG93Jykge1xyXG4gICAgICB0aHJvd01kZVBvcG92ZXJJbnZhbGlkUG9zaXRpb25ZKCk7XHJcbiAgICB9XHJcbiAgICB0aGlzLl9wb3NpdGlvblkgPSB2YWx1ZTtcclxuICAgIHRoaXMuc2V0UG9zaXRpb25DbGFzc2VzKCk7XHJcbiAgfVxyXG5cclxuICAvKiogUG9wb3ZlciB0cmlnZ2VyIGV2ZW50ICovXHJcbiAgQElucHV0KCdtZGVQb3BvdmVyVHJpZ2dlck9uJylcclxuICBnZXQgdHJpZ2dlckV2ZW50KCk6IE1kZVBvcG92ZXJUcmlnZ2VyRXZlbnQgeyByZXR1cm4gdGhpcy5fdHJpZ2dlckV2ZW50OyB9XHJcbiAgc2V0IHRyaWdnZXJFdmVudCh2OiBNZGVQb3BvdmVyVHJpZ2dlckV2ZW50KSB7IHRoaXMuX3RyaWdnZXJFdmVudCA9IHY7IH1cclxuXHJcbiAgLyoqIFBvcG92ZXIgZW50ZXIgZGVsYXkgKi9cclxuICBASW5wdXQoJ21kZVBvcG92ZXJFbnRlckRlbGF5JylcclxuICBnZXQgZW50ZXJEZWxheSgpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5fZW50ZXJEZWxheTsgfVxyXG4gIHNldCBlbnRlckRlbGF5KHY6IG51bWJlcikgeyB0aGlzLl9lbnRlckRlbGF5ID0gdjsgfVxyXG5cclxuICAvKiogUG9wb3ZlciBsZWF2ZSBkZWxheSAqL1xyXG4gIEBJbnB1dCgnbWRlUG9wb3ZlckxlYXZlRGVsYXknKVxyXG4gIGdldCBsZWF2ZURlbGF5KCk6IG51bWJlciB7IHJldHVybiB0aGlzLl9sZWF2ZURlbGF5OyB9XHJcbiAgc2V0IGxlYXZlRGVsYXkodjogbnVtYmVyKSB7IHRoaXMuX2xlYXZlRGVsYXkgPSB2OyB9XHJcblxyXG4gIC8qKiBQb3BvdmVyIG92ZXJsYXAgdHJpZ2dlciAqL1xyXG4gIEBJbnB1dCgnbWRlUG9wb3Zlck92ZXJsYXBUcmlnZ2VyJylcclxuICBnZXQgb3ZlcmxhcFRyaWdnZXIoKTogYm9vbGVhbiB7IHJldHVybiB0aGlzLl9vdmVybGFwVHJpZ2dlcjsgfVxyXG4gIHNldCBvdmVybGFwVHJpZ2dlcih2OiBib29sZWFuKSB7IHRoaXMuX292ZXJsYXBUcmlnZ2VyID0gdjsgfVxyXG5cclxuICAvKiogUG9wb3ZlciB0YXJnZXQgb2Zmc2V0IHggKi9cclxuICBASW5wdXQoJ21kZVBvcG92ZXJPZmZzZXRYJylcclxuICBnZXQgdGFyZ2V0T2Zmc2V0WCgpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5fdGFyZ2V0T2Zmc2V0WDsgfVxyXG4gIHNldCB0YXJnZXRPZmZzZXRYKHY6IG51bWJlcikgeyB0aGlzLl90YXJnZXRPZmZzZXRYID0gdjsgfVxyXG5cclxuICAvKiogUG9wb3ZlciB0YXJnZXQgb2Zmc2V0IHkgKi9cclxuICBASW5wdXQoJ21kZVBvcG92ZXJPZmZzZXRZJylcclxuICBnZXQgdGFyZ2V0T2Zmc2V0WSgpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5fdGFyZ2V0T2Zmc2V0WTsgfVxyXG4gIHNldCB0YXJnZXRPZmZzZXRZKHY6IG51bWJlcikgeyB0aGlzLl90YXJnZXRPZmZzZXRZID0gdjsgfVxyXG5cclxuICAvKiogUG9wb3ZlciBhcnJvdyBvZmZzZXQgeCAqL1xyXG4gIEBJbnB1dCgnbWRlUG9wb3ZlckFycm93T2Zmc2V0WCcpXHJcbiAgZ2V0IGFycm93T2Zmc2V0WCgpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5fYXJyb3dPZmZzZXRYOyB9XHJcbiAgc2V0IGFycm93T2Zmc2V0WCh2OiBudW1iZXIpIHsgdGhpcy5fYXJyb3dPZmZzZXRYID0gdjsgfVxyXG5cclxuICAvKiogUG9wb3ZlciBhcnJvdyB3aWR0aCAqL1xyXG4gIEBJbnB1dCgnbWRlUG9wb3ZlckFycm93V2lkdGgnKVxyXG4gIGdldCBhcnJvd1dpZHRoKCk6IG51bWJlciB7IHJldHVybiB0aGlzLl9hcnJvd1dpZHRoOyB9XHJcbiAgc2V0IGFycm93V2lkdGgodjogbnVtYmVyKSB7IHRoaXMuX2Fycm93V2lkdGggPSB2OyB9XHJcblxyXG4gIC8qKiBQb3BvdmVyIGFycm93IGNvbG9yICovXHJcbiAgQElucHV0KCdtZGVQb3BvdmVyQXJyb3dDb2xvcicpXHJcbiAgZ2V0IGFycm93Q29sb3IoKTogc3RyaW5nIHsgcmV0dXJuIHRoaXMuX2Fycm93Q29sb3I7IH1cclxuICBzZXQgYXJyb3dDb2xvcih2OiBzdHJpbmcpIHsgdGhpcy5fYXJyb3dDb2xvciA9IHY7IH1cclxuXHJcbiAgLyoqXHJcbiAgICogUG9wb3ZlciBjb250YWluZXIgY2xvc2Ugb24gY2xpY2tcclxuICAgKiBkZWZhdWx0OiB0cnVlXHJcbiAgICovXHJcbiAgQElucHV0KCdtZGVQb3BvdmVyQ2xvc2VPbkNsaWNrJylcclxuICBnZXQgY2xvc2VPbkNsaWNrKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5fY2xvc2VPbkNsaWNrOyB9XHJcbiAgc2V0IGNsb3NlT25DbGljayh2OiBib29sZWFuKSB7IHRoaXMuX2Nsb3NlT25DbGljayA9IHY7IH1cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIFBvcG92ZXIgZm9jdXMgdHJhcCB1c2luZyBjZGtUcmFwRm9jdXNcclxuICAgKiBkZWZhdWx0OiB0cnVlXHJcbiAgICovXHJcbiAgQElucHV0KCdtZGVGb2N1c1RyYXBFbmFibGVkJylcclxuICBnZXQgZm9jdXNUcmFwRW5hYmxlZCgpOiBib29sZWFuIHsgcmV0dXJuIHRoaXMuX2ZvY3VzVHJhcEVuYWJsZWQ7IH1cclxuICBzZXQgZm9jdXNUcmFwRW5hYmxlZCh2OiBib29sZWFuKSB7IHRoaXMuX2ZvY3VzVHJhcEVuYWJsZWQgPSB2OyB9XHJcblxyXG5cclxuICAvKipcclxuICAgKiBUaGlzIG1ldGhvZCB0YWtlcyBjbGFzc2VzIHNldCBvbiB0aGUgaG9zdCBtZC1wb3BvdmVyIGVsZW1lbnQgYW5kIGFwcGxpZXMgdGhlbSBvbiB0aGVcclxuICAgKiBwb3BvdmVyIHRlbXBsYXRlIHRoYXQgZGlzcGxheXMgaW4gdGhlIG92ZXJsYXkgY29udGFpbmVyLiAgT3RoZXJ3aXNlLCBpdCdzIGRpZmZpY3VsdFxyXG4gICAqIHRvIHN0eWxlIHRoZSBjb250YWluaW5nIHBvcG92ZXIgZnJvbSBvdXRzaWRlIHRoZSBjb21wb25lbnQuXHJcbiAgICogQHBhcmFtIGNsYXNzZXMgbGlzdCBvZiBjbGFzcyBuYW1lc1xyXG4gICAqL1xyXG4gIEBJbnB1dCgnY2xhc3MnKVxyXG4gIHNldCBwYW5lbENsYXNzKGNsYXNzZXM6IHN0cmluZykge1xyXG4gICAgaWYgKGNsYXNzZXMgJiYgY2xhc3Nlcy5sZW5ndGgpIHtcclxuICAgICAgdGhpcy5fY2xhc3NMaXN0ID0gY2xhc3Nlcy5zcGxpdCgnICcpLnJlZHVjZSgob2JqOiBhbnksIGNsYXNzTmFtZTogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgb2JqW2NsYXNzTmFtZV0gPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiBvYmo7XHJcbiAgICAgIH0sIHt9KTtcclxuXHJcbiAgICAgIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5jbGFzc05hbWUgPSAnJztcclxuICAgICAgdGhpcy5zZXRQb3NpdGlvbkNsYXNzZXMoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgbWV0aG9kIHRha2VzIGNsYXNzZXMgc2V0IG9uIHRoZSBob3N0IG1kLXBvcG92ZXIgZWxlbWVudCBhbmQgYXBwbGllcyB0aGVtIG9uIHRoZVxyXG4gICAqIHBvcG92ZXIgdGVtcGxhdGUgdGhhdCBkaXNwbGF5cyBpbiB0aGUgb3ZlcmxheSBjb250YWluZXIuICBPdGhlcndpc2UsIGl0J3MgZGlmZmljdWx0XHJcbiAgICogdG8gc3R5bGUgdGhlIGNvbnRhaW5pbmcgcG9wb3ZlciBmcm9tIG91dHNpZGUgdGhlIGNvbXBvbmVudC5cclxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYHBhbmVsQ2xhc3NgIGluc3RlYWQuXHJcbiAgICovXHJcbiAgQElucHV0KClcclxuICBnZXQgY2xhc3NMaXN0KCk6IHN0cmluZyB7IHJldHVybiB0aGlzLnBhbmVsQ2xhc3M7IH1cclxuICBzZXQgY2xhc3NMaXN0KGNsYXNzZXM6IHN0cmluZykgeyB0aGlzLnBhbmVsQ2xhc3MgPSBjbGFzc2VzOyB9XHJcblxyXG4gIC8qKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIHBvcG92ZXIgaXMgY2xvc2VkLiAqL1xyXG4gIEBPdXRwdXQoKSBjbG9zZSA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcclxuXHJcbiAgQFZpZXdDaGlsZChUZW1wbGF0ZVJlZikgdGVtcGxhdGVSZWY6IFRlbXBsYXRlUmVmPGFueT47XHJcblxyXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYpIHtcclxuICAgIHRoaXMuc2V0UG9zaXRpb25DbGFzc2VzKCk7XHJcbiAgfVxyXG5cclxuICBuZ09uRGVzdHJveSgpIHtcclxuICAgIHRoaXMuX2VtaXRDbG9zZUV2ZW50KCk7XHJcbiAgICB0aGlzLmNsb3NlLmNvbXBsZXRlKCk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLyoqIEhhbmRsZSBhIGtleWJvYXJkIGV2ZW50IGZyb20gdGhlIHBvcG92ZXIsIGRlbGVnYXRpbmcgdG8gdGhlIGFwcHJvcHJpYXRlIGFjdGlvbi4gKi9cclxuICBfaGFuZGxlS2V5ZG93bihldmVudDogS2V5Ym9hcmRFdmVudCkge1xyXG4gICAgc3dpdGNoIChldmVudC5rZXlDb2RlKSB7XHJcbiAgICAgIGNhc2UgRVNDQVBFOlxyXG4gICAgICAgIHRoaXMuX2VtaXRDbG9zZUV2ZW50KCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBlbWl0cyBhIGNsb3NlIGV2ZW50IHRvIHdoaWNoIHRoZSB0cmlnZ2VyIGlzIHN1YnNjcmliZWQuIFdoZW4gZW1pdHRlZCwgdGhlXHJcbiAgICogdHJpZ2dlciB3aWxsIGNsb3NlIHRoZSBwb3BvdmVyLlxyXG4gICAqL1xyXG4gIF9lbWl0Q2xvc2VFdmVudCgpOiB2b2lkIHtcclxuICAgIHRoaXMuY2xvc2UuZW1pdCgpO1xyXG4gIH1cclxuXHJcbiAgLyoqIENsb3NlIHBvcG92ZXIgb24gY2xpY2sgaWYgY2xvc2VPbkNsaWNrIGlzIHRydWUgKi9cclxuICBvbkNsaWNrKCkge1xyXG4gICAgaWYgKHRoaXMuY2xvc2VPbkNsaWNrKSB7XHJcbiAgICAgIHRoaXMuX2VtaXRDbG9zZUV2ZW50KCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUT0RPOiBSZWZhY3RvciB3aGVuIEBhbmd1bGFyL2NkayBpbmNsdWRlcyBmZWF0dXJlIEkgbWVudGlvbmVkIG9uIGdpdGh1YiBzZWUgbGluayBiZWxvdy5cclxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9tYXRlcmlhbDIvcHVsbC81NDkzI2lzc3VlY29tbWVudC0zMTMwODUzMjNcclxuICAgKi9cclxuICAvKiogRGlzYWJsZXMgY2xvc2Ugb2YgcG9wb3ZlciB3aGVuIGxlYXZpbmcgdHJpZ2dlciBlbGVtZW50IGFuZCBtb3VzZSBvdmVyIHRoZSBwb3BvdmVyICovXHJcbiAgb25Nb3VzZU92ZXIoKSB7XHJcbiAgICBpZiAodGhpcy50cmlnZ2VyRXZlbnQgPT09ICdob3ZlcicpIHtcclxuICAgICAgdGhpcy5jbG9zZURpc2FibGVkID0gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcbiAgLyoqIEVuYWJsZXMgY2xvc2Ugb2YgcG9wb3ZlciB3aGVuIG1vdXNlIGxlYXZpbmcgcG9wb3ZlciBlbGVtZW50ICovXHJcbiAgb25Nb3VzZUxlYXZlKCkge1xyXG4gICAgaWYgKHRoaXMudHJpZ2dlckV2ZW50ID09PSAnaG92ZXInKSB7XHJcbiAgICAgIHRoaXMuY2xvc2VEaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgICB0aGlzLl9lbWl0Q2xvc2VFdmVudCgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gVE9ETzogUmVmYWN0b3IgaG93IHN0eWxlcyBhcmUgc2V0IGFuZCB1cGRhdGVkIG9uIHRoZSBjb21wb25lbnQsIHVzZSBiZXN0IHByYWN0aWNlcy5cclxuICAvLyBUT0RPOiBJZiBhcnJvdyBsZWZ0IGFuZCByaWdodCBwb3NpdGlvbmluZyBpcyByZXF1ZXN0ZWQsIHNlZSBpZiBmbGV4IGRpcmVjdGlvbiBjYW4gYmUgdXNlZCB0byB3b3JrIHdpdGggb3JkZXIuXHJcbiAgLyoqIFNldHMgdGhlIGN1cnJlbnQgc3R5bGVzIGZvciB0aGUgcG9wb3ZlciB0byBhbGxvdyBmb3IgZHluYW1pY2FsbHkgY2hhbmdpbmcgc2V0dGluZ3MgKi9cclxuICBzZXRDdXJyZW50U3R5bGVzKCkge1xyXG5cclxuICAgIC8vIFRPRE86IFNlZSBpZiBhcnJvdyBwb3NpdGlvbiBjYW4gYmUgY2FsY3VsYXRlZCBhdXRvbWF0aWNhbGx5IGFuZCBhbGxvdyBvdmVycmlkZS5cclxuICAgIC8vIFRPRE86IFNlZSBpZiBmbGV4IG9yZGVyIGlzIGEgYmV0dGVyIGFsdGVybmF0aXZlIHRvIHBvc2l0aW9uIGFycm93IHRvcCBvciBib3R0b20uXHJcbiAgICB0aGlzLnBvcG92ZXJBcnJvd1N0eWxlcyA9IHtcclxuICAgICAgJ3JpZ2h0JzogdGhpcy5wb3NpdGlvblggPT09ICdiZWZvcmUnID8gKHRoaXMuYXJyb3dPZmZzZXRYIC0gdGhpcy5hcnJvd1dpZHRoKSArICdweCcgOiAnJyxcclxuICAgICAgJ2xlZnQnOiB0aGlzLnBvc2l0aW9uWCA9PT0gJ2FmdGVyJyA/ICh0aGlzLmFycm93T2Zmc2V0WCAtIHRoaXMuYXJyb3dXaWR0aCkgKyAncHgnIDogJycsXHJcbiAgICAgICdib3JkZXItdG9wJzogdGhpcy5wb3NpdGlvblkgPT09ICdiZWxvdycgP1xyXG4gICAgICAgIHRoaXMuYXJyb3dXaWR0aCArICdweCBzb2xpZCAnICsgdGhpcy5hcnJvd0NvbG9yIDogJzBweCBzb2xpZCB0cmFuc3BhcmVudCcsXHJcbiAgICAgICdib3JkZXItcmlnaHQnOiAndW5kZWZpbmVkJyA9PT0gdW5kZWZpbmVkID9cclxuICAgICAgICB0aGlzLmFycm93V2lkdGggKyAncHggc29saWQgJyArIHRoaXMuYXJyb3dDb2xvciA6XHJcbiAgICAgICAgdGhpcy5hcnJvd1dpZHRoICsgJ3B4IHNvbGlkIHRyYW5zcGFyZW50JyxcclxuICAgICAgJ2JvcmRlci1ib3R0b20nOiB0aGlzLnBvc2l0aW9uWSA9PT0gJ2Fib3ZlJyA/XHJcbiAgICAgICAgdGhpcy5hcnJvd1dpZHRoICsgJ3B4IHNvbGlkICcgKyB0aGlzLmFycm93Q29sb3IgOlxyXG4gICAgICAgIHRoaXMuYXJyb3dXaWR0aCArICdweCBzb2xpZCB0cmFuc3BhcmVudCcsXHJcbiAgICAgICdib3JkZXItbGVmdCc6ICd1bmRlZmluZWQnID09PSB1bmRlZmluZWQgP1xyXG4gICAgICAgIHRoaXMuYXJyb3dXaWR0aCArICdweCBzb2xpZCAnICsgdGhpcy5hcnJvd0NvbG9yIDpcclxuICAgICAgICB0aGlzLmFycm93V2lkdGggKyAncHggc29saWQgdHJhbnNwYXJlbnQnLFxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBUT0RPOiBSZW1vdmUgaWYgZmxleCBvcmRlciBpcyBhZGRlZC5cclxuICAgIHRoaXMucG9wb3ZlckNvbnRlbnRTdHlsZXMgPSB7XHJcbiAgICAgICdwYWRkaW5nLXRvcCc6IHRoaXMub3ZlcmxhcFRyaWdnZXIgPT09IHRydWUgPyAnMHB4JyA6IHRoaXMuYXJyb3dXaWR0aCArICdweCcsXHJcbiAgICAgICdwYWRkaW5nLWJvdHRvbSc6IHRoaXMub3ZlcmxhcFRyaWdnZXIgPT09IHRydWUgPyAnMHB4JyA6ICh0aGlzLmFycm93V2lkdGgpICsgJ3B4JyxcclxuICAgICAgJ21hcmdpbi10b3AnOiB0aGlzLm92ZXJsYXBUcmlnZ2VyID09PSBmYWxzZSAmJiB0aGlzLnBvc2l0aW9uWSA9PT0gJ2JlbG93JyAmJiB0aGlzLmNvbnRhaW5lclBvc2l0aW9uaW5nID09PSBmYWxzZSA/XHJcbiAgICAgICAgLSh0aGlzLmFycm93V2lkdGggKiAyKSArICdweCcgOiAnMHB4J1xyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEl0J3MgbmVjZXNzYXJ5IHRvIHNldCBwb3NpdGlvbi1iYXNlZCBjbGFzc2VzIHRvIGVuc3VyZSB0aGUgcG9wb3ZlciBwYW5lbCBhbmltYXRpb25cclxuICAgKiBmb2xkcyBvdXQgZnJvbSB0aGUgY29ycmVjdCBkaXJlY3Rpb24uXHJcbiAgICovXHJcbiAgc2V0UG9zaXRpb25DbGFzc2VzKHBvc1ggPSB0aGlzLnBvc2l0aW9uWCwgcG9zWSA9IHRoaXMucG9zaXRpb25ZKTogdm9pZCB7XHJcbiAgICB0aGlzLl9jbGFzc0xpc3RbJ21kZS1wb3BvdmVyLWJlZm9yZSddID0gcG9zWCA9PT0gJ2JlZm9yZSc7XHJcbiAgICB0aGlzLl9jbGFzc0xpc3RbJ21kZS1wb3BvdmVyLWFmdGVyJ10gPSBwb3NYID09PSAnYWZ0ZXInO1xyXG4gICAgdGhpcy5fY2xhc3NMaXN0WydtZGUtcG9wb3Zlci1hYm92ZSddID0gcG9zWSA9PT0gJ2Fib3ZlJztcclxuICAgIHRoaXMuX2NsYXNzTGlzdFsnbWRlLXBvcG92ZXItYmVsb3cnXSA9IHBvc1kgPT09ICdiZWxvdyc7XHJcbiAgfVxyXG59XHJcbiJdfQ==